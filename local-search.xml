<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Introduction of ROS2</title>
    <link href="/2023/02/ros2-intro/"/>
    <url>/2023/02/ros2-intro/</url>
    
    <content type="html"><![CDATA[<p>当前ROS2已经成为了应用最为广泛的机器人应用程序开发SDK之一，它拥有先进的分布式架构、更好的可靠性、实时性以及嵌入式设备支持。ROS2的诞生主要源于以下三个方面：</p><ol><li>ROS1的历史遗留问题</li><li>机器人技术经过多年的发展产生了新的需求</li><li>在ROS发展的时间里产生了很多新的技术</li></ol><h1 id="History-from-ROS-to-ROS2"><a href="#History-from-ROS-to-ROS2" class="headerlink" title="History from ROS to ROS2"></a>History from ROS to ROS2</h1><p><img src="https://robots.ieee.org/robots/pr2/Photos/SD/pr2-photo1-full.jpg"></p><p>ROS最初的设计是为了给使用Willow Garage PR2机器人进行研究的项目或实验室提供便于使用的软件开发工具。为了提高系统的通用性，开发团队在抽象层花了很多功夫，特别的消息接口的设计与实现上。因此ROS具有了极高的复用性，大部分组件也可以用在其他大部分的机器人应用程序中。但是在当时ROS诞生的时期，也主要是面向学术研究使用，研究人员的主要需求也就如下一些内容：</p><ol><li>应用于单个机器人</li><li>拥有工作站级别的计算资源</li><li>基本没有实时性要求（有实时性要求的组件会有特定的解决方案）</li><li>高性能的网络连接能力（大带宽的有线或近距离无线连接）</li><li>主要应用于学术研究，最大化灵活性，没有任何限制和约束</li></ol><p>这些特性在ROS中都有着不错的实现，能比较完美地满足之前所提出的需求。但是ROS得发展远远超出了开发团队得预期，无论是轮式机器人、足式机器人甚至是工业机械臂等商业产品和项目都在应用ROS框架进行软件开发。随着应用场景的日益增加，也就伴随了新需求和新技术。</p><p>如今新的场景与需求：</p><ol><li>集群机器人开发（当前也有许多开发者使用ROS进行集群开发，但是业内目前没有统一的标准，大部分开发者也只是在ROS当前的单master节点上进行hack）</li><li>对于嵌入式设备的支持（让裸板的嵌入式设备原生接入ROS，而不是通过上位机的驱动接入）</li><li>实时性要求（在ROS上原生支持实时控制，而不用像之前一样通过特定的组件）</li><li>非理想网络条件（用来应对延迟、丢包、断连的场景）</li><li>应对生产环境（更好的稳定性和真实环境中的鲁棒性）</li><li>构建系统的规范与限制（在保持灵活性的同时让系统或配置更有条理）</li></ol><h1 id="New-technologies"><a href="#New-technologies" class="headerlink" title="New technologies"></a>New technologies</h1><p>ROS2依然是围绕着最核心的匿名消息发布和订阅机制进行起草的，在ROS1的基础上引入了许多新技术来满足新的需求，例如：</p><ul><li>Zeroconf（零网络配置，用于快速组网）</li><li>Protocol Buffers（跨平台序列化数据结构的协议）</li><li><a href="https://design.ros2.org/articles/ros_with_zeromq.html">ZeroMQ</a> (and the other MQs)（异步消息传递库，应用于分布式或并发应用程序）</li><li>Redis（分布式高性能缓存服务）</li><li>WebSockets</li><li><a href="https://design.ros2.org/articles/ros_on_dds.html">DDS</a> (Data Distribution Service)（实时数据分发服务）</li></ul><h1 id="Build-Tool"><a href="#Build-Tool" class="headerlink" title="Build Tool"></a>Build Tool</h1><p>在ROS生态中，应用程序通常被分割为许多软件包，开发人员同时处理多个软件包的场景也是很常见的。这与传统的软件开发流程中开发者只面对一个软件包，并一次性提供所有需要依赖的软件包（这部分依赖通常没有迭代）的场景形成了鲜明对比。</p><p>构建一组软件包的“手动”方法包括逐一构建所有软件包。对于每个软件包如何管理相互之间的依赖关系，如何设置环境以构建软件包，以及如何在之后设置环境以使用软件包。如果没有自动化该过程的工具，这样的工作流程在规模化开发时是不切实际的。</p><p>在ROS1中有多个工具提供以上流程的自动化支持，即<code>catkin_make</code>、<code>catkin_make_isolated</code>和<code>catkin_tools</code>。对于ROS 2，提供此功能的构建工具称为<code>ament_tools</code>。</p><h2 id="Build-tool-amp-build-system"><a href="#Build-tool-amp-build-system" class="headerlink" title="Build tool &amp; build system"></a>Build tool &amp; build system</h2><p>构建工具在一组软件包上运行，它确定依赖关系图，并按拓扑顺序为每个包调用特定的构建系统。ROS所使用的构建工具有<code>catkin_make</code>、<code>catkin_make_isolated</code>、<code>catkin_tools</code>和<code>ament_tools</code>。</p><p>构建系统在单个软件包上运行。例如<code>Make</code>、<code>CMake</code>、Python <code>Python setuptools</code>。例如cmake软件包通过以下流程完成构建：<code>cmake</code>，<code>make</code>，<code>make install</code>。</p><h2 id="Goals-of-ament-tools"><a href="#Goals-of-ament-tools" class="headerlink" title="Goals of ament_tools"></a>Goals of ament_tools</h2><p>统一构建工具的目标是构建一组具有单向依赖的软件包。它应该适用于ROS 1软件包以及在其清单文件（package.xml）中提供必要信息的ROS 2软件包。它还应该适用于本身不提供清单文件的软件包，因为必要的元信息可以推断或外部提供。这将允许将构建工具用于非ROS软件包，例如Gazebo的某些插件和SDFormat格式的地图信息。</p><h2 id="Build-pipeline-of-ament-tools"><a href="#Build-pipeline-of-ament-tools" class="headerlink" title="Build pipeline of ament_tools"></a>Build pipeline of ament_tools</h2><p>初始化构建环境⬇️</p><p>识别并组织不同的构建系统⬇️</p><p>计算软件包依赖拓扑⬇️</p><p>调用构建系统完成构建⬇️</p><h2 id="Related-topics"><a href="#Related-topics" class="headerlink" title="Related topics"></a>Related topics</h2><p>超出构建工具之外的能力</p><ul><li>应对包含多种构建系统的工程</li><li>拉取源代码 <a href="http://wiki.ros.org/rosinstall_generator">rosinstall_generator</a> </li><li>安装依赖<a href="http://wiki.ros.org/rosdep">rosdep</a></li><li>创建和发布二进制包 <a href="http://wiki.ros.org/bloom">bloom</a></li></ul><h1 id="Compared-with-ROS1"><a href="#Compared-with-ROS1" class="headerlink" title="Compared with ROS1"></a>Compared with ROS1</h1><table><thead><tr><th></th><th>ROS1</th><th>ROS2</th></tr></thead><tbody><tr><td>操作系统</td><td>最初仅支持应用于Linux操作系统（之后官方也有提供Windows的版本）</td><td>完全跨平台，支持Linux、Windows、MacOS甚至RTOS</td></tr><tr><td>C++标准</td><td>C++03</td><td>主要是C++11和14，之后会逐步迁移到C++17</td></tr><tr><td>构建系统</td><td>catkin</td><td>colcon（ament_cmake）原生支持除cmake外的一些构建系统</td></tr><tr><td>isolated build</td><td>默认整体构建，可选是否单独构建某一个软件包（每个包需要保证依赖完整，同时共享命名空间容易造成命名冲突）</td><td>仅支持单独构建每一个包</td></tr><tr><td>中间件</td><td>采用TCP&#x2F;IP协议作为通讯标准</td><td>使用了实时的通讯框架DDS以满足实时性要求</td></tr><tr><td>应用框架</td><td>采用单master架构设计，一旦master节点出现问题，整个系统将无法工作<img src="https://www.circuspi.com/wp-content/uploads/2022/09/1.png"></td><td>采用了分布式的发现机制组网，这样其中的任何一个节点出现异常都不会导致整个系统停止工作<img src="https://www.circuspi.com/wp-content/uploads/2022/09/2.png"></td></tr></tbody></table><h1 id="Migrate-to-ROS2"><a href="#Migrate-to-ROS2" class="headerlink" title="Migrate to ROS2"></a>Migrate to ROS2</h1><h2 id="Prerequisites-amp-Steps"><a href="#Prerequisites-amp-Steps" class="headerlink" title="Prerequisites &amp; Steps"></a>Prerequisites &amp; Steps</h2><ul><li><a href="https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Migration-Guide.html#prerequisites">Prerequisites</a></li><li><a href="https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Migration-Guide.html#migration-steps">Migration steps</a><ul><li><a href="https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Migration-Guide.html#package-manifests">Package manifests</a></li><li><a href="https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Migration-Guide.html#metapackages">Metapackages</a></li><li><a href="https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Migration-Guide.html#message-service-and-action-definitions">Message, service, and action definitions</a></li><li><a href="https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Migration-Guide.html#build-system">Build system</a></li><li><a href="https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Migration-Guide.html#update-source-code">Update source code</a></li></ul></li><li><a href="https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Migration-Guide.html#parameters">Parameters</a></li><li><a href="https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Migration-Guide.html#launch-files">Launch files</a></li></ul><h2 id="Migration-example"><a href="#Migration-example" class="headerlink" title="Migration example"></a>Migration example</h2><p>ROS1: <a href="https://github.com/Jason-xy/VINS-Fusion/tree/master">https://github.com/Jason-xy/VINS-Fusion/tree/master</a></p><p>ROS2: <a href="https://github.com/Jason-xy/VINS-Fusion/tree/cuda">https://github.com/Jason-xy/VINS-Fusion/tree/cuda</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://design.ros2.org/articles/why_ros2.html">Why ROS 2?</a></li><li><a href="https://design.ros2.org/articles/build_tool.html">A universal build tool</a></li><li><a href="https://design.ros2.org/articles/changes.html">Changes between ROS 1 and ROS 2</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Robotics</category>
      
      <category>Syste</category>
      
    </categories>
    
    
    <tags>
      
      <tag>colcon</tag>
      
      <tag>ROS2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS package发布工作流</title>
    <link href="/2022/12/ros-pkg-distro/"/>
    <url>/2022/12/ros-pkg-distro/</url>
    
    <content type="html"><![CDATA[<p>对于API相对稳定的ROS package通常会采用二进制发布的方式向社区项目提供支持，这里的二进制发布有许多可选的流程，最终的包形态也不尽相同，不同的包发布方式也各有优劣。当前较为主流的包发布方式还是以ROS社区的bloom+ros_buildfarm为主，但是很多特定场景下开发者们也可能通过snapshot&#x2F;bundle或者container的形式进行发布。最近为了解决上述发布形式的一些问题也有开发者提出了基于nix的发布方式，以及结合C++包管理工具Conan进行发布的一系列方法。</p><h2 id="现状分析"><a href="#现状分析" class="headerlink" title="现状分析"></a>现状分析</h2><h3 id="当前常见包发布流程特点"><a href="#当前常见包发布流程特点" class="headerlink" title="当前常见包发布流程特点"></a>当前常见包发布流程特点</h3><table><thead><tr><th>bloom+ros_buildfarm</th><th>snapshot&#x2F;bundle&#x2F;container</th></tr></thead><tbody><tr><td>支持增量构建</td><td>环境版本化，可回退</td></tr><tr><td>强制要求每次发布打tag</td><td>编译资源、存储资源网络资源消耗巨大</td></tr><tr><td>对于下游项目缺乏系统集成后的版本管理</td><td>没有统一工具集</td></tr><tr><td>无回退流程</td><td></td></tr><tr><td>发布为.deb存入apt源</td><td></td></tr></tbody></table><p>上述发布流程中大部分情况只对模块本身进行自测，将集成测试推后，模块自身API的稳定性和向前兼容性是二进制版本发布的前提。</p><h3 id="可能的包发布流程需求"><a href="#可能的包发布流程需求" class="headerlink" title="可能的包发布流程需求"></a>可能的包发布流程需求</h3><ul><li>支持增量构建</li><li>环境版本化，可回退</li><li>统一的框架和工具集</li></ul><h3 id="可能难以解决的问题"><a href="#可能难以解决的问题" class="headerlink" title="可能难以解决的问题"></a>可能难以解决的问题</h3><p>对于二进制集成的迭代模式，下游项目通常选择可用版本进行集成，放在末端项目级别来考虑的话如果涉及对已发布包的变更和再次发布的需求，往往相比于直接源码集成迭代周期会被出包+验证流程拉长。</p><h2 id="ROS-Build-Farm"><a href="#ROS-Build-Farm" class="headerlink" title="ROS Build Farm"></a>ROS Build Farm</h2><p>ROS Build Farm 是支持 ROS 生态系统的重要基础设施之一。它提供源代码和二进制包的构建、持续集成、测试和分析。它旨在满足公共 ROS 社区的需求，并且在 <a href="http://build.ros.org/">http://build.ros.org/</a> 上有一个开源包的托管实例。</p><p>ROS Build Farm 还旨在支持部署自定义构建农场。这对于发布闭源包、为官方 ROS 构建农场未提供的平台和架构构建或根据特定需求定制过程的场景很有用。</p><p>构建的各项工作主要由 Jenkins 实例完成。当然还有其他人将这些工具与 Build Bot 一起使用。ROS Build Farm 的设计目标是大部分基础设施是模块化的和可重用的。</p><h3 id="release准备"><a href="#release准备" class="headerlink" title="release准备"></a>release准备</h3><p>更新源码仓库change log：<code>b</code></p><p>更新源码仓库版本、tag信息，并push至release仓库： <code>catkin_prepare_release</code></p><p>更新release仓库，准备进行新的一次release：<code>bloom-release</code></p><p>bloom会自动向rosdistro仓库提交pr，以vision_opencv的一次release为例：</p><blockquote><h2 id="vision-opencv-foxy-3-0-7-1"><a href="#vision-opencv-foxy-3-0-7-1" class="headerlink" title="vision_opencv (foxy) - 3.0.7-1"></a>vision_opencv (foxy) - 3.0.7-1</h2><p>The packages in the <code>vision_opencv</code> repository were released into the <code>foxy</code> distro by running <code>/usr/bin/bloom-release --rosdistro foxy vision_opencv</code> on <code>Sat, 15 Oct 2022 13:19:59 -0000</code></p><p><strong>These packages were released:</strong></p><ul><li><code>cv_bridge</code></li><li><code>image_geometry</code></li><li><code>vision_opencv</code></li></ul><p><strong>These packages were explicitly ignored:</strong></p><ul><li><code>opencv_tests</code></li></ul><p>Version of package(s) in repository <code>vision_opencv</code>:</p><ul><li>upstream repository: <a href="https://github.com/ros-perception/vision_opencv.git">https://github.com/ros-perception/vision_opencv.git</a></li><li>release repository: <a href="https://github.com/ros2-gbp/vision_opencv-release.git">https://github.com/ros2-gbp/vision_opencv-release.git</a></li><li>rosdistro version: <code>3.0.6-1</code></li><li>old version: <code>3.0.6-1</code></li><li>new version: <code>3.0.7-1</code></li></ul><p><strong>Versions of tools used:</strong></p><ul><li>bloom version:  <code>0.11.2</code></li><li>catkin_pkg version: <code>0.5.2</code></li><li>rosdep version: <code>0.22.1</code></li><li>rosdistro version: <code>0.9.0</code></li><li>vcstools version: <code>0.1.42</code></li></ul></blockquote><h3 id="编译农场"><a href="#编译农场" class="headerlink" title="编译农场"></a>编译农场</h3><p><strong>rosdistro_cache job</strong></p><p>每五分钟同步一次ros&#x2F;rosdistro的变更</p><p>gzip压缩后的yaml文件包含：</p><ul><li>distribution_file：ros&#x2F;rosdistro中的distribution_file拷贝</li><li>release_repo_package_xmls：当前发布的包版本中的 package.xml 内容</li><li>source_repo_package_xmls：空，获取源package.xml比较棘手</li><li>name：分发包名</li><li>type, version：REP-141 格式的信息</li></ul><p>job内容：</p><ol><li>生成一个新的 rosdistro 缓存文件并将其上传到存储库主机</li><li>每五分钟运行一次</li><li>通过HTTPS轮询distribution.yaml 更改</li><li>由于 CDN 缓存，更改有时会滞后</li><li>触发器为更新的包重新配置作业</li></ol><p><strong>reconfigure job</strong></p><p>rosdistro_cache job拉取变更后将会触发包变更的版本分发配置</p><ul><li>每次job对应ros_buildfarm_config中的一个构建文件</li><li>使用发布构建配置和ros_buildfarm模板为每个包生成一个sourcepkg和binarypkg job</li><li>当由rosdistro缓存触发以更新更改的包时运行</li><li>每24小时运行一次以保持job配置最新</li></ul><p><strong>release trigger job</strong></p><ul><li>每次job对应ros_buildfarm_config中的一个构建文件</li><li>将构建存储库中的包与基于rosdistro缓存的预期包进行比较，并触发sourcepkg和binarypkg job来实施变更</li></ul><p>job参数</p><p>missing only – 为存储库中不存在的包触发job</p><p>source only – 仅触发源码包的job； 当需要在重建二进制文件之前更新源码包时很有用</p><p>packaging job</p><p>每15分钟执行一次发生变更的包的打包</p><p><strong>source package job</strong></p><ul><li>根据ros2-gbp仓库中的平台元数据拉取包的源码，并创建不同平台的源码包（Ubuntu&#x2F;Fedora），同时上传至构建仓库</li><li>不使用colcon、rosdep、bloom 等ROS 工具。 此时所有包信息都已呈现为特定于发行版的格式</li><li>成功构建将触发二进制包构建，用于从创建的源码包生成的所有二进制包</li><li>导入新的源码包时删除旧的二进制包</li></ul><p><strong>binary package job</strong></p><ul><li>从构建存储库中获取源代码</li><li>安装构建依赖项</li><li>将创建的二进制包上传到构建存储库</li><li>不使用colcon、rosdep、bloom 等ROS 工具。 此时所有包信息都已呈现为特定于发行版的格式</li><li>成功的构建将使新构建的二进制包导入构建存储库并使其下游的所有包无效</li></ul><p><strong>包失效</strong></p><ul><li>删除所有递归依赖于新重建包的包</li><li>防止生产环境中的ABI被破坏</li><li>API更改时对下游包的即时反馈</li></ul><p><strong>同步任务</strong></p><p><strong>sync to testing job</strong></p><ul><li>从测试存储库中删除所有与job rosdistro、平台版本和体系结构相匹配的 ROS 包，以及相关的源码包</li><li>从符合相同条件的构建库中导入所有ROS包</li><li>当不再有出包的job时，包将被删除</li><li>所有出二进制包和源代码包job都会block测试job，因此这些job只在完全重新构建时执行</li><li>设置了自动阈值以防止缺陷版本清除测试存储库</li></ul><p><strong>sync to main job</strong></p><ul><li>从main存储库中删除所有与job rosdistro、平台版本和体系结构相匹配的 ROS 包，以及相关的源码包</li><li>只会由ros核心团队手动执行</li></ul><p><strong>发布流程全景图</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/PicGo/202212182314038.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Robotics</category>
      
      <category>System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>robotic</tag>
      
      <tag>drone</tag>
      
      <tag>ROS</tag>
      
      <tag>catkin</tag>
      
      <tag>colcon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将ros package从ros1迁移至ros2</title>
    <link href="/2022/12/Migration-from-ROS1-to-ROS2/"/>
    <url>/2022/12/Migration-from-ROS1-to-ROS2/</url>
    
    <content type="html"><![CDATA[<p>总体来说从ros1迁移至ros2的过程还是比较简单的，基本上是在ros1的package基础上针对ros2的差异进行一些改动和适配。</p><p>catkin package与colcon package的差异主要体现在以下几个方面：</p><ol><li>构建系统：catkin-&gt;colcon</li><li>ros组件：roscpp-&gt;rclcpp</li><li>源码：部分模块命名空间有区别</li></ol><h2 id="迁移步骤"><a href="#迁移步骤" class="headerlink" title="迁移步骤"></a>迁移步骤</h2><p>以vins-fusion中的loop_fusion模块为例</p><h3 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h3><p>ros2对package.xml的格式有新的要求，不在支持format 1，需要将格式更新到format 2及以上，具体体现如下：</p><p>ros1</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ros2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;?xml-model href=<span class="hljs-string">&quot;http://download.ros.org/schema/package_format3.xsd&quot;</span> schematypens=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure><p>buildtool_depend字段从catkin更换为ament_cmake，build_type字段也更换为ament_cmake，具体体现如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;?xml-model href=<span class="hljs-string">&quot;http://download.ros.org/schema/package_format3.xsd&quot;</span> schematypens=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>  ...<br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>ament_cmake<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br>  ...<br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">export</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build_type</span>&gt;</span>ament_cmake<span class="hljs-tag">&lt;/<span class="hljs-name">build_type</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure><p>depend字段中的roscpp也需要更换为rclcpp，rospy需要更换为rclpy,如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>rclcpp<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>rclpy<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ros2对组件中的message package也有一些调整，需要指出对相应的msg的依赖，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>std_msgs<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>sensor_msgs<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>visualization_msgs<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>nav_msgs<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完整的package.xml如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;?xml-model href=<span class="hljs-string">&quot;http://download.ros.org/schema/package_format3.xsd&quot;</span> schematypens=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>loop_fusion<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>loop_fusion package<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;tony-ws@todo.todo&quot;</span>&gt;</span>tony-ws<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>TODO: License declaration<span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>ament_cmake<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>rclcpp<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>ament_index_cpp<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>std_msgs<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>sensor_msgs<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>visualization_msgs<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>nav_msgs<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>cv_bridge<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">depend</span>&gt;</span>camera_models<span class="hljs-tag">&lt;/<span class="hljs-name">depend</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">export</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build_type</span>&gt;</span>ament_cmake<span class="hljs-tag">&lt;/<span class="hljs-name">build_type</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">export</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h3><p>cmake最低版本要求需要3.5以上：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cmake_minimum_required</span><span class="hljs-params">(VERSION <span class="hljs-number">3.10</span>)</span></span><br></code></pre></td></tr></table></figure><p>C&#x2F;C++代码需要依照C14标准，否则会报编译错误：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)</span></span><br></code></pre></td></tr></table></figure><p>改变对ros组件依赖的查找方式：</p><p>对比ros1与ros2：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scss"># ROS1<br><span class="hljs-built_in">find_package</span>(catkin REQUIRED COMPONENTS<br>    roscpp<br>    std_msgs<br>    nav_msgs<br>    camera_models<br>    cv_bridge<br>    roslib<br>    )<br><br># ROS2<br><span class="hljs-built_in">find_package</span>(ament_cmake REQUIRED)<br><span class="hljs-built_in">find_package</span>(rclcpp REQUIRED)<br><span class="hljs-built_in">find_package</span>(ament_index_cpp REQUIRED)<br><span class="hljs-built_in">find_package</span>(std_msgs REQUIRED)<br><span class="hljs-built_in">find_package</span>(sensor_msgs REQUIRED)<br><span class="hljs-built_in">find_package</span>(visualization_msgs REQUIRED)<br><span class="hljs-built_in">find_package</span>(nav_msgs REQUIRED)<br><span class="hljs-built_in">find_package</span>(cv_bridge REQUIRED)<br><span class="hljs-built_in">find_package</span>(camera_models REQUIRED)<br></code></pre></td></tr></table></figure><p>在include_directories中去除对catkin头文件依赖。</p><p>通过ament_target_dependencies描述ros2依赖：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ament<span class="hljs-constructor">_target_dependencies(<span class="hljs-params">loop_fusion_node</span> <span class="hljs-params">camera_models</span> <span class="hljs-params">rclcpp</span> <span class="hljs-params">ament_index_cpp</span> <span class="hljs-params">std_msgs</span> <span class="hljs-params">sensor_msgs</span> <span class="hljs-params">visualization_msgs</span> <span class="hljs-params">nav_msgs</span> <span class="hljs-params">cv_bridge</span> OpenCV)</span><br></code></pre></td></tr></table></figure><p>安装编译产物：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">install</span>(<br>  TARGETS loop_fusion_node<br>  DESTINATION lib/$&#123;PROJECT_NAME&#125;<br>)<br><span class="hljs-built_in">install</span>(TARGETS<br>   loop_fusion_node<br>   DESTINATION lib/$&#123;PROJECT_NAME&#125;<br>)<br><span class="hljs-built_in">install</span>(TARGETS loop_fusion_node<br>   ARCHIVE DESTINATION lib<br>   LIBRARY DESTINATION lib<br>   RUNTIME DESTINATION bin<br>)<br><span class="hljs-built_in">install</span>(TARGETS loop_fusion_node<br>   RUNTIME DESTINATION lib/$&#123;PROJECT_NAME&#125;<br>)<br></code></pre></td></tr></table></figure><p>最后把catkin_package换成ament_package:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ament_package</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>完整的CMakeLists.txt如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-built_in">project</span>(loop_fusion)<br><br><span class="hljs-built_in">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<br><span class="hljs-built_in">set</span>(CMAKE_BUILD_TYPE &quot;Release&quot;)<br><span class="hljs-built_in">set</span>(CMAKE_CXX_FLAGS_RELEASE &quot;-O3 -Wall -g&quot;)<br><br><span class="hljs-built_in">find_package</span>(ament_cmake REQUIRED)<br><span class="hljs-built_in">find_package</span>(rclcpp REQUIRED)<br><span class="hljs-built_in">find_package</span>(ament_index_cpp REQUIRED)<br><span class="hljs-built_in">find_package</span>(std_msgs REQUIRED)<br><span class="hljs-built_in">find_package</span>(sensor_msgs REQUIRED)<br><span class="hljs-built_in">find_package</span>(visualization_msgs REQUIRED)<br><span class="hljs-built_in">find_package</span>(nav_msgs REQUIRED)<br><span class="hljs-built_in">find_package</span>(cv_bridge REQUIRED)<br><span class="hljs-built_in">find_package</span>(camera_models REQUIRED)<br><span class="hljs-built_in">find_package</span>(OpenCV)<br><span class="hljs-built_in">find_package</span>(Ceres REQUIRED)<br><br><span class="hljs-built_in">set</span>(CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake)<br><span class="hljs-built_in">find_package</span>(Eigen3)<br><span class="hljs-built_in">include_directories</span>($&#123;CERES_INCLUDE_DIRS&#125;  $&#123;EIGEN3_INCLUDE_DIR&#125;)<br><br><span class="hljs-built_in">add_executable</span>(loop_fusion_node<br>    src/pose_graph_node.cpp<br>    src/pose_graph.cpp<br>    src/keyframe.cpp<br>    src/utility/CameraPoseVisualization.cpp<br>    src/ThirdParty/DBoW/BowVector.cpp<br>    src/ThirdParty/DBoW/FBrief.cpp<br>    src/ThirdParty/DBoW/FeatureVector.cpp<br>    src/ThirdParty/DBoW/QueryResults.cpp<br>    src/ThirdParty/DBoW/ScoringObject.cpp<br>    src/ThirdParty/DUtils/Random.cpp<br>    src/ThirdParty/DUtils/Timestamp.cpp<br>    src/ThirdParty/DVision/BRIEF.cpp<br>    src/ThirdParty/VocabularyBinary.cpp<br>    )<br><br><span class="hljs-built_in">ament_target_dependencies</span>(loop_fusion_node camera_models rclcpp ament_index_cpp std_msgs sensor_msgs visualization_msgs nav_msgs cv_bridge OpenCV)<br><span class="hljs-built_in">target_link_libraries</span>(loop_fusion_node $&#123;OpenCV_LIBS&#125; $&#123;CERES_LIBRARIES&#125;)<br><br># Install nodes<br><span class="hljs-built_in">install</span>(<br>  TARGETS loop_fusion_node<br>  DESTINATION lib/$&#123;PROJECT_NAME&#125;<br>)<br><span class="hljs-built_in">install</span>(TARGETS<br>   loop_fusion_node<br>   DESTINATION lib/$&#123;PROJECT_NAME&#125;<br>)<br><span class="hljs-built_in">install</span>(TARGETS loop_fusion_node<br>   ARCHIVE DESTINATION lib<br>   LIBRARY DESTINATION lib<br>   RUNTIME DESTINATION bin<br>)<br><span class="hljs-built_in">install</span>(TARGETS loop_fusion_node<br>   RUNTIME DESTINATION lib/$&#123;PROJECT_NAME&#125;<br>)<br><br><span class="hljs-built_in">ament_package</span>()<br></code></pre></td></tr></table></figure><h3 id="源码修改"><a href="#源码修改" class="headerlink" title="源码修改"></a>源码修改</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p>ros2使用rclcpp替换了roscpp接口，源码里面的改动如下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">//<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span><br></code></pre></td></tr></table></figure><p>对于msg的依赖需要加一级msg目录，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">//#</span><span class="language-bash">include <span class="hljs-string">&quot;std_msgs/String.h&quot;</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">include <span class="hljs-string">&quot;std_msgs/msg/string.hpp&quot;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">//#</span><span class="language-bash">include <span class="hljs-string">&quot;nav_msgs/path.hpp&quot;</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">include nav_msgs/msg/path.hpp<span class="hljs-string">&quot;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">//#</span><span class="language-bash"><span class="hljs-string">include &quot;</span>geometry_msgs/point_stamped.h<span class="hljs-string">&quot;</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">include &quot;</span>geometry_msgs/msg/point_stamped.h<span class="hljs-string">&quot;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">//#</span><span class="language-bash"><span class="hljs-string">include &quot;</span>nav_msgs/odometry.h<span class="hljs-string">&quot;</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">include &quot;</span>nav_msgs/msg/odometry.h<span class="hljs-string">&quot;</span></span><br></code></pre></td></tr></table></figure><h4 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h4><p>rclcpp不是将节点的名称传递给库初始化调用，而是进行初始化，然后将节点名称传递给节点对象的构造器：（auto关键字依赖C14标准编译器）</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//  ros::init(argc, argv, <span class="hljs-string">&quot;talker&quot;</span>);<br>//  ros::NodeHandle n;<br>    rclcpp::init(argc, argv);<br>    auto <span class="hljs-keyword">node</span> <span class="hljs-title">= rclcpp</span>::<span class="hljs-keyword">Node</span><span class="hljs-title">::make_shared</span>(<span class="hljs-string">&quot;talker&quot;</span>);<br></code></pre></td></tr></table></figure><p>publisher和rate对象的命名空间发生了变化：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">//  ros::<span class="hljs-title class_">Publisher</span> chatter_pub = n.advertise&lt;std_msgs::<span class="hljs-title class_">String</span>&gt;(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>);<br>//  ros::<span class="hljs-title class_">Rate</span> loop_rate(<span class="hljs-number">10</span>);<br>  auto chatter_pub = node-&gt;create_publisher&lt;std_msgs::msg::<span class="hljs-title class_">String</span>&gt;(<span class="hljs-string">&quot;chatter&quot;</span>,<br>    <span class="hljs-number">1000</span>);<br>  rclcpp::<span class="hljs-title class_">Rate</span> loop_rate(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>msg相关的模块命名空间也发生了变化，相比ros1多了一层msg：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//  std_msgs::String msg;</span><br>  std_msgs::msg::<span class="hljs-type">String</span> msg;<br><span class="hljs-comment">//  nav_msgs::Path;</span><br>  nav_msgs::msg::Path<br></code></pre></td></tr></table></figure><p>还有一些别的ros接口稍微有点小变化：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//    while (ros::ok())</span><br>    <span class="hljs-keyword">while</span> (rclcpp::ok<span class="hljs-literal">()</span>)<br><span class="hljs-comment">//    ros::spinOnce();</span><br>    rclcpp::spin<span class="hljs-constructor">_some(<span class="hljs-params">node</span>)</span>;<br><span class="hljs-comment">//    ROS_INFO(&quot;%s&quot;, msg.data.c_str());</span><br>    <span class="hljs-constructor">RCLCPP_INFO(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">get_logger</span>()</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, msg.data.c<span class="hljs-constructor">_str()</span>);<br><br></code></pre></td></tr></table></figure><h3 id="Colcon-build"><a href="#Colcon-build" class="headerlink" title="Colcon build"></a>Colcon build</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> $<span class="hljs-params">(PATH_TO_YOUR_ROS2_WS)</span><span class="hljs-string">/src</span><br>git clone -b cuda https:<span class="hljs-string">//github.com/Jason-xy/VINS-Fusion.git</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br>colcon build <span class="hljs-params">--symlink-install</span> <span class="hljs-params">--allow-overriding</span> cv_bridge<br></code></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://docs.ros.org/en/foxy/The-ROS2-Project/Contributing/Migration-Guide.html">ROS迁移指南官方文档</a></p><p>实例代码：VINS-Fusion <a href="https://github.dev/Jason-xy/VINS-Fusion/tree/master/loop_fusion">ROS1</a> <a href="https://github.dev/Jason-xy/VINS-Fusion/tree/cuda/loop_fusion">ROS2</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Robotics</category>
      
      <category>System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>robotic</tag>
      
      <tag>drone</tag>
      
      <tag>ROS</tag>
      
      <tag>catkin</tag>
      
      <tag>colcon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jetpack(L4T) Perf性能分析工具安装及测试</title>
    <link href="/2022/12/Jetpack-Perf-install-and-test/"/>
    <url>/2022/12/Jetpack-Perf-install-and-test/</url>
    
    <content type="html"><![CDATA[<p>不同于普通AMD64的PC，安装perf相关工具一行apt命令即可<code>sudo apt install linux-tools-common  linux-tools-&quot;$(uname -r)&quot;  linux-cloud-tools-&quot;$(uname -r)&quot;</code>, L4T版本的perf由于不在arm64的apt源中需要从源码编译。</p><h2 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h2><ol><li><p>可以通过jtop直接查看相应的l4t版本，如图<img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/PicGo/202212070000797.png" alt="image-20221206235818326"></p></li><li><p>去<a href="https://developer.nvidia.com/embedded/downloads">nvidia下载中心</a>寻找相应版本的Linux Driver<img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/PicGo/202212070000620.png" alt="image-20221207000032138"></p></li><li><p>进入release page找到BSP源码</p></li></ol><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/PicGo/202212070002708.png" alt="image-20221207000212684"></p><ol start="4"><li><p>复制链接后直接用<code>wget</code>下载至jetson，通常为<code>public_sources.tbz2</code>，通过<code>tar -xjvf public_sources.tbz2</code>解压后可以得到<code>Linux_for_Tegra</code>目录<img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/PicGo/202212070004807.png" alt="image-20221207000416790"></p></li><li><p>进入目录<code>Linux_for_Tegra/source/public</code>，解压<code>tar -xjvf kernel_src.tbz2</code>，之后可会得到<code>kernel</code>目录，进入目录<code>kernel/kernel-5.10/tools/perf</code>，即可找到perf相关的源码</p></li></ol><h2 id="编译并安装perf"><a href="#编译并安装perf" class="headerlink" title="编译并安装perf"></a>编译并安装perf</h2><p><code>make &amp;&amp; sudo rm /usr/bin/perf &amp;&amp; sudo cp perf /usr/bin/perf </code></p><p>可以根据检查报告安装相应的库，以支持更加丰富的功能</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/PicGo/202212072128394.png" alt="image-20221207212812351"></p><p>检查perf是否安装成功<code>perf --version</code></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/PicGo/202212070015187.png" alt="image-20221207001524167"></p><h2 id="生成火焰图"><a href="#生成火焰图" class="headerlink" title="生成火焰图"></a>生成火焰图</h2><p><strong>下载火焰图工具</strong></p><p><code>git clone https://github.com/brendangregg/FlameGraph</code></p><p><strong>查看并设置系统限制</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysctl kernel.kptr_restrict <br>sudo sysctl -w kernel.kptr_restrict=0<br>sudo sysctl -w kernel.perf_event_paranoid=-1<br></code></pre></td></tr></table></figure><p><strong>采集特定进程信息</strong></p><p><code>perf record -F 100 -p  1157822  -g -- sleep 100</code></p><p>采样频率100Hz，PID 1157822，包含调用栈，持续100s</p><p><strong>生成火焰图</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=&lt;FlameGraph工程目录&gt;:$PATH<br>perf script  | stackcollapse-perf.pl | flamegraph.pl  &gt; out.svg<br></code></pre></td></tr></table></figure><p>用浏览器打开即可</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/PicGo/202212070103413.svg" alt="out"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>Usage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>jetson</tag>
      
      <tag>l4t</tag>
      
      <tag>perf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++通用构建加速方法</title>
    <link href="/2022/06/c-compile-speedup/"/>
    <url>/2022/06/c-compile-speedup/</url>
    
    <content type="html"><![CDATA[<h2 id="C-x2F-C-编译基本原理"><a href="#C-x2F-C-编译基本原理" class="headerlink" title="C&#x2F;C++编译基本原理"></a>C&#x2F;C++编译基本原理</h2><p>对于C&#x2F;C++代码通常来说整个构建过程分为以下几个主要部分：</p><ul><li><p>预处理</p><p>在此阶段主要完成的工作是将头文件展开、替换宏指令、条件编译展开、消除注释。</p></li><li><p>编译</p><p>在此阶段主要将预编译好的文件转换成汇编语言（高级语言-&gt;LLVM平台无关语言-&gt;平台汇编语言）。</p></li><li><p>汇编</p><p>在此阶段将汇编语言转换为二进制机器语言。</p></li><li><p>链接</p><p>将编译产物和预编译制品（.o、.a、.so）“拼”成可执行文件，具体一些就是为main编译过程中每一个未定义的符号去编译产物中挨个寻找相应的实现代码，补全符号地址信息。</p></li></ul><p>在编译耗时分析中也就应该对以上几个主要方面分别进行时间维度的评估，逐渐细化分析粒度确定时间瓶颈，直到某个文件、某个函数、某个模板才能有针对性地制定从宏观的构建系统到微观的文件、符号的具体优化方案。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>gcc -E选项可以得到预处理后的结果，扩展名为.i 或 .ii。一般来说对预处理阶段的分析尤为重要，因为预处理完了之后的中间文件才是真正编译过程的输入。预处理后文件的体量大小直接影响了后续阶段各个部分的时间消耗水平。由于C&#x2F;C++编译特点的影响，每个编译单元（源文件），都需要独立解析所有包含的头文件。也就是说如果N个源文件引用到了同一个头文件，则这个头文件需要解析N次。如果头文件中有模板（STL&#x2F;Boost），则该模板在每个cpp文件中使用时都会做一次实例化，N个源文件中的std::vector会实例化N次。通常来说预处理阶段资源消耗是否合理一般可以通过以下几个具体指标进行查看。</p><ul><li>单个源文件头文件引用总数</li><li>单个头文件被引用总数</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>gcc -S选项可以得到编译后的汇编代码文件，扩展名为.s。在该阶段中，GCC为了满足用户不同程度的的优化需要，提供了近百种优化选项，用来对编译时间，目标文件长度，执行效率这个三维模型进行不同的取舍和平衡。优化的方法不一而足，总体上将有以下几类：</p><ol><li>精简操作指令。 </li><li>尽量满足CPU的流水操作。 </li><li>通过对程序行为地猜测，重新调整代码的执行顺序。 </li><li>充分使用寄存器。 </li><li>对简单的调用进行展开等等。</li></ol><p>而使用编译器提供的优化选项有时也可能需要再别的地方做取舍。部分优化选项会精简指令改变代码执行顺序，这会导致程序的可调试性大幅降低。另外一些涉及对寄存器、内存进行优化的指令可能会使程序在内存或者寄存器中结果的正确性得不到保障，这也是偶尔会在涉及到寄存器操作的代码中看到Volatile关键字的原因之一。</p><p>为了简化用户操作，GCC也提供了相应的一些预设优化方案例如O0~03</p><ul><li>O0：不做任何优化，这是默认的编译选项。</li><li>O和O1：对程序做部分编译优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。</li><li>O2：是比O1更高级的选项，进行更多的优化。GCC将执行几乎所有的不包含时间和空间折中的优化。当设置O2选项时，编译器并不进行循环展开以及函数内联优化。与O1比较而言，O2优化增加了编译时间的基础上，提高了生成代码的执行效率。</li><li>O3：在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。</li><li>Os：主要是对代码大小的优化， 通常各种优化都会打乱程序的结构，让调试工作变得无从着手。并且会打乱执行顺序，依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性。</li></ul><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>gcc -c选项可以得到汇编后的结果文件，扩展名为.o。.o文件，是按照的二进制编码方式生成的文件。在这个阶段中可以做的优化方案并不多，所以暂时只需要了解该阶段的基本作用即可。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>简单的讲，链接器的工作就是解析未定义的符号引用，将目标文件中的占位符替换为符号的地址。链接器还要完成程序中各目标文件的地址空间的组织，这可能涉及重定位工作。在C.&#x2F;C++程序的链接过程中主要涉及以下角色：</p><ul><li>静态库：指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了，其后缀名一般为“.a”。</li><li>动态库：在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可执行文件比较小，动态库一般后缀名为“.so”。</li><li>可执行文件：将所有的二进制文件链接起来融合成一个可执行程序，不管这些文件是目标二进制文件还是库二进制文件。</li></ul><h2 id="C-编译特性"><a href="#C-编译特性" class="headerlink" title="C++编译特性"></a>C++编译特性</h2><h3 id="编译单元"><a href="#编译单元" class="headerlink" title="编译单元"></a>编译单元</h3><p>C&#x2F;C++的编译系统和其他高级语言存在很大的差异，其他高级语言中，编译单元是整个Module，即Module下所有源码，会在同一个编译任务中执行。而在C&#x2F;C++中，编译单元是以文件为单位。每个.c&#x2F;.cc&#x2F;.cxx&#x2F;.cpp源文件是一个独立的编译单元，导致编译优化时只能基于本文件内容进行优化，很难跨编译单元提供代码优化。</p><h3 id="头文件解析"><a href="#头文件解析" class="headerlink" title="头文件解析"></a>头文件解析</h3><p>如果N个源文件引用到了同一个头文件，则这个头文件需要解析N次。</p><p>如果头文件中有模板（STL&#x2F;Boost），则该模板在每个cpp文件中使用时都会做一次实例化，N个源文件中的std::vector会实例化N次。</p><h3 id="模板函数实例化"><a href="#模板函数实例化" class="headerlink" title="模板函数实例化"></a>模板函数实例化</h3><p>在C++ 98语言标准中，对于源代码中出现的每一处模板实例化，编译器都需要去做实例化的工作；而在链接时，链接器还需要移除重复的实例化代码。显然编译器遇到一个模板定义时，每次都去进行重复的实例化工作，进行重复的编译工作。此时，如果能够让编译器避免此类重复的实例化工作，那么可以大大提高编译器的工作效率。在C++ 0x标准中一个新的语言特性 – 外部模板的引入解决了这个问题。</p><p>在C++ 98中，已经有一个叫做显式实例化（Explicit Instantiation）的语言特性，它的目的是指示编译器立即进行模板实例化操作（即强制实例化）。而外部模板语法就是在显式实例化指令的语法基础上进行修改得到的，通过在显式实例化指令前添加前缀extern，从而得到外部模板的语法。</p><ol><li>显式实例化语法：template class vector。 </li><li>外部模板语法：extern template class vector。</li></ol><p>一旦在一个编译单元中使用了外部模板声明，那么编译器在编译该编译单元时，会跳过与该外部模板声明匹配的模板实例化。</p><h2 id="耗时分析工具"><a href="#耗时分析工具" class="headerlink" title="耗时分析工具"></a>耗时分析工具</h2><h3 id="ftime-trace"><a href="#ftime-trace" class="headerlink" title="-ftime-trace"></a><a href="https://reviews.llvm.org/D58675">-ftime-trace</a></h3><p>clang-9中增加了一个选项可以产生编译耗时的具体详情，通过在编译的时候增加这个选项，我们可以找到程序真实瓶颈。</p><p>通过命令clang++ -ftime-trace -c .&#x2F;main.cpp -o test 可以在编译的过程中多得到一个.json文件，简单的处理方法是直接拽到chrome:&#x2F;&#x2F;tracing里分析 一个简单的使用cout的hello world的编译耗时如下图所示：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2022/06/15/03.png" alt="img"></p><p>由此可以通过火焰图直观地分析出编译中各个过程，找出时间消耗的瓶颈。</p><h3 id="Clang-Build-Analyzer"><a href="#Clang-Build-Analyzer" class="headerlink" title="Clang Build Analyzer"></a><a href="https://github.com/aras-p/ClangBuildAnalyzer">Clang Build Analyzer</a></h3><p>对于较为大型的项目来说，往往有成千上万个源文件，相应地在编译过程中也就会生成相当数量的.json文件，显然无法直接分析。此时就可以使用Clang Build Analyzer来汇总所有的json文件对整个工程的构建时间消耗进行分析。通过分析最终可以获得以下对于耗时瓶颈分析十分重要的信息：</p><p>哪些文件的解析速度最慢? 例如，花时间在编译器前端（lexer&#x2F;解析器）上时间最多的文件。</p><p>哪个C++模板的实例化时间最长？</p><p>哪些文件生成代码的速度最慢? 例如，花时间在编译器后端进行代码生成和优化时间最长的文件。</p><p>哪些函数生成代码的速度最慢？</p><p>在整个构建过程中，哪些头文件被包含得最多，解析它们花费了多少时间，它们的包含链是什么？</p><p><strong>使用条件</strong></p><p>由于该工具是通过分析clang生成描述编译过程的.json文件，所以需要clang支持-ftime-trace参数，更加明确一点就是clang版本需要&gt;&#x3D;9.0.0</p><p><strong>使用方法</strong>（以标准cmake工程为例）</p><p>创建build目录，并启动ClangBuildAnalyzer开始记录时间戳</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/ClangBuildAnalyzer –start $&#123;project&#125;/</span>build<br></code></pre></td></tr></table></figure><p>执行构建</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">cmake</span></span> .. &amp;&amp; make -j<br></code></pre></td></tr></table></figure><p>构建结束后停止记录，并把数据保存在二进制文件内</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/ClangBuildAnalyzer –stop $&#123;project&#125;/</span>build result_bin<br></code></pre></td></tr></table></figure><p>对数据执行分析</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ClangBuildAnalyzer</span> –analyze result_bin<br></code></pre></td></tr></table></figure><h3 id="Include-What-You-Use"><a href="#Include-What-You-Use" class="headerlink" title="Include What You Use"></a><a href="https://github.com/include-what-you-use/include-what-you-use">Include What You Use</a></h3><p>这是一个用于分析和管理头文件依赖的工具，具体的描述如下：对于在 foo.cc (或 foo.cpp)中使用的每个符号(类型、函数、变量或宏) ，foo.cc 或 foo.h 都应该包含一个。导出该符号声明的 h 文件。(类似地，对于 foo_test.cc，或者 foo_test.cc 或 foo.h 应该包括在内。)显然，在 foo.cc 中定义的符号被排除在这个需求之外。这使头文件依赖处于这样一种状态，即每个文件都包含声明其所使用的符号所需的标头，而不必担心意外地破坏该文件的向上依赖关系。还可以轻松地自动跟踪和更新源代码中的依赖项。</p><p>利用这个工具可以比较方便地扫描出哪些头文件是多余的，哪些是需要的，开发者可以由此为依据调整头文件依赖关系，减少冗余头文件依赖，简化依赖管理过程，同时也可以减少构建的预处理过程中代码膨胀程度，加快编译构建速度。</p><p><strong>使用方式</strong>（以标准cmake工程为例）</p><p>构建iwyu时需要与构建工具链的clang版本对齐，否则可能会导致程序运行结果与运行构建环境不匹配的情况（例如出现了很多不存在的头文件）先执行一次完整的构建，然后用iwyu来分析构建的中间文件（比如compile_commands.json）建议直接使用iwyu提供的python脚本进行分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 iwyu_tool.py -p <span class="hljs-variable">$&#123;project&#125;</span>/build<br></code></pre></td></tr></table></figure><p>分析结果类似如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino">../jsarray.h should add these lines:<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span>                     <span class="hljs-comment">// for uint32_t</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>                  <span class="hljs-comment">// for int32_t</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dist/include/js/RootingAPI.h&quot;</span>  <span class="hljs-comment">// for HandleObject, Handle, etc</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jsapi.h&quot;</span>                      <span class="hljs-comment">// for Value, HandleObject, etc</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jsfriendapi.h&quot;</span>                <span class="hljs-comment">// for JSID_TO_ATOM</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jstypes.h&quot;</span>                    <span class="hljs-comment">// for JSBool</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vm/String.h&quot;</span>                  <span class="hljs-comment">// for JSAtom</span></span><br><span class="hljs-keyword">namespace</span> JS &#123; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span>; &#125;<br><span class="hljs-keyword">namespace</span> js &#123; <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExclusiveContext</span>; &#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JSContext</span>;<br><br>../jsarray.h should remove these lines:<br><br>The full include-list <span class="hljs-keyword">for</span> ../jsarray.h:<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span>                     <span class="hljs-comment">// for uint32_t</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>                  <span class="hljs-comment">// for int32_t</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dist/include/js/RootingAPI.h&quot;</span>  <span class="hljs-comment">// for HandleObject, Handle, etc</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jsapi.h&quot;</span>                      <span class="hljs-comment">// for Value, HandleObject, etc</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jsfriendapi.h&quot;</span>                <span class="hljs-comment">// for JSID_TO_ATOM</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jsobj.h&quot;</span>                      <span class="hljs-comment">// for JSObject (ptr only), etc</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jspubtd.h&quot;</span>                    <span class="hljs-comment">// for jsid</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jstypes.h&quot;</span>                    <span class="hljs-comment">// for JSBool</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vm/String.h&quot;</span>                  <span class="hljs-comment">// for JSAtom</span></span><br><span class="hljs-keyword">namespace</span> JS &#123; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span>; &#125;<br><span class="hljs-keyword">namespace</span> js &#123; <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayObject</span>; &#125;  <span class="hljs-comment">// lines 44-44</span><br><span class="hljs-keyword">namespace</span> js &#123; <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExclusiveContext</span>; &#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JSContext</span>;<br></code></pre></td></tr></table></figure><p>获取输出的分析结果后不建议直接自动修改头文件引用，因为可能会出现意料之外的问题，同时也可能降低代码的可读性。一般来说作为一个头文件引用参考会比较好，然后根据这个分析结果手动调整依赖关系。</p><h2 id="优化与加速手段"><a href="#优化与加速手段" class="headerlink" title="优化与加速手段"></a>优化与加速手段</h2><h3 id="并行构建"><a href="#并行构建" class="headerlink" title="并行构建"></a>并行构建</h3><p><strong>适用条件：</strong>计算资源充足</p><p><strong>常规方法：</strong>使用-j参数执行make，尽可能地利用计算资源。</p><p><strong>再进一步：</strong>如果采用标准cmake组织的工程，可以尝试使用ninja替换make进行构建操作，得益于ninja出色的依赖分析再构建时可以得到更好的并行度。相对于用make构建只需要做很少的改变：首先在cmake时用-G指定Ninja，用cmake生成ninja.build（作用类比于makefile），然后ninja -jxxx就可以开始构建了。</p><p><strong>代码优化：</strong>减少串行依赖和间接依赖。</p><p><strong>进阶策略：</strong>可以尝试类似于catkin的并行构建思想，除了单个target或者package中代码的并行构建，还可以把各个package的构建并行，可以获得更好的并行程度。但是为了实现模块的并行构建，需要额外维护一份模块间依赖关系的描述文件，例如catkin中的package.xml文件。</p><h3 id="CCache编译缓存"><a href="#CCache编译缓存" class="headerlink" title="CCache编译缓存"></a><a href="https://github.com/ccache/ccache">CCache</a>编译缓存</h3><p>ccache是一个编译缓存工具，其原理是将cpp的编译结果保存在文件缓存中，以后编译时若对应文件无变动可直接从缓存中获取编译结果。需要注意的是，Make本身也有一定缓存功能，当目标文件已编译（且依赖无变化)时，若源文件时间戳无变化也不会再次编译；但CCache是按文件内容做的缓存，且同一机器的多个项目可以共享缓存，因此适用面更大。</p><p>使用<code>ccache -s</code>可以查看当前ccache信息，例如剩余缓存空间、命中率等数据。</p><p>单机构建：可以通过提高ccache空间来提高命中率。</p><p>集群构建：可以尝试使用redis来做ccache存储空间，让构建集群共享编译缓存。</p><h3 id="预编译头文件（PCH）"><a href="#预编译头文件（PCH）" class="headerlink" title="预编译头文件（PCH）"></a>预编译头文件（<a href="https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html">PCH</a>）</h3><p>该方法预先将常用头文件的编译结果保存起来，这样编译器在处理对应的头文件引入时可以直接使用预先编译好的结果，从而加快整个编译流程。有的头文件包含了巨量的源代码（如著名的windows.h），或者使用模板编程时要生成巨大的头文件模板库（如Eigen math library与Boost C++ libraries)。为减少编译时间，某些编译器允许把头文件编译为某种中间形式称为预编译头（precompiled header），后续再编译源文件时就可以尽量直接使用这些预编译头。</p><p><strong>使用方法</strong>（以标准的cmake工程为例）</p><p><strong>环境要求</strong>：CMake &gt;&#x3D; 3.16</p><p><a href="https://cmake.org/cmake/help/latest/command/target_precompile_headers.html">用CMake启用PCH</a></p><p>确认需要使用PCH特性的头文件，针对头文件所在的target按照如下方式修改cmake</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake">target_precompile_headers(myTarget<br>  PUBLIC<br>    project_header.h<br>  PRIVATE<br>    [[<span class="hljs-string">&quot;other_header.h&quot;</span>]]<br>    &lt;unordered_map&gt;<br>)<br></code></pre></td></tr></table></figure><p>对于有特定语言要求的头文件需要手动指定出是C或者C++</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">target_precompile_headers(mylib PRIVATE<br>  <span class="hljs-string">&quot;$&lt;$&lt;COMPILE_LANGUAGE:CXX&gt;:$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cxx_only.h&gt;&quot;</span><br>  <span class="hljs-string">&quot;$&lt;$&lt;COMPILE_LANGUAGE:C&gt;:&lt;stddef.h$&lt;ANGLE-R&gt;&gt;&quot;</span><br>  <span class="hljs-string">&quot;$&lt;$&lt;COMPILE_LANGUAGE:CXX&gt;:&lt;cstddef$&lt;ANGLE-R&gt;&gt;&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>如果有别的模块需要使用之前预编译好的头文件，按如下方式修改cmake</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_precompile_headers(&lt;<span class="hljs-params">target</span>&gt; REUSE_FROM &lt;<span class="hljs-params">other_target</span>&gt;)</span><br></code></pre></td></tr></table></figure><h3 id="module编译"><a href="#module编译" class="headerlink" title="module编译"></a>module编译</h3><p>如果项目是用C++ 20进行开发的，那么Module编译也是一个优化编译速度的方案，C++20之前的版本会把每一个cpp当做一个编译单元处理，会存在引入的头文件被多次解析编译的问题。而Module的出现就是解决这一问题，Module不再需要头文件（只需要一个模块文件，不需要声明和实现两个文件），它会将你的（.ixx 或者 .cppm）模块实体直接编译，并自动生成一个二进制接口文件。import和include预处理不同，编译好的模块下次import的时候不会重复编译，可以大幅度提高编译器的效率。</p><h3 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h3><p>在执行构建耗时分析后，如果发现编译后端耗时过高可以尝试罗列一下<a href="https://cplusplus.com/doc/oldtutorial/templates/">模板</a>实例化的top项。以Clang Build Analyzer的分析结果为例，经常会发现有的模板被重复实例化了几十上百次。由于模板被使用时才会实例化这一特性，相同的实例可以出现在多个文件对象中。编译器要对每一处模板进行实例化，链接器还要移除重复的实例化代码。当在广泛使用模板的项目中，编译器会产生大量的冗余代码，这会极大地增加编译时间和链接时间。而在C++11中的”外部模板“就是一个关于模板性能上的改进。</p><p>在使用外部模板之前，代码构建过程如下图：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2022/06/15/01.png"></p><p>而在使用外部模板之后：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2022/06/15/02.png"></p><p><strong>具体实现</strong></p><p> <code>extern_template.h</code> 外部模板头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// extern_template.h</span><br><br>__pragma(once)<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 模板</span><br><br><span class="hljs-comment">// 类</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;;<br><br><span class="hljs-comment">// 静态成员方法</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sm_f</span><span class="hljs-params">(T t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;B::sm_f :: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 静态普通函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">s_f</span><span class="hljs-params">(T t)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;static s_f :: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;<br>&#125;;<br><br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;func :: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>extern_template.cpp</code> 实例化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// extern_template.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;extern_template.h&quot;</span></span><br><br><span class="hljs-comment">// 实例化</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_f1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A&lt;<span class="hljs-type">int</span>&gt; a;<br>    <span class="hljs-built_in">s_f</span>(<span class="hljs-number">1</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;static general func&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_f2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;general func&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_f3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">sm_f</span>(<span class="hljs-number">1</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;static member func&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>main.cpp</code> 外部模板声明与应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// main.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;extern_template.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&lt;<span class="hljs-type">int</span>&gt;;            <span class="hljs-comment">// 类</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-type">void</span> B&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">sm_f</span>(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 静态成员函数</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-type">void</span> <span class="hljs-built_in">s_f</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>);      <span class="hljs-comment">// error C2129 静态函数“void s_f&lt;int&gt;(int)”已声明但未定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-type">void</span> <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>);     <span class="hljs-comment">// 普通函数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;test_f&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">s_f</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">test_f</span>();<br>    B&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">sm_f</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">static s_f :: 1</span><br><span class="hljs-comment">func :: 1</span><br><span class="hljs-comment">test_f</span><br><span class="hljs-comment">B::sm_f t :: 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://tech.meituan.com/2020/12/10/apache-kylin-practice-in-meituan.html">C++服务编译耗时优化原理及实践</a></p><p><a href="https://github.com/aras-p/ClangBuildAnalyzer">ClangBuildAnalyzer</a></p><p><a href="https://github.com/include-what-you-use/include-what-you-use">include-what-you-use</a></p><p><a href="http://www.cplusplus.com/doc/oldtutorial/templates/">C++ Templates</a></p><p><a href="https://ccache.dev/">CCache</a></p><p><a href="https://en.wikipedia.org/wiki/Precompiled_header">Precompiled header</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
      <tag>compile</tag>
      
      <tag>link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程管理-随笔记录</title>
    <link href="/2021/10/linuxprocessesmanagement/"/>
    <url>/2021/10/linuxprocessesmanagement/</url>
    
    <content type="html"><![CDATA[<h2 id="进程的描述PCB"><a href="#进程的描述PCB" class="headerlink" title="进程的描述PCB"></a>进程的描述PCB</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/02/image-20211002122957484.png" alt="image-20211002122957484"></p><p>描述一个进程的结构。</p><p><strong>组织方式</strong></p><p>进程链表：用于遍历</p><p>进程树：体现父子关系</p><p>进程哈希表：用于pid检索</p><h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/02/image-20211002123858943.png" alt="image-20211002123858943"></p><h3 id="僵尸"><a href="#僵尸" class="headerlink" title="僵尸"></a>僵尸</h3><p>僵尸进程：PCB还没消失，等到父进程wait()，父进程可以得知子进程退出原因。</p><p>内存泄漏：随时间增加内存消耗震荡发散。</p><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><p>用STOP信号暂停，保存中间结果，用CONTINUE信号继续。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">Ctrl+z` 和`bg`、`fg<br></code></pre></td></tr></table></figure><h3 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h3><p>深睡眠：只有当资源都满足才唤醒。<code>kill -9</code>也无法杀掉。</p><p>浅睡眠：可以被信号唤醒。</p><h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/05/image-20211005105535624.png" alt="image-20211005105535624"></p><h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/05/image-20211005105035326.png" alt="image-20211005105035326"></p><p>相同的虚拟地址，但页表对应的物理地址不同。</p><h2 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/05/image-20211005105600004.png" alt="image-20211005105600004"></p><h2 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create()"></a>pthread_create()</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/05/image-20211005105804929.png" alt="image-20211005105804929"></p><h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/05/image-20211005110022717.png" alt="image-20211005110022717"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/05/image-20211005110030577.png" alt="image-20211005110030577"></p><p>可以自由选择拷贝task_struct中的任意部分。</p><h2 id="PID与TGID"><a href="#PID与TGID" class="headerlink" title="PID与TGID"></a>PID与TGID</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/05/image-20211005110908778.png" alt="image-20211005110908778"></p><p>用户空间中<code>getpid()</code>实际上得到的是<code>TGID</code></p><h2 id="进程脱孤"><a href="#进程脱孤" class="headerlink" title="进程脱孤"></a>进程脱孤</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/05/image-20211005111807317.png" alt="image-20211005111807317"></p><h2 id="睡眠-1"><a href="#睡眠-1" class="headerlink" title="睡眠"></a>睡眠</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/05/image-20211005112255626.png" alt="image-20211005112255626"></p><p>依赖于等待队列</p><h2 id="进程0和1"><a href="#进程0和1" class="headerlink" title="进程0和1"></a>进程0和1</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/05/image-20211005112807754.png" alt="image-20211005112807754"></p><h2 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/05/image-20211005114800208.png" alt="image-20211005114800208"></p><h2 id="CFS调度策略"><a href="#CFS调度策略" class="headerlink" title="CFS调度策略"></a>CFS调度策略</h2><h3 id="CFS策略"><a href="#CFS策略" class="headerlink" title="CFS策略"></a>CFS策略</h3><p>CFS 调度程序并不采用严格规则来为一个优先级分配某个长度的时间片，而是为每个任务分配一定比例的 CPU 处理时间。每个任务分配的具体比例是根据友好值来计算的。友好值的范围从 -20 到 +19，数值较低的友好值表示较高的相对优先级。具有较低友好值的任务，与具有较高友好值的任务相比，会得到更高比例的处理器处理时间。默认友好值为 0。</p><p>CFS 调度程序没有直接分配优先级。相反，它通过每个任务的变量 vruntime 以便维护虚拟运行时间，进而记录每个任务运行多久。虚拟运行时间与基于任务优先级的衰减因子有关，更低优先级的任务比更高优先级的任务具有更高衰减速率。对于正常优先级的任务（友好值为 0），虚拟运行时间与实际物理运行时间是相同的。</p><p>因此，如果一个默认优先级的任务运行 200ms，则它的虚拟运行时间也为 200ms。然而，如果一个较低优先级的任务运行 200ms，则它的虚拟运行时间将大于 200ms。同样，如果一个更高优先级的任务运行 200ms，则它的虚拟运行时间将小于 200ms。当决定下步运行哪个任务时，调度程序只需选择具有最小虚拟运行时间的任务。此外，一个更高优先级的任务如成为可运行，就会抢占低优先级任务。</p><p>下面分析一下 CFS 调度程序是如何工作的。假设有两个任务，它们具有相同的友好值。一个任务是 I&#x2F;O 密集型而另一个为 CPU 密集型。通常，I&#x2F;O 密集型任务在运行很短时间后就会阻塞以便等待更多的 I&#x2F;O；而 CPU 密集型任务只要有在处理器上运行的机会，就会用完它的时间片。</p><p>因此，I&#x2F;O 密集型任务的虚拟运行时间最终将会小于 CPU 密集型任务的，从而使得 I&#x2F;O 密集型任务具有更高的优先级。这时，如果 CPU 密集型任务在运行，而 I&#x2F;O 密集型任务变得有资格可以运行（如该任务所等待的 I&#x2F;O 已成为可用)，那么 I&#x2F;O 密集型任务就会抢占 CPU 密集型任务。</p><p>Linux 也实现了实时调度。采用 SCHED_FIFO 或 SCHED_RR 实时策略来调度的任何任务，与普通（非实时的）任务相比，具有更高的优先级。</p><p>Linux 采用两个单独的优先级范围，一个用于实时任务，另一个用于正常任务。实时任务分配的静态优先级为 0〜99，而正常任务分配的优先级为 100〜139。</p><p>这两个值域合并成为一个全局的优先级方案，其中较低数值表明较高的优先级。正常任务，根据它们的友好值，分配一个优先级；这里 -20 的友好值映射到优先级 100，而 +19 的友好值映射到 139。下图显示了这个方案。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/11/image-20211011160615690.png" alt="image-20211011160615690"></p><h3 id="CFS-性能"><a href="#CFS-性能" class="headerlink" title="CFS 性能"></a>CFS 性能</h3><p>Linux CFS 调度程序釆用高效算法，以便选择运行下个任务。每个可运行的任务放置在红黑树上（这是一种平衡的、二分搜索树，它的键是基于虚拟运行时间的）。这种树如下图所示：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/11/image-20211011160739213.png" alt="image-20211011160739213"></p><p>当一个任务变成可运行时，它被添加到树上。当一个任务变成不可运行时（例如，当阻塞等待 I&#x2F;O 时），它从树上被删除。一般来说，得到较少处理时间的任务（虚拟运行时间较小）会偏向树的左侧；得到较多处理时间的任务会偏向树的右侧。</p><p>根据二分搜索树的性质，最左侧的结点有最小的键值；从 CFS 调度程序角度而言，这也是具有最高优先级的任务。由于红黑树是平衡的，找到最左侧结点会需要 <code>O(lgN)</code> 操作（这里 N 为树内结点总数）。不过，为高效起见，Linux 调度程序将这个值缓存在变量<code>rb_leftmost</code>中，从而确定哪个任务运行只需检索缓存的值。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是对概念模型2-3-4树的一种实现，由于直接进行不同节点间的转化会造成较大的开销，所以选择以二叉树为基础，在二叉树的属性中加入一个<strong>颜色属性</strong>来表示2-3-4树中不同的节点。</p><p>2-3-4树中的2节点对应着红黑树中的黑色节点，而2-3-4树中的非2节点是以<strong>红节点+黑节点</strong>的方式存在，红节点的意义是与黑色父节点结合，表达着2-3-4树中的3，4节点。</p><p>（此处理解成红节点也好，红色链接也好，看个人喜好。很多书中会说是由黑色节点指出的红色链接，链接指向的节点颜色为红。）</p><h4 id="1-节点颜色有红色和黑色"><a href="#1-节点颜色有红色和黑色" class="headerlink" title="1.节点颜色有红色和黑色"></a><strong>1.节点颜色有红色和黑色</strong></h4><p>【2-3树到红黑树的转化见下文】</p><h4 id="2-根节点必为黑色"><a href="#2-根节点必为黑色" class="headerlink" title="2.根节点必为黑色"></a><strong>2.根节点必为黑色</strong></h4><p>【2-3树中如果根节点为2节点，那么它本来就对应红黑树中黑节点；如果根节点为3节点，也可以用黑色节点表示较大的那个元素，然后较小的元素作为左倾红节点存在于红黑树中】</p><h4 id="3-所有叶子节点都是黑色"><a href="#3-所有叶子节点都是黑色" class="headerlink" title="3.所有叶子节点都是黑色"></a><strong>3.所有叶子节点都是黑色</strong></h4><p>【此处提到的叶子其实是空链接，因篇幅问题不便全部画出】</p><h4 id="4-任意节点到叶子节点经过的黑色节点数目相同"><a href="#4-任意节点到叶子节点经过的黑色节点数目相同" class="headerlink" title="4.任意节点到叶子节点经过的黑色节点数目相同"></a>4.任意节点到叶子节点经过的黑色节点数目相同</h4><p>【红黑树中的红节点是和黑色父节点绑定的，在2-3树中本来就是同一层的，只有黑色节点才会在2-3树中真正<strong>贡献高度</strong>，由于2-3树的任一节点到空链接距离相同，因此反应在红黑树中就是<strong>黑色完美平衡</strong>】</p><h4 id="5-不会有连续的红色节点"><a href="#5-不会有连续的红色节点" class="headerlink" title="5.不会有连续的红色节点"></a><strong>5.不会有连续的红色节点</strong></h4><p>【2-3树中本来就规定没有4节点，2-3-4树中虽然有4节点，但是要求在红黑树中体现为一黑色节点带两红色儿子，分布左右，所以也不会有连续红节点】</p><h4 id="2-3-4树到红黑树的节点转换"><a href="#2-3-4树到红黑树的节点转换" class="headerlink" title="2-3-4树到红黑树的节点转换"></a>2-3-4树到红黑树的节点转换</h4><p>我们先看2-3-4树到红黑树的节点转换。2节点直接转化为黑色节点；3节点这里可以有两种表现形式，左倾红节点或者右倾红节点。而4节点被 强制<strong>要求</strong>转化为一个黑父带着左右两个红色儿子。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/11/image-20211011145729459.png" alt="image-20211011145729459"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/10/11/image-20211011150640330.png" alt="image-20211011150640330"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VScode C/C++编译及调试环境配置</title>
    <link href="/2021/09/vscode-c-cpp/"/>
    <url>/2021/09/vscode-c-cpp/</url>
    
    <content type="html"><![CDATA[<p>博客原文：<a href="https://jason-xy.cn/2021/09/vscode_c_cpp/">VScode C&#x2F;C++编译及调试环境配置</a></p><p>默认已安装了VScode</p><h2 id="MinGW安装（Windows）"><a href="#MinGW安装（Windows）" class="headerlink" title="MinGW安装（Windows）"></a>MinGW安装（Windows）</h2><p><a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64">Mingw-w64下载地址</a></p><p>下载该文件（需要科学上网）</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917152719828.png" alt="image-20210917152719828"></p><p>国内COS服务器（作者按流量付费的，大伙省着点用）：<a href="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/files/MinGW.zip">MinGW.zip</a></p><p>下载后解压到一个可以记住的路径，如下图：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917153207551.png" alt="image-20210917153207551"></p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>根据自己刚解压的路径配置环境变量。</p><p>如下图所示</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917153423654.png" alt="image-20210917153423654"></p><p>打开cmd检查是否配置成功</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gcc -v</span><br></code></pre></td></tr></table></figure><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917153608825.png" alt="image-20210917153608825"></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">g</span><span class="hljs-literal">++</span> <span class="hljs-literal">-</span><span class="hljs-comment">v</span><br></code></pre></td></tr></table></figure><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917153630672.png" alt="image-20210917153630672"></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gdb -v</span><br></code></pre></td></tr></table></figure><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917153717699.png" alt="image-20210917153717699"></p><p>出现版本信息则说明环境变量配置成功。</p><h2 id="VScode插件安装"><a href="#VScode插件安装" class="headerlink" title="VScode插件安装"></a>VScode插件安装</h2><h3 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h3><p>C&#x2F;C++基础支持</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917153933546.png" alt="image-20210917153933546"></p><h4 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h4><p><code>shift</code> + <code>ctrl</code> + <code>p</code></p><p>如下搜索<img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917154321265.png" alt="image-20210917154321265"></p><p>配置详情</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917154458003.png" alt="image-20210917154458003"></p><h3 id="Code-Runner"><a href="#Code-Runner" class="headerlink" title="Code Runner"></a>Code Runner</h3><p>在终端运行代码</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917154014595.png" alt="image-20210917154014595"></p><h4 id="具体配置-1"><a href="#具体配置-1" class="headerlink" title="具体配置"></a>具体配置</h4><p>进入配置界面</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917154600238.png" alt="image-20210917154600238"></p><p>具体配置</p><p>找到如下两项并打勾即可</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917154635439.png" alt="image-20210917154635439"></p><h3 id="Tabnine（可选）"><a href="#Tabnine（可选）" class="headerlink" title="Tabnine（可选）"></a>Tabnine（可选）</h3><p>基于机器学习的代码补全插件。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917154153820.png" alt="image-20210917154153820"></p><h2 id="使用测试"><a href="#使用测试" class="headerlink" title="使用测试"></a>使用测试</h2><p><strong>打开一个工作区（文件夹）</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917154842544.png" alt="image-20210917154842544"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917154855546.png" alt="image-20210917154855546"></p><p>随便写一个简单的demo</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917155045160.png" alt="image-20210917155045160"></p><h3 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h3><p>点击右上角小三角即可在终端运行</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917155155115.png" alt="image-20210917155155115"></p><h3 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h3><p>点击左侧小bug创建<code>launch.json</code>文件</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917155304077.png" alt="image-20210917155304077"></p><p>选择<code>GDB/LLDB</code></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917155342454.png" alt="image-20210917155342454"></p><p>选择<code>gcc</code></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917155438680.png" alt="image-20210917155438680"></p><p>即可自动生成如下启动配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span><br>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span><br>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gcc.exe - 生成和调试活动文件&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:\\MinGW\\bin\\gdb.exe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>按<code>F5</code>进入调试</p><p><strong>断点停留</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917155839039.png" alt="image-20210917155839039"></p><p><strong>变量查看</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917155854262.png" alt="image-20210917155854262"></p><p><strong>表达式监视</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917160132558.png" alt="image-20210917160132558"></p><p><strong>堆栈调用</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917160007732.png" alt="image-20210917160007732"></p><p><strong>调试方式选项</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917160055651.png" alt="image-20210917160055651"></p><p>【Bug】寄存器监视打开后程序崩溃，从而看不到下面的画面</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/17/image-20210917160505954.png" alt="image-20210917160505954"></p><p>目前推测是gcc或者gdb的原因，具体解决方法请私信<a href="mailto:&#x61;&#100;&#x6d;&#105;&#x6e;&#64;&#106;&#97;&#115;&#111;&#110;&#45;&#x78;&#x79;&#x2e;&#99;&#x6e;">&#x61;&#100;&#x6d;&#105;&#x6e;&#64;&#106;&#97;&#115;&#111;&#110;&#45;&#x78;&#x79;&#x2e;&#99;&#x6e;</a></p><p>🥳到这里差不多基本功能都实现了，还有很多别的功能，就留给读者慢慢摸索吧。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>IT小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
      <tag>c/c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率生成问题</title>
    <link href="/2021/09/coin/"/>
    <url>/2021/09/coin/</url>
    
    <content type="html"><![CDATA[<p>作者：imageslr<br>链接：<a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-pao-ying-bi-kai-shi-xun-xu-jian-jin-ba-zhe-da/">https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-pao-ying-bi-kai-shi-xun-xu-jian-jin-ba-zhe-da/</a><br>来源：力扣（LeetCode）</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>概率生成问题是一种比较常见的面试题，常见题型举例：</p><ul><li>有一枚不均匀的硬币，要求产生均匀的概率分布</li><li>有一枚均匀的硬币，要求产生不均匀的概率分布，如 0.25 和 0.75</li><li>利用 Rand7() 实现 Rand10()</li></ul><p>本文将依次讲解这三个问题，然后总结此类问题的通用方法。</p><h2 id="不均匀硬币，产生等概率"><a href="#不均匀硬币，产生等概率" class="headerlink" title="不均匀硬币，产生等概率"></a>不均匀硬币，产生等概率</h2><p>现有一枚不均匀的硬币 <code>coin()</code>，能够返回 0、1 两个值，其概率分别为 0.6、0.4。要求使用这枚硬币，产生均匀的概率分布。即编写一个函数 <code>coin_new()</code> 使得它返回 0、1 的概率均为 0.5。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不均匀硬币，返回 0、1 的概率分别为 0.6、0.4</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">coin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (rand() % <span class="hljs-number">10</span>) &gt; <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>统计抛两次硬币的结果的概率分布：</p><table><thead><tr><th>结果</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0.6*0.6&#x3D;0.36</td><td>0.6*0.4&#x3D;0.24</td></tr><tr><td>1</td><td>0.4*0.6&#x3D;0.24</td><td>0.4*0.4&#x3D;0.16</td></tr></tbody></table><p>不难发现，连续抛两枚硬币得到 <code>0 1</code> 和 <code>1 0</code> 的概率分布是相同的。因此这道题的解法就是连续抛两次硬币，如果得到 <code>0 1</code>，返回 0；如果得到 <code>1 0</code>，返回 1；如果两次结果相同，则重新抛。</p><p>以此类推，无论这枚不均匀硬币的概率是多少，都可以用这种方法得到等概率的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">coin_new</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> a = coin();<br>        <span class="hljs-keyword">if</span> (coin() != a) <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 不均匀硬币</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coin</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>) &gt; <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coin_new</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">coin</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">coin</span>() != a) <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N = <span class="hljs-number">1000000</span>;<br>    <span class="hljs-type">float</span> count[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        count[<span class="hljs-built_in">coin_new</span>()] ++;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;0: &quot;</span> &lt;&lt; count[<span class="hljs-number">0</span>]/N &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1: &quot;</span> &lt;&lt; count[<span class="hljs-number">1</span>]/N &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">0: 0.50037<br>1: 0.49963<br></code></pre></td></tr></table></figure><h2 id="均匀硬币，产生不等概率"><a href="#均匀硬币，产生不等概率" class="headerlink" title="均匀硬币，产生不等概率"></a>均匀硬币，产生不等概率</h2><p>现有一枚均匀的硬币 <code>coin()</code>，能够返回 0、1 两个值，其概率均为 0.5。要求编写一个函数 <code>coin_new()</code>，使得它返回指定的 0、1 概率分布。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 均匀硬币</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">coin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> rand() % <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="P-0-x3D-1-x2F-4，P-1-x3D-3-x2F-4"><a href="#P-0-x3D-1-x2F-4，P-1-x3D-3-x2F-4" class="headerlink" title="P(0) &#x3D; 1&#x2F;4，P(1) &#x3D; 3&#x2F;4"></a><strong>P(0) &#x3D; 1&#x2F;4，P(1) &#x3D; 3&#x2F;4</strong></h3><p>对于均匀硬币而言，连续抛两次，得到 0 0、0 1、1 0、1 1 的概率均为 1&#x2F;4。显然，只需要连续抛两次硬币，如果得到 0 0，返回 0，其他情况返回 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">coin_new</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> coin() || coin();<br>&#125;<br></code></pre></td></tr></table></figure><p>测试输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">0: 0.249249<br>1: 0.750751<br></code></pre></td></tr></table></figure><h3 id="P-0-x3D-1-x2F-3，P-1-x3D-2-x2F-3"><a href="#P-0-x3D-1-x2F-3，P-1-x3D-2-x2F-3" class="headerlink" title="P(0) &#x3D; 1&#x2F;3，P(1) &#x3D; 2&#x2F;3"></a>P(0) &#x3D; 1&#x2F;3，P(1) &#x3D; 2&#x2F;3</h3><p>连续抛两次硬币。如果得到 <code>1 1</code>，返回 0；如果得到 <code>1 0</code> 或 <code>0 1</code>，返回 1；如果得到 <code>0 0</code>，继续抛硬币。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">coin_new</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> a = coin(), b = coin();<br>        <span class="hljs-keyword">if</span> (a &amp;&amp; b) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (a || b) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">0: 0.333663<br>1: 0.666337<br></code></pre></td></tr></table></figure><h3 id="P-0-x3D-0-3，P-1-x3D-0-7"><a href="#P-0-x3D-0-3，P-1-x3D-0-7" class="headerlink" title="P(0) &#x3D; 0.3，P(1) &#x3D; 0.7"></a>P(0) &#x3D; 0.3，P(1) &#x3D; 0.7</h3><p>每抛一次硬币，会得到二进制数的一位<br>连续抛 4 次硬币，可以等概率生成 <code>[0, 15]</code> 的每个数，记为 xx<br>去掉 <code>[10, 15]</code>，剩下 <code>[0, 9]</code> 的每个数依然是等概率的<br>如果 x∈[0,2]，返回 0；x∈[4,9]，返回 1；x≥10，重复上述过程</p><p>测试输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">0: 0.300324<br>1: 0.699676<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/09/05/image-20210905141534174.png" alt="image-20210905141534174"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>possibilities</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA on Arm - 存储单元</title>
    <link href="/2021/08/cuda-on-arm-memory/"/>
    <url>/2021/08/cuda-on-arm-memory/</url>
    
    <content type="html"><![CDATA[<p>🎉感谢来自NVIDIA企业级开发者社区的何琨（Ken）老师提供的资料和细致耐心的讲解</p><p>本篇不涉及存储单元的加速优化，重点演示最基础的内存申请释放、数据拷贝传输</p><h2 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h2><p>（这块并没有完全学完，Constant memory和Texture memory存储介绍内容来源于搜索引擎）</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/23/image-20210823233746897.png" alt="image-20210823233746897"></p><h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p>寄存器是GPU最快的memory，寄存器变量是每个线程私有的，一旦thread执行结束，寄存器变量就会失效。寄存器是稀有资源。在Fermi上，每个thread限制最多拥有63个register，Kepler则是255个。让自己的kernel使用较少的register就能够允许更多的block驻留在SM中，也就增加了Occupancy，提升了性能。</p><p>寄存器不像共享内存、设备内存、常量内存和纹理内存显式声明，它们的声明不加任何限定符，就如普通变量一样，如<code> int a</code>。</p><p>寄存器主要承担Scalar variables（标量变量）和编译时已知的静态索引的数组。</p><h3 id="Local-memory"><a href="#Local-memory" class="headerlink" title="Local memory"></a>Local memory</h3><p>有时候，如果Register不够用了，那么就会使用Local memory来代替这部分寄存器空间。</p><p>除此外，下面几种情况，编译器可能会把变量放置在Local memory：</p><ul><li>编译期无法决定确切值的本地数组。</li><li>较大的结构体或者数组，也就是那些可能会消耗大量Register的变量。</li><li>任何超过寄存器限制的变量。</li></ul><p>在Local memory中的变量本质上跟Global memory在同一块存储区。所以，Local memory有很高的atency和较低的bandwidth。在CC2.0以上，GPU针对Local memory会有L1（per-SM）和L2（per-device）两级cache。</p><h3 id="Shared-memory"><a href="#Shared-memory" class="headerlink" title="Shared memory"></a>Shared memory</h3><p>用__shared__修饰符修饰的变量存放在Shared memory。因为Shared memory是on-chip的，他相比Local Memory和Global memory来说，拥有高的多bandwidth和低很多的latency。他的使用和CPU的L1 cache非常类似，但是他是programmable的。</p><p>按惯例，像这类性能这么好的memory都是有限制的，Shared memory是以block为单位分配的。我们必须非常小心的使用Shared memory，否则会无意识的限制了active warp的数目。</p><p>不同于Register，Shared memory尽管在kernel里声明的，但是他的生命周期是伴随整个block，而不是单个thread。当该block执行完毕，他所拥有的资源就会被释放，重新分配给别的block。</p><p>Shared memory是thread交流的基本方式。同一个block中的thread通过Shared memory中的数据来相互合作。获取Shared memory的数据前必须先用__syncthreads()同步。</p><h3 id="Global-memory"><a href="#Global-memory" class="headerlink" title="Global memory"></a>Global memory</h3><p>Global Memory是空间最大，latency最高，GPU最基础的memory。“global”指明了其生命周期。任意SM都可以在整个程序的生命期中获取其状态。global中的变量既可以是静态也可以是动态声明。可以使用__device__修饰符来限定其属性。Global memory的分配就是之前频繁使用的<code>cudaMalloc</code>，释放使用<code>cudaFree</code>。Global memory驻留在Device memory，可以通过32-byte、64-byte或者128-byte三种格式传输。这些memory transaction必须是对齐的，也就是说首地址必须是32、64或者128的倍数。优化memory transaction对于性能提升至关重要。当warp执行memory load&#x2F;store时，需要的transaction数量依赖于下面两个因素：</p><ol><li>Distribution of memory address across the thread of that warp 就是前文的连续</li><li>Alignment of memory address per transaction 对齐</li></ol><p>一般来说，所需求的transaction越多，潜在的不必要数据传输就越多，从而导致throughput efficiency降低。</p><h3 id="Constant-memory"><a href="#Constant-memory" class="headerlink" title="Constant memory"></a>Constant memory</h3><p>Constant Memory驻留在Device Memory，并且使用专用的Constant cache（per-SM）。该Memory的声明应该以__connstant__修饰。Constant的范围是全局的，针对所有kernel，对于所有CC其大小都是64KB。在同一个编译单元，Constant对所有kernel可见。</p><p>当一个warp中所有thread都从同一个Memory地址读取数据时，Constant Memory表现最好。例如，计算公式中的系数。如果所有的thread从不同的地址读取数据，并且只读一次，那么Constant memory就不是很好的选择，因为一次读Constant memory操作会广播给所有thread知道。</p><h3 id="Texture-memory"><a href="#Texture-memory" class="headerlink" title="Texture memory"></a>Texture memory</h3><p>Texture Memory驻留在Device memory中，并且使用一个只读cache（per-SM）。Texture Memory实际上也是Global Memory在一块，但是他有自己专有的只读cache。这个cache在浮点运算很有用。Texture Memory是针对2D空间局部性的优化策略，所以thread要获取2D数据就可以使用Texture Memory来达到很高的性能。</p><h2 id="内存的分配与回收"><a href="#内存的分配与回收" class="headerlink" title="内存的分配与回收"></a>内存的分配与回收</h2><p>CPU内存</p><ul><li>malloc()</li><li>memset()</li><li>free()</li></ul><p>GPU内存</p><ul><li>cudaMalloc()</li><li>cudaMemset()</li><li>cudaFree()</li></ul><p><strong>当我们要为一个方阵<code>M[m * m]</code>申请GPU的存储单元时</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cudaMalloc((<span class="hljs-type">void</span> **) &amp;d_m,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * m * m);<br></code></pre></td></tr></table></figure><p><strong>d_m：</strong>指向存储在Device端数据的地址的指针（双重指针）。</p><p><strong>sizeof(int) * m * m：</strong>存储在Device端空间的大小。</p><p><strong>当我们要释放申请的GPU的存储单元时</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cudaFree(d_m);<br></code></pre></td></tr></table></figure><p>d_m：指向存储在Device端数据的地址的指针。</p><h2 id="内存拷贝"><a href="#内存拷贝" class="headerlink" title="内存拷贝"></a>内存拷贝</h2><p>**cudaMemcpy(void <em>dst, const void <em>src, size_t count, cudaMemcpyKind kind)</em></em></p><ul><li><strong>dst:</strong> 目的内存地址</li><li><strong>src:</strong> 源内存地址</li><li><strong>count:</strong> 以字节为单位要拷贝的数据大小</li><li><strong>kind:</strong> 数据传输方向</li></ul><p><strong>cudaMemcpyKind</strong></p><ul><li>cudaMemcpyHostToDevice</li><li>cudaMemcpyDeviceToHost</li><li>cudaMemcpyDeviceToDevice</li><li>cudaMemcpyHostToHost</li></ul><p><strong>当我们要将准备好的数据从CPU内存传输到GPU的存储单元时</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cudaMemcpy(d_m, h_m, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * m * m, cudaMemcpyHostToDevice);<br></code></pre></td></tr></table></figure><p><strong>d_m：</strong>传输的目的地，GPU存储单元</p><p><strong>h_m：</strong>数据的源地址，CPU存储单元</p><p><strong>sizeof(int) * m * m：</strong>数据传输的大小</p><p><strong>cudaMemcpyHostToDevice：</strong>数据传输的方向，CPU -&gt; GPU</p><p><strong>当我们要将准备好的数据从GPU存储单元传输到CPU的内存时</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cudaMemcpy(h_c, d_c, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * m * k, cudaMemcpyDeviceToHost);<br></code></pre></td></tr></table></figure><h2 id="实验（矩阵乘法）"><a href="#实验（矩阵乘法）" class="headerlink" title="实验（矩阵乘法）"></a>实验（矩阵乘法）</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/24/image-20210824000328785.png" alt="image-20210824000328785"></p><p>矩阵相乘计算样例：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/23/image-20210823235724074.png" alt="image-20210823235724074"></p><h3 id="CPU矩阵乘法"><a href="#CPU矩阵乘法" class="headerlink" title="CPU矩阵乘法"></a>CPU矩阵乘法</h3><p>使用CPU完成这一过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cpu_matrix_mult</span><span class="hljs-params">(<span class="hljs-type">int</span> *h_m, <span class="hljs-type">int</span> *h_n, <span class="hljs-type">int</span> *h_result, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j)&#123;<br><span class="hljs-type">int</span> tmp = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> h = <span class="hljs-number">0</span>; h &lt; n; ++h)&#123;<br>tmp += h_m[i * n + h] * h_n[h * k + j];<br>            &#125;<br>h_result[i * k + j] = tmp;<br>        &#125;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>可见整个计算过程需要完成三重循环，总共需要计算<code>m * n * k</code>次<code>tmp += h_m[i * n + h] * h_n[h * k + j];</code>才能完成计算。下面采用CUDA的并行编程模型来尝试去掉部分循环进行加速。</p><h3 id="二维网格和线程块"><a href="#二维网格和线程块" class="headerlink" title="二维网格和线程块"></a>二维网格和线程块</h3><p>为了解决矩阵乘法的问题，需要先搞定二维状态下线程的索引计算（当然也可以转换为一维）。</p><p>线程的索引排序方式如下图：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/24/image-20210824000858814.png" alt="image-20210824000858814"></p><p>Global linear memory index: <code>idx = iy * nx + ix</code></p><p><strong>以44号线程为例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> index = (blockIdx.y * blockDim.y + threadIdx.y) * nx+ (blockIdx.x * blockDim.x + threadIdx.x);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Index = (<span class="hljs-number">2</span> * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">8</span> + (<span class="hljs-number">1</span> * <span class="hljs-number">4</span> + <span class="hljs-number">0</span>) <br>Index = <span class="hljs-number">44</span><br></code></pre></td></tr></table></figure><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/24/image-20210824001345666.png" alt="image-20210824001345666"></p><p>将整个grid对应到整个矩阵后，就如下图所示：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/24/image-20210824001447544.png" alt="image-20210824001447544"></p><h3 id="GPU矩阵乘法"><a href="#GPU矩阵乘法" class="headerlink" title="GPU矩阵乘法"></a>GPU矩阵乘法</h3><p><strong>grid中多线程计算Pd</strong></p><ul><li>每个线程计算Pd的一个元素</li></ul><p><strong>每个线程</strong></p><ul><li>读入矩阵Md的一行，读入矩阵Nd的一列</li><li>为每对Md和Nd元素执行一次乘法和加法</li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/24/image-20210824002247739.png" alt="image-20210824002247739"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZE 16</span><br><br>__global__ <span class="hljs-type">void</span> <span class="hljs-title function_">gpu_matrix_mult</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b, <span class="hljs-type">int</span> *c, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span><br>&#123; <br>    <span class="hljs-type">int</span> row = blockIdx.y * blockDim.y + threadIdx.y; <br>    <span class="hljs-type">int</span> col = blockIdx.x * blockDim.x + threadIdx.x;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>( col &lt; k &amp;&amp; row &lt; m) <br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        &#123;<br>            sum += a[row * n + i] * b[i * k + col];<br>        &#125;<br>        c[row * k + col] = sum;<br>    &#125;<br>&#125; <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">cpu_matrix_mult</span><span class="hljs-params">(<span class="hljs-type">int</span> *h_a, <span class="hljs-type">int</span> *h_b, <span class="hljs-type">int</span> *h_result, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) <br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j) <br>        &#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-number">0.0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> h = <span class="hljs-number">0</span>; h &lt; n; ++h) <br>            &#123;<br>                tmp += h_a[i * n + h] * h_b[h * k + j];<br>            &#125;<br>            h_result[i * k + j] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> m=<span class="hljs-number">1000</span>;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">2000</span>;<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">3000</span>;<br><br>    <span class="hljs-type">int</span> *h_a, *h_b, *h_c, *h_cc;<br>    cudaMallocHost((<span class="hljs-type">void</span> **) &amp;h_a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*n);<br>    cudaMallocHost((<span class="hljs-type">void</span> **) &amp;h_b, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*n*k);<br>    cudaMallocHost((<span class="hljs-type">void</span> **) &amp;h_c, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*k);<br>    cudaMallocHost((<span class="hljs-type">void</span> **) &amp;h_cc, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*k);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            h_a[i * n + j] = rand() % <span class="hljs-number">1024</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j) &#123;<br>            h_b[i * k + j] = rand() % <span class="hljs-number">1024</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> *d_a, *d_b, *d_c;<br>    cudaMalloc((<span class="hljs-type">void</span> **) &amp;d_a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*n);<br>    cudaMalloc((<span class="hljs-type">void</span> **) &amp;d_b, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*n*k);<br>    cudaMalloc((<span class="hljs-type">void</span> **) &amp;d_c, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*k);<br><br>    <span class="hljs-comment">// copy matrix A and B from host to device memory</span><br>    cudaMemcpy(d_a, h_a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*n, cudaMemcpyHostToDevice);<br>    cudaMemcpy(d_b, h_b, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*n*k, cudaMemcpyHostToDevice);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> grid_rows = (m + BLOCK_SIZE - <span class="hljs-number">1</span>) / BLOCK_SIZE;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> grid_cols = (k + BLOCK_SIZE - <span class="hljs-number">1</span>) / BLOCK_SIZE;<br>    dim3 <span class="hljs-title function_">dimGrid</span><span class="hljs-params">(grid_cols, grid_rows)</span>;<br>    dim3 <span class="hljs-title function_">dimBlock</span><span class="hljs-params">(BLOCK_SIZE, BLOCK_SIZE)</span>;<br>    gpu_matrix_mult&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;(d_a, d_b, d_c, m, n, k);    <br>    cudaMemcpy(h_c, d_c, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*k, cudaMemcpyDeviceToHost);<br><br>    cpu_matrix_mult(h_a, h_b, h_cc, m, n, k);<br><br>    <span class="hljs-type">int</span> ok = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(h_cc[i*k + j] - h_c[i*k + j])&gt;(<span class="hljs-number">1.0e-10</span>))<br>            &#123;<br>                ok = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(ok)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pass!!!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error!!!\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// free memory</span><br>    cudaFree(d_a);<br>    cudaFree(d_b);<br>    cudaFree(d_c);<br>    cudaFreeHost(h_a);<br>    cudaFreeHost(h_b);<br>    cudaFreeHost(h_c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><h4 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">__global__ <span class="hljs-type">void</span> <span class="hljs-title function_">gpu_matrix_mult</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b, <span class="hljs-type">int</span> *c, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span><br>&#123; <br>    <span class="hljs-type">int</span> row = blockIdx.y * blockDim.y + threadIdx.y; <br>    <span class="hljs-type">int</span> col = blockIdx.x * blockDim.x + threadIdx.x;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>( col &lt; k &amp;&amp; row &lt; m) <br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        &#123;<br>            sum += a[row * n + i] * b[i * k + col];<br>        &#125;<br>        c[row * k + col] = sum;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>先计算好元素在矩阵中的行和列，每一个线程处理了矩阵Md的一行和矩阵Nd的一列，分别相乘再相加。将计算好的最终值写入Pd矩阵的对应位置即可。</p><p>这里需要注意索引的计算方式，我们输入的矩阵实际上是一个一维的数组，那么需要将二维坐标线性化。</p><h4 id="CPU计算函数"><a href="#CPU计算函数" class="headerlink" title="CPU计算函数"></a>CPU计算函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cpu_matrix_mult</span><span class="hljs-params">(<span class="hljs-type">int</span> *h_a, <span class="hljs-type">int</span> *h_b, <span class="hljs-type">int</span> *h_result, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) <br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j) <br>        &#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-number">0.0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> h = <span class="hljs-number">0</span>; h &lt; n; ++h) <br>            &#123;<br>                tmp += h_a[i * n + h] * h_b[h * k + j];<br>            &#125;<br>            h_result[i * k + j] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将CPU计算结果作为标准来对GPU计算结果进行校验。</p><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *h_a, *h_b, *h_c, *h_cc;<br>cudaMallocHost((<span class="hljs-type">void</span> **) &amp;h_a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*n);<br>cudaMallocHost((<span class="hljs-type">void</span> **) &amp;h_b, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*n*k);<br>cudaMallocHost((<span class="hljs-type">void</span> **) &amp;h_c, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*k);<br>cudaMallocHost((<span class="hljs-type">void</span> **) &amp;h_cc, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*k);<br></code></pre></td></tr></table></figure><p>定义变量并在Host上分配数组空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>        h_a[i * n + j] = rand() % <span class="hljs-number">1024</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j) &#123;<br>        h_b[i * k + j] = rand() % <span class="hljs-number">1024</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Host端初始化数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *d_a, *d_b, *d_c;<br>cudaMalloc((<span class="hljs-type">void</span> **) &amp;d_a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*n);<br>cudaMalloc((<span class="hljs-type">void</span> **) &amp;d_b, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*n*k);<br>cudaMalloc((<span class="hljs-type">void</span> **) &amp;d_c, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*k);<br></code></pre></td></tr></table></figure><p>定义变量，并调用<code>cudaMalloc</code>在GPU端为变量分配内存空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cudaMemcpy(d_a, h_a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*n, cudaMemcpyHostToDevice);<br>cudaMemcpy(d_b, h_b, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*n*k, cudaMemcpyHostToDevice);<br></code></pre></td></tr></table></figure><p>将在CPU端初始化好的数组拷贝到GPU，便于在GPU并行处理数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">dim3 <span class="hljs-title function_">dimGrid</span><span class="hljs-params">(grid_cols, grid_rows)</span>;<br>dim3 <span class="hljs-title function_">dimBlock</span><span class="hljs-params">(BLOCK_SIZE, BLOCK_SIZE)</span>;<br>gpu_matrix_mult&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;(d_a, d_b, d_c, m, n, k); <br>cudaMemcpy(h_c, d_c, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*m*k, cudaMemcpyDeviceToHost);<br></code></pre></td></tr></table></figure><p>完成执行设置并调用核函数，在GPU上开始程序的并行部分。</p><p>计算完成后结果存储在<code>d_c</code>所指向的GPU内存中，需要调用<code>cudaMemcpy</code>将数据从Device拷贝到Host中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">cpu_matrix_mult(h_a, h_b, h_cc, m, n, k);<br><br><span class="hljs-type">int</span> ok = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(h_cc[i*k + j] - h_c[i*k + j])&gt;(<span class="hljs-number">1.0e-10</span>))<br>        &#123;<br>            ok = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(ok)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pass!!!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error!!!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在CPU中完成标准答案的计算并与GPU计算结果进行对比校验。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">cudaFree(d_a);<br>cudaFree(d_b);<br>cudaFree(d_c);<br>cudaFreeHost(h_a);<br>cudaFreeHost(h_b);<br>cudaFreeHost(h_c);<br></code></pre></td></tr></table></figure><p>调用<code>cudaFree</code>相关函数释放刚刚在Host和Device中分配的内存，随即程序结束。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Course</category>
      
      <category>CUDA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>jetson</tag>
      
      <tag>cuda</tag>
      
      <tag>GPU</tag>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA on Arm - 线程层次</title>
    <link href="/2021/08/cuda-on-arm-thread/"/>
    <url>/2021/08/cuda-on-arm-thread/</url>
    
    <content type="html"><![CDATA[<p>🎉感谢来自NVIDIA企业级开发者社区的何琨（Ken）老师提供的资料和细致耐心的讲解</p><h2 id="线程层次"><a href="#线程层次" class="headerlink" title="线程层次"></a>线程层次</h2><p><strong>Thread: sequential execution unit</strong></p><ul><li>所有线程执行相同的核函数</li><li>并行执行</li></ul><p><strong>Thread Block: a group of threads</strong></p><ul><li>执行在一个Streaming Multiprocessor [SM]</li><li>同一个Block中的线程可以协作</li></ul><p><strong>Thread Grid: a collection of thread blocks</strong></p><ul><li>一个Grid当中的Block可以在多个SM中执行</li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822154013395.png" alt="image-20210822154013395"></p><h3 id="执行设置"><a href="#执行设置" class="headerlink" title="执行设置"></a>执行设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dim3 <span class="hljs-title function_">grid</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span>, <span class="hljs-title function_">block</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure><p>如下图所示👇</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822154154061.png" alt="image-20210822154154061"></p><h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><p><strong>threadldx.[x yz]</strong></p><ul><li>是执行当前kernel函数的线程在block中的索引值</li></ul><p><strong>blockldx.[x y z]</strong></p><ul><li>是指执行当前kernel函数的线程所在block，在grid中的索引值</li></ul><p><strong>blockDim.lx y z]</strong></p><ul><li>表示一个grid中包含多少个block</li></ul><p><strong>gridDim.[x y z]</strong></p><ul><li>表示一个block中包含多少个线程</li></ul><h3 id="执行配置举例"><a href="#执行配置举例" class="headerlink" title="执行配置举例"></a>执行配置举例</h3><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">__global__ <span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">( <span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b,<span class="hljs-type">int</span> *c )</span> &#123;<br>c[threadIdx.x] = a[threadIdx.x]+ b[threadIdx.x];<br>&#125;<br>add&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&gt;&gt;&gt;( a, b, c );<br></code></pre></td></tr></table></figure><p><strong>实际运行的样子：</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822161450699.png" alt="image-20210822161450699"></p><h3 id="软硬件对应关系"><a href="#软硬件对应关系" class="headerlink" title="软硬件对应关系"></a>软硬件对应关系</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822220943869.png" alt="image-20210822220943869"></p><p>这也说明了为什么不只有线程，而引入块和网格的概念的原因，这都是与GPU硬件架构息息相关的。</p><h3 id="CUDA的执行流程"><a href="#CUDA的执行流程" class="headerlink" title="CUDA的执行流程"></a>CUDA的执行流程</h3><ol><li>加载核函数。</li><li>将Grid分配到一个Device。</li><li>根据&lt;&lt;&lt;..&gt;&gt;&gt;内的执行设置的第一个参数，Giga threads engine将block分配到SM中。一个Block内的线程一定会在同一个SM内，一个SM可以有很多个Block。</li><li>根据&lt;&lt;&lt;..&gt;&gt;&gt;内的执行设置的第二个参数，Warp调度器会将调用线程。</li><li>Warp调度器为了提高运行效率，会将每32个线程分为一组，称作一个warp。</li><li>每个Warp会被分配到32个core上运行。</li></ol><h3 id="硬件调度"><a href="#硬件调度" class="headerlink" title="硬件调度"></a>硬件调度</h3><ul><li>Grid：GPU(GPC)级别的调度单位</li><li>Block(CTA)：SM级别的调度单位</li><li>Threads&#x2F;Warp：CUDA core级别的调度单位</li></ul><h3 id="资源和通信"><a href="#资源和通信" class="headerlink" title="资源和通信"></a>资源和通信</h3><ul><li>Grid：共享同样的kernel和 Context</li><li>Block(CTA)：同一个SM(Streaming Multi processor)，同一个SM(Shared Memory)</li><li>Threads&#x2F;Warp：允许同一个warp中的thread读取其他thread的值</li></ul><p><a href="https://gallery.jason-xy.cn/image/B2Yb"><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822221554288.png" alt="image-20210822221554288.png"></a></p><h2 id="CUDA的线程索引"><a href="#CUDA的线程索引" class="headerlink" title="CUDA的线程索引"></a>CUDA的线程索引</h2><h3 id="确定线程执行的数据"><a href="#确定线程执行的数据" class="headerlink" title="确定线程执行的数据"></a>确定线程执行的数据</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822222313241.png" alt="image-20210822222313241"></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">__global__ <span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> *x, <span class="hljs-type">const</span> <span class="hljs-type">double</span>*y, <span class="hljs-type">double</span> *z)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = blockDim.x * blockldx.x + threadldx.x;<br>    z[n] = x[n]+ y[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>每个线程都执行相同的指令。</p><h2 id="实验（VectorAdd-矩阵加法）"><a href="#实验（VectorAdd-矩阵加法）" class="headerlink" title="实验（VectorAdd 矩阵加法）"></a>实验（VectorAdd 矩阵加法）</h2><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> __global__ <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> *x, <span class="hljs-type">const</span> <span class="hljs-type">double</span> *y, <span class="hljs-type">double</span> *z)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = blockDim.x * blockIdx.x + threadIdx.x;<br>    z[n] = x[n] + y[n];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> *z, <span class="hljs-type">const</span> <span class="hljs-type">int</span> N)</span><br>&#123;<br>    <span class="hljs-type">bool</span> error = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; N; ++n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(z[n] - <span class="hljs-number">3</span>) &gt; (<span class="hljs-number">1.0e-10</span>))<br>        &#123;<br>            error = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, error ? <span class="hljs-string">&quot;Errors&quot;</span> : <span class="hljs-string">&quot;Pass&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100000000</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>) * N;<br>    <span class="hljs-type">double</span> *h_x = (<span class="hljs-type">double</span>*) <span class="hljs-built_in">malloc</span>(M);<br>    <span class="hljs-type">double</span> *h_y = (<span class="hljs-type">double</span>*) <span class="hljs-built_in">malloc</span>(M);<br>    <span class="hljs-type">double</span> *h_z = (<span class="hljs-type">double</span>*) <span class="hljs-built_in">malloc</span>(M);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; N; ++n)<br>    &#123;<br>        h_x[n] = <span class="hljs-number">1</span>;<br>        h_y[n] = <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-type">double</span> *d_x, *d_y, *d_z;<br>    cudaMalloc((<span class="hljs-type">void</span> **)&amp;d_x, M);<br>    cudaMalloc((<span class="hljs-type">void</span> **)&amp;d_y, M);<br>    cudaMalloc((<span class="hljs-type">void</span> **)&amp;d_z, M);<br>    cudaMemcpy(d_x, h_x, M, cudaMemcpyHostToDevice);<br>    cudaMemcpy(d_y, h_y, M, cudaMemcpyHostToDevice);<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> block_size = <span class="hljs-number">128</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> grid_size = (N + block_size - <span class="hljs-number">1</span>) / block_size;<br>    add&lt;&lt;&lt;grid_size, block_size&gt;&gt;&gt;(d_x, d_y, d_z);<br><br>    cudaMemcpy(h_z, d_z, M, cudaMemcpyDeviceToHost);<br>    check(h_z, N);<br><br>    <span class="hljs-built_in">free</span>(h_x);<br>    <span class="hljs-built_in">free</span>(h_y);<br>    <span class="hljs-built_in">free</span>(h_z);<br>    cudaFree(d_x);<br>    cudaFree(d_y);<br>    cudaFree(d_z);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><h4 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __global__ <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> *x, <span class="hljs-type">const</span> <span class="hljs-type">double</span> *y, <span class="hljs-type">double</span> *z)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = blockDim.x * blockIdx.x + threadIdx.x;<br>    z[n] = x[n] + y[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>核函数就是给每一个线程分配的任务，这里将矩阵的每一个数据由一个线程处理，那么每一个线程只需要处理一个加法即可。</p><p>每一个线程处理的数据由线程id决定（在所有线程中的id），这里的<code>n = blockDim.x * blockIdx.x + threadIdx.x</code>便计算出了线程索引，正好与数据索引一一对应，由此便实现了单指令多数据的并行处理。</p><h4 id="校验函数"><a href="#校验函数" class="headerlink" title="校验函数"></a>校验函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> *z, <span class="hljs-type">const</span> <span class="hljs-type">int</span> N)</span><br>&#123;<br>    <span class="hljs-type">bool</span> error = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; N; ++n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(z[n] - <span class="hljs-number">3</span>) &gt; (<span class="hljs-number">1.0e-10</span>))<br>        &#123;<br>            error = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, error ? <span class="hljs-string">&quot;Errors&quot;</span> : <span class="hljs-string">&quot;Pass&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将CPU计算结果作为基准与GPU计算结果对比校验是否计算正确。</p><h4 id="主函数部分"><a href="#主函数部分" class="headerlink" title="主函数部分"></a>主函数部分</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100000000</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>) * N;<br><span class="hljs-type">double</span> *h_x = (<span class="hljs-type">double</span>*) <span class="hljs-built_in">malloc</span>(M);<br><span class="hljs-type">double</span> *h_y = (<span class="hljs-type">double</span>*) <span class="hljs-built_in">malloc</span>(M);<br><span class="hljs-type">double</span> *h_z = (<span class="hljs-type">double</span>*) <span class="hljs-built_in">malloc</span>(M);<br></code></pre></td></tr></table></figure><p>定义变量，并在host（CPU）中分配存储空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; N; ++n)<br>&#123;<br>    h_x[n] = <span class="hljs-number">1</span>;<br>    h_y[n] = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>给输入矩阵赋初值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> *d_x, *d_y, *d_z;<br>cudaMalloc((<span class="hljs-type">void</span> **)&amp;d_x, M);<br>cudaMalloc((<span class="hljs-type">void</span> **)&amp;d_y, M);<br>cudaMalloc((<span class="hljs-type">void</span> **)&amp;d_z, M);<br>cudaMemcpy(d_x, h_x, M, cudaMemcpyHostToDevice);<br>cudaMemcpy(d_y, h_y, M, cudaMemcpyHostToDevice);<br></code></pre></td></tr></table></figure><p>定义变量后，使用<code>cudaMalloc</code>在device（GPU）中分配空间，使用<code>cudaMemcpy</code>将数据从host内存拷贝到device内存。</p><p><code>cudaMalloc((void **)ptr, size_byte)</code>中<code>ptr</code>是一个指向device memory地址的指针，所以这里是一个双重指针，<code>size_byte</code>就是分配的空间大小了，以<strong>字节</strong>为单位。</p><p><code>cudaMemcpy(dst, src, size_byte, direction)</code>中 <code>direction</code>是指传输方向，具体的可选项请查询手册。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> block_size = <span class="hljs-number">128</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> grid_size = (N + block_size - <span class="hljs-number">1</span>) / block_size;<br>add&lt;&lt;&lt;grid_size, block_size&gt;&gt;&gt;(d_x, d_y, d_z);<br></code></pre></td></tr></table></figure><p>这里是核函数执行配置及调用，也就是程序开始并行化的部分。</p><p>关于执行配置的详细说明见后文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cudaMemcpy(h_z, d_z, M, cudaMemcpyDeviceToHost);<br>check(h_z, N);<br></code></pre></td></tr></table></figure><p>将数据拷贝回host并校验数据正确性。</p><p><code>cudaMemcpy</code>中隐式执行了设备同步所以不用显示调用<code>cudaDeviceSynchronize()</code>来完成同步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">free</span>(h_x);<br><span class="hljs-built_in">free</span>(h_y);<br><span class="hljs-built_in">free</span>(h_z);<br>cudaFree(d_x);<br>cudaFree(d_y);<br>cudaFree(d_z);<br></code></pre></td></tr></table></figure><p>释放内存，程序结束。</p><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvcc vectorAdd.cu -o vectorAdd<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Pass</span><br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h2><h3 id="如何设置Gridsize-amp-Blocksize"><a href="#如何设置Gridsize-amp-Blocksize" class="headerlink" title="如何设置Gridsize &amp; Blocksize"></a>如何设置Gridsize &amp; Blocksize</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">block_size = <span class="hljs-number">128</span>;<br>grid_size =(N + block_size - <span class="hljs-number">1</span>] / block_size;<br></code></pre></td></tr></table></figure><p>这样可以最大限度地少浪费线程资源。</p><p><code>grid_size = (n + block_size - 1) / block_size</code>可以这么理解，如果<code>n = a * block_size + b</code>（a为0 or 正整数，b为小于block_size的0 or 正整数）, 那么<code>(n + block_size - 1) / block_size</code>等价于<code>(a * block_size + b + block_size - 1) / block_size</code>等价于<code>a + (b + block_size - 1) / block_size</code>，由于会向下取整，所以<code>(b + block_size - 1) / block_size</code> 等价于1，最终<code>(n + block_size - 1) / block_size = a + 1</code>。<br>如果<code>n = a * block_size + b</code>定义为，a个线程block+个数小于block_size的零散的thread， 那么上面推导出的那个a就是值a个block，而上面推导出的+1就是为个数小于block_size的零散的thread而专门设置的block。</p><h3 id="每个BLOCK可以申请多少个线程"><a href="#每个BLOCK可以申请多少个线程" class="headerlink" title="每个BLOCK可以申请多少个线程"></a>每个BLOCK可以申请多少个线程</h3><p>在<code>cd /usr/local/cuda/samples/1_Utilities/deviceQuery</code>中执行<code>./deviceQuery</code>可以查询到如下信息：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822230802528.png" alt="image-20210822230802528"></p><h3 id="数据过大，线程不够用怎么办"><a href="#数据过大，线程不够用怎么办" class="headerlink" title="数据过大，线程不够用怎么办"></a>数据过大，线程不够用怎么办</h3><p>采用滑动窗口的思想来处理数据，如下图所示：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822231019733.png" alt="image-20210822231019733"></p><p>参考代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">__global__ <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> *x, <span class="hljs-type">const</span> <span class="hljs-type">double</span> *y, <span class="hljs-type">double</span> *z, in</span><br><span class="hljs-params">&#123;</span><br><span class="hljs-params"><span class="hljs-type">int</span> index = blockDim.x * blockldx.x + threadldx.x;</span><br><span class="hljs-params">    <span class="hljs-type">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="hljs-params"><span class="hljs-keyword">for</span>(; index &lt; n; index += stride)</span><br><span class="hljs-params">z[index] = x[index] + y[index];</span><br><span class="hljs-params">&#125;</span><br></code></pre></td></tr></table></figure><p>这里的<code>stride</code>即为每次滑动的距离。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Course</category>
      
      <category>CUDA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>jetson</tag>
      
      <tag>cuda</tag>
      
      <tag>GPU</tag>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA on Arm - 并行计算基础</title>
    <link href="/2021/08/cuda-on-arm-parallelcomputing/"/>
    <url>/2021/08/cuda-on-arm-parallelcomputing/</url>
    
    <content type="html"><![CDATA[<p>🎉感谢来自NVIDIA企业级开发者社区的何琨（Ken）老师提供的资料和细致耐心的讲解</p><h2 id="异构计算"><a href="#异构计算" class="headerlink" title="异构计算"></a>异构计算</h2><p><strong>术语：</strong></p><p>Host： CPU和内存（host memory）</p><p>Device：GPU和显存（device memory）</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/16/image-20210816140636318.png" alt="image-20210816140636318"></p><h2 id="CUDA安装"><a href="#CUDA安装" class="headerlink" title="CUDA安装"></a>CUDA安装</h2><h3 id="适用设备"><a href="#适用设备" class="headerlink" title="适用设备"></a>适用设备</h3><p>所有包含NVIDIA GPU的服务器，工作站，个人电脑，嵌入式设备等电子设备。</p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><strong>Windows：</strong><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-microsoft-windows/index.html">https://docs.nvidia.com/cuda/cuda-installation-guide-microsoft-windows/index.html</a></p><p>Windows安装最简单，只需运行一个exe即可。</p><p><strong>Linux：</strong><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html">https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html</a></p><p>具体步骤也可以参考我的这篇博文，但由于时间推移注意替换软件版本号。</p><p><a href="https://jason-xy.cn/2020/07/ubuntu_nvidia/">Ubuntu20.04下安装Cuda11.0+Nvidia-440+Cudnn7.1.4</a></p><p><strong>Jetson：</strong><a href="https://developer.nvidia.com/embedded/jetpack">https://developer.nvidia.com/embedded/jetpack</a></p><p>采用NVIDIA SDK Manager安装。</p><p><strong>GPU状态查询：</strong></p><p>PC、工作站：<code>nvidia-smi</code></p><p>Jetson：<code>jtop</code></p><p>GPU信息查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/local/cuda/samples/1_Utilities/deviceQuery<br>./deviceQuery<br></code></pre></td></tr></table></figure><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/16/image-20210816142314321.png" alt="image-20210816142314321"></p><h2 id="CUDA程序的编写模型"><a href="#CUDA程序的编写模型" class="headerlink" title="CUDA程序的编写模型"></a>CUDA程序的编写模型</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822135353790.png" alt="image-20210822135353790"></p><h3 id="把输入数据从CPU内存复制到GPU显存"><a href="#把输入数据从CPU内存复制到GPU显存" class="headerlink" title="把输入数据从CPU内存复制到GPU显存"></a>把输入数据从CPU内存复制到GPU显存</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822135532199.png" alt="image-20210822135532199"></p><h3 id="在执行芯片上缓存数据，加载GPU程序并执行"><a href="#在执行芯片上缓存数据，加载GPU程序并执行" class="headerlink" title="在执行芯片上缓存数据，加载GPU程序并执行"></a>在执行芯片上缓存数据，加载GPU程序并执行</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822135626626.png" alt="image-20210822135626626"></p><h3 id="将计算结果从GPU显存中复制到CPU内存中"><a href="#将计算结果从GPU显存中复制到CPU内存中" class="headerlink" title="将计算结果从GPU显存中复制到CPU内存中"></a>将计算结果从GPU显存中复制到CPU内存中</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822135754435.png" alt="image-20210822135754435"></p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/16/image-20210816143012665.png" alt="image-20210816143012665"></p><h3 id="CUDA程序案例"><a href="#CUDA程序案例" class="headerlink" title="CUDA程序案例"></a>CUDA程序案例</h3><p><strong>核函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">__global__ <span class="hljs-type">void</span> <span class="hljs-title function_">gpu_kernel</span><span class="hljs-params">(<span class="hljs-type">int</span> input_M[N * N], <span class="hljs-type">int</span> output_M[N * N])</span><br>&#123;<br>    <span class="hljs-type">int</span> idx = blockIdx.x * blockDim.x + threadIdx.x;<br>    <span class="hljs-keyword">if</span> (idx &gt;= N * N)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (input_M[idx] &gt; <span class="hljs-number">100</span>)<br>        output_M[idx] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input_M[idx] &lt; <span class="hljs-number">100</span>)<br>        output_M[idx] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核函数配置及调用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc <span class="hljs-type">char</span> **argv)</span>&#123;<br>...<br><span class="hljs-comment">//kernel configuration</span><br>    dim3 <span class="hljs-title function_">dimGrid</span><span class="hljs-params">(<span class="hljs-built_in">ceil</span>(N/TILE_DIM), <span class="hljs-built_in">ceil</span>(M/TILE_DIM), <span class="hljs-number">1</span>)</span>;<span class="hljs-comment">//网格大小配置</span><br>    dim3 <span class="hljs-title function_">dimBlock</span><span class="hljs-params">(TILE_DIM, BLOCK_ROWS, <span class="hljs-number">1</span>)</span>;<span class="hljs-comment">//块大小配置</span><br>    <span class="hljs-comment">//&lt;&lt;&lt;执行配置&gt;&gt;&gt;指定了线程数量以及线程分组</span><br>    gpu_kernel&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;(inputMat, outputMat);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CUDA程序的编译"><a href="#CUDA程序的编译" class="headerlink" title="CUDA程序的编译"></a>CUDA程序的编译</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/16/image-20210816143817075.png" alt="image-20210816143817075"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/16/image-20210816144054858.png" alt="image-20210816144054858"></p><h3 id="NVCC使用案例"><a href="#NVCC使用案例" class="headerlink" title="NVCC使用案例"></a>NVCC使用案例</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822141032544.png" alt="image-20210822141032544"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvcc --device-c hello_from_gpu.cu -o hello_from_gpu.o<br>nvcc hello_from_gpu.o hello_cuda_main.cu -o hello_from_gpu<br></code></pre></td></tr></table></figure><h2 id="CUDA程序性能分析"><a href="#CUDA程序性能分析" class="headerlink" title="CUDA程序性能分析"></a>CUDA程序性能分析</h2><h3 id="NVPROF"><a href="#NVPROF" class="headerlink" title="NVPROF"></a>NVPROF</h3><p>Kernel Timeline输出的是以gpu kernel为单位的一段时间的运行时间线，我们可以通过它观察GPU在什么时候有闲置或者利用不够充分的行为，更准确地定位优化问题。nvprof是nvidia提供的用于生成gpu timeline的工具，其为cuda toolkit的自带工具。</p><p>可以结合nvvp和nsight进行可视化分析。</p><h3 id="NVPROF-使用案例"><a href="#NVPROF-使用案例" class="headerlink" title="NVPROF 使用案例"></a>NVPROF 使用案例</h3><p><strong>查看a.exe的运行总体情况：</strong></p><p>在不指定参数的情况下默认输出<code>--print-api-summary</code></p><p>执行时可能需要管理员权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvprof a.exe<br></code></pre></td></tr></table></figure><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822141513806.png" alt="image-20210822141513806"></p><p><strong>查看a.exe的运行流程：</strong></p><p>需要指定参数：<code>--print-api-trace</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvprof --print-api-trace a.exe<br></code></pre></td></tr></table></figure><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/22/image-20210822141641403.png" alt="image-20210822141641403"></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="编写第一个CUDA程序"><a href="#编写第一个CUDA程序" class="headerlink" title="编写第一个CUDA程序"></a>编写第一个CUDA程序</h2><ul><li>关键词：&quot;__global__&quot; ,  &lt;&lt;&lt;…&gt;&gt;&gt;  ,  .cu</li></ul><p>在当前的目录下创建一个名为hello_cuda.cu的文件，编写第一个Cuda程序：</p><p><strong>CPU版本</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvcc hello_cuda.cu -o hello_cuda<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Hello World!<br></code></pre></td></tr></table></figure><p>GPU版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br>__global__ <span class="hljs-type">void</span> <span class="hljs-title function_">cuda_hello</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello CUDA from GPU!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    cuda_hello&lt;&lt;&lt;<span class="hljs-number">8</span>,<span class="hljs-number">1</span>&gt;&gt;&gt;();<br>    cudaDeviceSynchronize();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvcc hello_cuda.cu -o hello_cuda<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br></code></pre></td></tr></table></figure><h2 id="使用nvprof查看程序性能"><a href="#使用nvprof查看程序性能" class="headerlink" title="使用nvprof查看程序性能"></a>使用nvprof查看程序性能</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /usr/local/cuda/bin/nvprof --print-api-summary ./hello_cuda<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">==<span class="hljs-number">17055</span>== NVPROF is profiling process <span class="hljs-number">17055</span>, command: ./hello_cuda<br>==<span class="hljs-number">17055</span>== Warning: Unified Memory Profiling is not supported on the underlying platform. System requirements for unified memory can be found at: http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#um-requirements<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>Hello CUDA from GPU!<br>==<span class="hljs-number">17055</span>== Profiling application: ./hello_cuda<br>==<span class="hljs-number">17055</span>== Profiling result:<br>            Type  Time(<span class="hljs-comment">%)      Time     Calls       Avg       Min       Max  Name</span><br>      API calls:   <span class="hljs-number">99.89</span><span class="hljs-comment">%  361.69ms         1  361.69ms  361.69ms  361.69ms  cudaLaunchKernel</span><br>                    <span class="hljs-number">0.06</span><span class="hljs-comment">%  213.18us        97  2.1970us     960ns  58.272us  cuDeviceGetAttribute</span><br>                    <span class="hljs-number">0.04</span><span class="hljs-comment">%  136.67us         1  136.67us  136.67us  136.67us  cudaDeviceSynchronize</span><br>                    <span class="hljs-number">0.01</span><span class="hljs-comment">%  21.152us         1  21.152us  21.152us  21.152us  cuDeviceTotalMem</span><br>                    <span class="hljs-number">0.00</span><span class="hljs-comment">%  10.432us         3  3.4770us  1.5360us  5.4720us  cuDeviceGetCount</span><br>                    <span class="hljs-number">0.00</span><span class="hljs-comment">%  8.0320us         2  4.0160us  2.1440us  5.8880us  cuDeviceGet</span><br>                    <span class="hljs-number">0.00</span><span class="hljs-comment">%  2.9120us         1  2.9120us  2.9120us  2.9120us  cuDeviceGetName</span><br>                    <span class="hljs-number">0.00</span><span class="hljs-comment">%  1.5040us         1  1.5040us  1.5040us  1.5040us  cuDeviceGetUuid</span><br></code></pre></td></tr></table></figure><h2 id="尝试利用CUDA-API打印GPU参数"><a href="#尝试利用CUDA-API打印GPU参数" class="headerlink" title="尝试利用CUDA API打印GPU参数"></a>尝试利用CUDA API打印GPU参数</h2><p>device.cu</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-comment">//define variables</span><br>    <span class="hljs-type">int</span> deviceCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dev = <span class="hljs-number">0</span>, driverVersion = <span class="hljs-number">0</span>, runtimeVersion = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//count device</span><br>    cudaError_t error_id = cudaGetDeviceCount(&amp;deviceCount);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Detected %d CUDA Capable device(s)\n&quot;</span>, deviceCount);<br>    <br>    <span class="hljs-comment">//select device</span><br>    cudaSetDevice(dev);<br>    cudaDeviceProp deviceProp;<br>    cudaGetDeviceProperties(&amp;deviceProp, dev);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Device %d: \&quot;%s\&quot;\n&quot;</span>, dev, deviceProp.name);<br>    <br>    <span class="hljs-comment">//CUDA info</span><br>    cudaDriverGetVersion(&amp;driverVersion);<br>    cudaRuntimeGetVersion(&amp;runtimeVersion);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CUDA Driver Version / Runtime Version          %d.%d / %d.%d\n&quot;</span>,<br>           driverVersion / <span class="hljs-number">1000</span>, (driverVersion % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>,<br>           runtimeVersion / <span class="hljs-number">1000</span>, (runtimeVersion % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CUDA Capability Major/Minor version number:    %d.%d\n&quot;</span>,<br>           deviceProp.major, deviceProp.minor);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvcc device.cu -o device<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Detected</span> <span class="hljs-number">1</span> CUDA Capable device(s)<br><span class="hljs-attribute">Device</span> <span class="hljs-number">0</span>: <span class="hljs-string">&quot;Xavier&quot;</span><br><span class="hljs-attribute">CUDA</span> Driver Version / Runtime Version          <span class="hljs-number">10</span>.<span class="hljs-number">2</span> / <span class="hljs-number">10</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">CUDA</span> Capability Major/Minor version number:    <span class="hljs-number">7</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Course</category>
      
      <category>CUDA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>jetson</tag>
      
      <tag>cuda</tag>
      
      <tag>GPU</tag>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA on Arm-GPU硬件架构</title>
    <link href="/2021/08/cuda-on-arm-gpuhardware/"/>
    <url>/2021/08/cuda-on-arm-gpuhardware/</url>
    
    <content type="html"><![CDATA[<p>🎉感谢来自NVIDIA企业级开发者社区的何琨（Ken）老师提供的资料和细致耐心的讲解</p><h2 id="GPU简介"><a href="#GPU简介" class="headerlink" title="GPU简介"></a>GPU简介</h2><h3 id="GPU计算性能变迁"><a href="#GPU计算性能变迁" class="headerlink" title="GPU计算性能变迁"></a>GPU计算性能变迁</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821170245589.png" alt="image-20210821170245589"></p><h3 id="体系结构层次"><a href="#体系结构层次" class="headerlink" title="体系结构层次"></a>体系结构层次</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/16/image-20210816110140126.png" alt="image-20210816110140126"></p><h2 id="更快的计算机"><a href="#更快的计算机" class="headerlink" title="更快的计算机"></a>更快的计算机</h2><h4 id="更多的晶体管"><a href="#更多的晶体管" class="headerlink" title="更多的晶体管"></a>更多的晶体管</h4><p>截至今日（2021-8-21）最新的Intel Alder Lake CPU构架如下图所示 <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/Alder_Lake.jpg" alt="Alder_Lake"></p><h4 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h4><p>芯片的集成密度每2年翻翻，成本下降一半。</p><p>可是…….</p><p>常规传统单核处理器遇到物理约束，时钟频率〔perf&#x2F;clock]无法保持线型增长。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821171147714.png" alt="image-20210821171147714"></p><p>现在的CPU系统已经遇到各种瓶颈，只能向多核及并行系统发展。<br>顺势而生的GPU- Graphics Processing Unit如下图</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821171339020.png" alt="image-20210821171339020"></p><h4 id="GPU计算性能与数据带宽"><a href="#GPU计算性能与数据带宽" class="headerlink" title="GPU计算性能与数据带宽"></a>GPU计算性能与数据带宽</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821171354030.png" alt="image-20210821171354030"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821171416620.png" alt="image-20210821171416620"></p><h2 id="GPU设计思想"><a href="#GPU设计思想" class="headerlink" title="GPU设计思想"></a>GPU设计思想</h2><h3 id="内核设计"><a href="#内核设计" class="headerlink" title="内核设计"></a>内核设计</h3><p><strong>CPU类型的内核</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821171532969.png" alt="image-20210821171532969"></p><p>实际上正真用于计算的单元在内核面积中占比并不算高，更多的都是用于控制和存储的机构，例如对于指令流水线、乱序执行、分支预测等支持部件。而GPU内核就在此基础上精简掉不必要的结构，先安排计算核心而后考虑别的方法去添加控制与存储部件。</p><p><strong>精简后的CPU内核</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821171852540.png" alt="image-20210821171852540"></p><p>将多个这样精简后的内核组合到一块就得到了GPU内核的雏形。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821172130738.png" alt="image-20210821172130738"></p><h3 id="芯片结构"><a href="#芯片结构" class="headerlink" title="芯片结构"></a>芯片结构</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821172246899.png" alt="image-20210821172246899"></p><p><strong>GA-100结构</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821200425778.png" alt="image-20210821200425778.png"></p><h3 id="GPU-on-Arm"><a href="#GPU-on-Arm" class="headerlink" title="GPU on Arm"></a>GPU on Arm</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821172457800.png" alt="image-20210821172457800"></p><h2 id="GPU应用场景"><a href="#GPU应用场景" class="headerlink" title="GPU应用场景"></a>GPU应用场景</h2><h3 id="快递员送披萨问题"><a href="#快递员送披萨问题" class="headerlink" title="快递员送披萨问题"></a>快递员送披萨问题</h3><p><strong>CPU处理</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821172656932.png" alt="image-20210821172656932"></p><p><strong>GPU处理</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821172722721.png" alt="image-20210821172722721.png"></p><h3 id="CUDA并行计算模式"><a href="#CUDA并行计算模式" class="headerlink" title="CUDA并行计算模式"></a>CUDA并行计算模式</h3><ul><li>并行计算是同时应用多个计算资源解决一个计算问题。</li><li>涉及多个计算资源或处理器。</li><li>问题被分解为多个离散的部分，可以同时处理(并行)，每个部分可以由一系列指令完成。</li><li>最好是计算密集的任务，通信和计算开销比例合适，不要受制于访存带宽。</li></ul><h3 id="程序并行化加速比"><a href="#程序并行化加速比" class="headerlink" title="程序并行化加速比"></a>程序并行化加速比</h3><p><strong>程序可能的加速比取决于可以被并行化的部分</strong></p><ul><li>如果没有可以并行化的， <code>P = 0</code> and the <code>speedup = 1</code> [no speedup]。</li><li>如果全部都可以并行化，<code>P = 1</code> and the speedup is infinite [in theory]。</li><li>如果50%可以并行化，<code>maximum speedup = 2</code>。</li></ul><p><strong>如果有N个处理器并行处理</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821173515481.png" alt="image-20210821173515481"></p><p>P &#x3D; 并行部分，N &#x3D; 处理器数量，s  &#x3D; 串行部分。</p><p><strong>并行化的可扩展性有极限</strong></p><p>For example, at P &#x3D; .50, .90 and .99  [50%，90% and 99% of the code isparallelizable]</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821173722760.png" alt="image-20210821173722760"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Course</category>
      
      <category>CUDA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>jetson</tag>
      
      <tag>cuda</tag>
      
      <tag>GPU</tag>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA on Arm - L4t ubuntu基础</title>
    <link href="/2021/08/cuda-on-arm-l4t-ubuntu/"/>
    <url>/2021/08/cuda-on-arm-l4t-ubuntu/</url>
    
    <content type="html"><![CDATA[<p>🎉感谢来自NVIDIA企业级开发者社区的李奕澎老师提供的资料 </p><h2 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a>应用需求</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/16/image-20210816093522065.png" alt="image-20210816093522065.png"></p><h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h2><h3 id="X86-Ubuntu与L4T-Ubuntu的区别"><a href="#X86-Ubuntu与L4T-Ubuntu的区别" class="headerlink" title="X86 Ubuntu与L4T Ubuntu的区别"></a>X86 Ubuntu与L4T Ubuntu的区别</h3><p><strong>X86 Ubuntu ：</strong>是指运行在X86架构CPU的linux ubuntu版本的操作系统。</p><p><strong>L4T Ubuntu：</strong>L4T 是linux for tegra的缩写，Tegra是集成了ARM架构的CPU和NVIDIA的GPU的处理器芯片，所以L4T Ubuntu就是为运行在基于arm架构的Tegra芯片上的linux ubuntu版本的操作系统，它是专门为Tegra定制的Ubuntu特殊版本。</p><p><strong>X86 Ubuntu与L4T Ubuntu主要区别：</strong></p><ul><li><p>应用场景：ARM处理器定位于嵌入式平台，应用在开发板、边缘设备、智能设备上；X86定位于桌面PC和服务器。</p></li><li><p>ARM是为了低功耗高效率设计的，而X86是为了追求高性能。</p></li><li><p>设计架构：ARM是精简指令集（RISC）架构；x86是复杂指令集(CISC)架构。</p></li><li><p>ARM几乎都采用Linux的操作系统；X86多为window系统也可采用linux操作系统。</p></li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821160532816.png" alt="image-20210821160532816"></p><h3 id="UBUNTU的文件管理-目录结构"><a href="#UBUNTU的文件管理-目录结构" class="headerlink" title="UBUNTU的文件管理 - 目录结构"></a>UBUNTU的文件管理 - 目录结构</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821160942100.png" alt="image-20210821160942100"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821160947338.png" alt="image-20210821160947338"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821161000414.png" alt="image-20210821161000414"></p><h3 id="UBUNTU的权限管理"><a href="#UBUNTU的权限管理" class="headerlink" title="UBUNTU的权限管理"></a>UBUNTU的权限管理</h3><p><strong>超级用户：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">//进入超级用户终端<br>su<br>//退出当前用户<br><span class="hljs-built_in">exit</span><br>//使用户在自己的环境下执行需要超级用户权限的任务<br>sudo &lt;<span class="hljs-built_in">command</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>用户组：</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821161302930.png" alt="image-20210821161302930"></p><ul><li><p>（User）文件所有者。</p></li><li><p>（Group）群组 ，我们可以在Ubuntu系统中为团    队建立一个群组。</p></li><li><p>（Others）其他人，不属于文件所有者或文件所属群组成员的用户便都是其他人。</p></li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821161321190.png" alt="image-20210821161321190"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821161356482.png" alt="image-20210821161356482"></p><h3 id="UBUNTU基本操作命令"><a href="#UBUNTU基本操作命令" class="headerlink" title="UBUNTU基本操作命令"></a>UBUNTU基本操作命令</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821161443187.png" alt="image-20210821161443187"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821161456335.png" alt="image-20210821161456335"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821161518808.png" alt="image-20210821161518808"></p><h3 id="UBUNTU网络管理"><a href="#UBUNTU网络管理" class="headerlink" title="UBUNTU网络管理"></a>UBUNTU网络管理</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821161927164.png" alt="image-20210821161927164"></p><h2 id="JupyterLab"><a href="#JupyterLab" class="headerlink" title="JupyterLab"></a>JupyterLab</h2><p><strong>JupyterLab ：</strong>数据科学生产工具，它作为一种基于web的集成开发环境，你可以使用它编写代码的notebook、操作终端、编辑markdown文本、打开交互模式、查看csv文件及图片等功能。</p><p><strong>安装方法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#pip</span><br>pip install jupyterlab<br><br><span class="hljs-comment">#conda</span><br>conda install -c conda-forge jupyterlab<br></code></pre></td></tr></table></figure><p><strong>启动方法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyterlab<br></code></pre></td></tr></table></figure><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821160840882.png" alt="image-20210821160840882"></p><h2 id="Makefile基本介绍与编写规则"><a href="#Makefile基本介绍与编写规则" class="headerlink" title="Makefile基本介绍与编写规则"></a>Makefile基本介绍与编写规则</h2><h3 id="什么是Makefile"><a href="#什么是Makefile" class="headerlink" title="什么是Makefile"></a>什么是Makefile</h3><p>当一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则，可以来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译。makefile就像一个Shell脚本一样，可以实现“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><h3 id="Makefile编写规则"><a href="#Makefile编写规则" class="headerlink" title="Makefile编写规则"></a>Makefile编写规则</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821162204257.png" alt="image-20210821162204257"></p><p><strong>多个C工程文件：</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/21/image-20210821162236572.png" alt="image-20210821162236572"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Course</category>
      
      <category>CUDA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>jetson</tag>
      
      <tag>cuda</tag>
      
      <tag>GPU</tag>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intel T265 + ROS视觉里程计搭建——Jetson平台</title>
    <link href="/2021/08/intel-t265-ros-jetson-with-cuda/"/>
    <url>/2021/08/intel-t265-ros-jetson-with-cuda/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenCV4-for-CUDA安装"><a href="#OpenCV4-for-CUDA安装" class="headerlink" title="OpenCV4 for CUDA安装"></a>OpenCV4 for CUDA安装</h2><p>OpenCV提供图像处理过程中的基础API，所以首先完成OpenCV4的构建。为了利用Jetson平台拥有CUDA加速的优势需要先安装OpenCV的CUDA版本。（Jetpack默认为非CUDA版本）</p><blockquote><p>如果是Jetson Nano平台需要先扩大Swap分区至4G以上，避免因为内存不足终止编译。</p></blockquote><p>可以使用Jtop工具扩展Swap分区。</p><h3 id="更新安装包"><a href="#更新安装包" class="headerlink" title="更新安装包"></a>更新安装包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install -y build-essential cmake git libgtk2.0-dev pkg-config  libswscale-dev libtbb2 libtbb-dev<br>sudo apt install -y python-dev python3-dev python-numpy python3-numpy<br>sudo apt install -y curl<br></code></pre></td></tr></table></figure><h3 id="安装视频和图片依赖"><a href="#安装视频和图片依赖" class="headerlink" title="安装视频和图片依赖"></a>安装视频和图片依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install -y  libjpeg-dev libpng-dev libtiff-dev<br>sudo apt install -y libavcodec-dev libavformat-dev<br>sudo apt install -y libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev<br>sudo apt install -y libv4l-dev v4l-utils qv4l2 v4l2ucp libdc1394-22-dev<br></code></pre></td></tr></table></figure><h3 id="克隆OpenCV和OpenCV-Contrib源码"><a href="#克隆OpenCV和OpenCV-Contrib源码" class="headerlink" title="克隆OpenCV和OpenCV_Contrib源码"></a>克隆OpenCV和OpenCV_Contrib源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -L https://github.com/opencv/opencv/archive/4.5.3.zip -o opencv-4.5.3.zip<br>curl -L https://github.com/opencv/opencv_contrib/archive/4.5.3.zip -o opencv_contrib-4.5.3.zip<br></code></pre></td></tr></table></figure><h3 id="解压缩包"><a href="#解压缩包" class="headerlink" title="解压缩包"></a>解压缩包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip opencv-4.5.3.zip <br>unzip opencv_contrib-4.5.3.zip <br><span class="hljs-built_in">cd</span> opencv-4.5.3/<br><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build/<br></code></pre></td></tr></table></figure><h3 id="使用Cmake编译工程"><a href="#使用Cmake编译工程" class="headerlink" title="使用Cmake编译工程"></a>使用Cmake编译工程</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cmake     -D <span class="hljs-attribute">WITH_CUDA</span>=ON \<br>        -D <span class="hljs-attribute">OPENCV_EXTRA_MODULES_PATH</span>=../../opencv_contrib-4.5.3/modules \<br>        -D <span class="hljs-attribute">WITH_GSTREAMER</span>=ON \<br>        -D <span class="hljs-attribute">WITH_LIBV4L</span>=ON \<br>        -D <span class="hljs-attribute">BUILD_opencv_python2</span>=ON \<br>        -D <span class="hljs-attribute">BUILD_opencv_python3</span>=ON \<br>        -D <span class="hljs-attribute">BUILD_TESTS</span>=OFF \<br>        -D <span class="hljs-attribute">BUILD_PERF_TESTS</span>=OFF \<br>        -D <span class="hljs-attribute">BUILD_EXAMPLES</span>=OFF \<br>        -D <span class="hljs-attribute">CMAKE_BUILD_TYPE</span>=RELEASE \<br>        -D <span class="hljs-attribute">CMAKE_INSTALL_PREFIX</span>=/usr/local <span class="hljs-built_in">..</span><br></code></pre></td></tr></table></figure><h3 id="编译和安装"><a href="#编译和安装" class="headerlink" title="编译和安装"></a>编译和安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j6 <span class="hljs-comment">#根据CPU核心来填数字</span><br>sudo make install<br></code></pre></td></tr></table></figure><h3 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/17/image-20210817224114622.png" alt="image-20210817224114622"></p><h2 id="安装ROS全家桶"><a href="#安装ROS全家桶" class="headerlink" title="安装ROS全家桶"></a>安装ROS全家桶</h2><h3 id="添加软件源"><a href="#添加软件源" class="headerlink" title="添加软件源"></a>添加软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sh -c <span class="hljs-string">&#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="添加密钥"><a href="#添加密钥" class="headerlink" title="添加密钥"></a>添加密钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -<br></code></pre></td></tr></table></figure><h3 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br></code></pre></td></tr></table></figure><h3 id="安装ROS"><a href="#安装ROS" class="headerlink" title="安装ROS"></a>安装ROS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install ros-melodic-desktop-full<br></code></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;source /opt/ros/melodic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><h3 id="安装额外依赖"><a href="#安装额外依赖" class="headerlink" title="安装额外依赖"></a>安装额外依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential<br></code></pre></td></tr></table></figure><h3 id="安装rosdep"><a href="#安装rosdep" class="headerlink" title="安装rosdep"></a>安装rosdep</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install python-rosdep<br></code></pre></td></tr></table></figure><h3 id="初始化rosdep"><a href="#初始化rosdep" class="headerlink" title="初始化rosdep"></a>初始化rosdep</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo rosdep init<br>rosdep update<br></code></pre></td></tr></table></figure><p>注：确保已接入外网环境</p><h2 id="安装Intel®-RealSense™-SDK"><a href="#安装Intel®-RealSense™-SDK" class="headerlink" title="安装Intel® RealSense™ SDK"></a>安装Intel® RealSense™ SDK</h2><p>感谢Jetsonhacks提供的安装脚本：<a href="https://github.com/jetsonhacks/installRealSenseSDK.git">https://github.com/jetsonhacks/installRealSenseSDK.git</a></p><p>请先克隆仓库，然后进行修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/jetsonhacks/installRealSenseSDK.git<br></code></pre></td></tr></table></figure><p>根据具体情况将版本做了一些修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Builds the Intel Realsense library librealsense on a Jetson NX</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Copyright (c) 2016-21 Jetsonhacks &amp; Jason_xy</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Jetson NX; L4T 32.4.3[Jetpack 4.4]</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2021-8-17</span><br>LIBREALSENSE_DIRECTORY=$&#123;HOME&#125;/librealsense<br>LIBREALSENSE_VERSION=v2.48.0<br>INSTALL_DIR=$PWD<br>NVCC_PATH=/usr/local/cuda-10.2/bin/nvcc<br></code></pre></td></tr></table></figure><h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./buildLibrealsense.sh <br></code></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/18/image-20210818092344805.png" alt="image-20210818092344805"></p><h2 id="安装realsense-ros"><a href="#安装realsense-ros" class="headerlink" title="安装realsense-ros"></a>安装realsense-ros</h2><h3 id="创建工作区"><a href="#创建工作区" class="headerlink" title="创建工作区"></a>创建工作区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/catkin_ws/src<br><span class="hljs-built_in">cd</span> ~/catkin_ws/src/<br></code></pre></td></tr></table></figure><h3 id="克隆源码仓库"><a href="#克隆源码仓库" class="headerlink" title="克隆源码仓库"></a>克隆源码仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/IntelRealSense/realsense-ros.git<br><span class="hljs-built_in">cd</span> realsense-ros/<br>git checkout `git tag | <span class="hljs-built_in">sort</span> -V | grep -P <span class="hljs-string">&quot;^2.\d+\.\d+&quot;</span> | <span class="hljs-built_in">tail</span> -1`<br><span class="hljs-built_in">cd</span> ..<br></code></pre></td></tr></table></figure><h3 id="构建模块"><a href="#构建模块" class="headerlink" title="构建模块"></a>构建模块</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">catkin_init_workspace<br><span class="hljs-function"><span class="hljs-title">cd</span></span> ..<br>catkin_make clean<br></code></pre></td></tr></table></figure><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a><strong>解决问题</strong></h4><h5 id="cv-bridge"><a href="#cv-bridge" class="headerlink" title="cv_bridge"></a><strong>cv_bridge</strong></h5><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/18/image-20210818002132664.png" alt="image-20210818002132664"></p><p>修改cv_bridge配置文件，将API对接到安装的OpenCV4 with CUDA</p><p>修改文件<code>/opt/ros/melodic/share/cv_bridge/cmake/cv_bridgeConfig.cmake</code></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/18/image-20210818002116799.png" alt="image-20210818002116799"></p><h5 id="ddynamic-reconfigure"><a href="#ddynamic-reconfigure" class="headerlink" title="ddynamic_reconfigure"></a>ddynamic_reconfigure</h5><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/18/image-20210818002145740.png" alt="image-20210818002145740"></p><p>安装ddynamic_reconfigure：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install ros-melodic-ddynamic-reconfigure<br></code></pre></td></tr></table></figure><h4 id="继续构建"><a href="#继续构建" class="headerlink" title="继续构建"></a>继续构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_make -DCATKIN_ENABLE_TESTING=False -DCMAKE_BUILD_TYPE=Release<br>catkin_make install<br></code></pre></td></tr></table></figure><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;source ~/catkin_ws/devel/setup.bash&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><h3 id="成功运行"><a href="#成功运行" class="headerlink" title="成功运行"></a>成功运行</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/18/image-20210818005040499.png" alt="image-20210818005040499"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/18/image-20210818010317263.png" alt="image-20210818010317263"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/08/18/image-20210818092410635.png" alt="image-20210818092410635"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Robotics</category>
      
      <category>ENV</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jetson</tag>
      
      <tag>cuda</tag>
      
      <tag>realsense</tag>
      
      <tag>t265</tag>
      
      <tag>ros</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统重点</title>
    <link href="/2021/06/osreview/"/>
    <url>/2021/06/osreview/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622100939188.png"></h1><p>博客原文：<a href="https://jason-xy.cn/2021/06/osreview/">计算机操作系统重点 – 全栈之路 (jason-xy.cn)</a></p><p>知乎原文：<a href="https://zhuanlan.zhihu.com/p/383665574">计算机操作系统复习整理 - 知乎 (zhihu.com)</a></p><h1 id="第一章-绪论（考概念）"><a href="#第一章-绪论（考概念）" class="headerlink" title="第一章 绪论（考概念）"></a>第一章 绪论（考概念）</h1><h2 id="什么是OS？"><a href="#什么是OS？" class="headerlink" title="什么是OS？"></a>什么是OS？</h2><ul><li>操作系统是一组<strong>控制和管理</strong>计算机软硬件资源、合理地对各类作业进行<strong>调度</strong>以及<strong>方便用户</strong>使用的程序集合。</li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622101202648.png"></p><ul><li>操作系统是位于硬件层(HAL)之上，所有其它系统软件层之下的一个系统软件，使得管理系统中的各种软件和硬件资源得以充分利用，方便用户使用计算机系统。</li><li><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622101647407.png"></li></ul><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><p><strong>方便性：</strong></p><ul><li>计算机只能识别0、1</li><li>用户熟悉的是各种语言</li><li>命令和图形界面</li></ul><p><strong>有效性：</strong></p><ul><li>长期是最重要的目标</li><li>提高系统资源利用率</li><li>提高系统吞吐量</li></ul><p><strong>可扩充性：</strong></p><ul><li>便于修改和增加功能（如何设计？）</li></ul><p><strong>开放性：</strong></p><ul><li>系统能支持世界标准规范</li></ul><h2 id="批处理、分时、实时系统比较"><a href="#批处理、分时、实时系统比较" class="headerlink" title="批处理、分时、实时系统比较"></a>批处理、分时、实时系统比较</h2><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622102054880.png" alt="image-20210622102054880"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622102135105.png" alt="image-20210622102135105"></p><ul><li><strong>名称由来</strong>：内存中始终仅存一道作业运行；</li><li><strong>主要特征</strong>：自动性、顺序性、单道性；</li><li><strong>主要优点</strong>：减少人工操作，解决了作业的自动接续；</li><li><strong>主要缺点</strong>：平均周转时间长，没有交互能力。</li></ul><h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622102254904.png" alt="image-20210622102254904"></p><ul><li><strong>定义</strong>：在内存中存放多道作业运行，运行结束或出错，自动调度内存中的另一道作业运行；</li><li><strong>好处</strong>：<ul><li>提高CPU的利用率；</li><li>提高内存和I&#x2F;O设备利用率；</li><li>增加系统吞吐率；</li></ul></li><li><strong>特征</strong>：多道性、无序性、调度性；</li><li><strong>主要优点</strong>：提高了资源利用率和吞吐能力；</li><li><strong>主要缺点</strong>：平均周转时间长，没有交互能力。</li></ul><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622102446740.png" alt="image-20210622102446740"></p><ul><li><strong>产生</strong>：人机交互、共享主机、便于用户上机</li><li><strong>关键问题</strong>：及时接收、及时处理</li><li><strong>特点</strong>：多路性、独立性、及时性、交互性</li></ul><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><ul><li><strong>定义</strong>：是计算机及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致的运行。</li><li><strong>举例</strong>：工业控制、军事控制、医疗控制、航班订票、联机情报检索</li><li><strong>分类</strong>：周期性非周期性、软硬实时任务</li><li><strong>特征</strong>：多路性、独立性、交互性、可靠性、及时性</li></ul><h2 id="OS-的作用"><a href="#OS-的作用" class="headerlink" title="OS 的作用"></a>OS 的作用</h2><ul><li>作为用户与计算机硬件系统之间的接口</li><li>作为计算机系统资源的管理者</li><li>用作扩充机器</li></ul><h2 id="OS-的四个基本特性⭐"><a href="#OS-的四个基本特性⭐" class="headerlink" title="OS 的四个基本特性⭐"></a>OS 的四个基本特性⭐</h2><ul><li><p>并发性（最重要的特性）</p><p><strong>并行</strong>是指两或多个事件在同一时刻发生<br><strong>并发</strong>是两或多个事件在同一时间间隔内发生</p></li><li><p>共享性   </p><p>系统中资源可供内存中多个并发执行的进程共同使用<br><strong>互斥共享：</strong>一段时间只允许一个进程访问该资源<br><strong>同时访问：</strong>微观上仍是互斥的<br> 并发和共享是操作系统的两个最基本的特征，它们又是互为存在的条件</p></li><li><p>虚拟性</p><p><strong>时分复用：</strong>虚拟处理机技术， 虚拟设备技术<br><strong>空分复用：</strong>虚拟存储<br>通过某种技术把一个物理实体变为若干个逻辑上的对应物。若n是某一物理设备所对应的虚拟的逻辑设备数，则虚拟设备的速度必然是物理设备速度的1&#x2F;n。</p></li><li><p>异步性</p><p>停停走走<br>运行进度不可预知</p></li></ul><h2 id="OS-的五大功能⭐"><a href="#OS-的五大功能⭐" class="headerlink" title="OS 的五大功能⭐"></a>OS 的五大功能⭐</h2><ul><li>处理机管理（CPU）</li><li>存储器管理</li><li>设备管理</li><li>文件管理</li><li>方便用户使用的用户接口。</li></ul><h2 id="OS-的基本类型（了解即可）"><a href="#OS-的基本类型（了解即可）" class="headerlink" title="OS 的基本类型（了解即可）"></a>OS 的基本类型（了解即可）</h2><ul><li>批处理系统</li><li>分时系统</li><li>实时系统</li></ul><h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><h2 id="进程和线程的概念、比较"><a href="#进程和线程的概念、比较" class="headerlink" title="进程和线程的概念、比较"></a>进程和线程的概念、比较</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>进程是程序的<strong>一次执行</strong></li><li>进程是一个<strong>程序及其数据</strong>在处理机上顺序执行时所<strong>发生的活动</strong></li><li>进程是程序在一个数据集合上运行的过程，它是<strong>系统进行资源分配和调度的一个独立单位</strong></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>轻型进程</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li><p>调度的基本单位</p><p>在引入线程的OS 中，已把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位。当线程切换时，仅需保存和设置少量寄存器内容，切换代价远低于进程。</p></li><li><p>并发性</p><p>在引入线程的OS 中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，甚至还允许在一个进程中的所有线程都能并发执行。同样，不同进程中的线程也能并发执行。</p></li><li><p>拥有资源</p><p>线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源。</p><p>属于同一进程的所有线程都具有相同的地址空间。</p></li><li><p>独立性</p><p>在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。</p></li><li><p>系统开销</p><p>在一些OS 中，线程的切换、同步和通信都无需操作系统内核的干预。</p></li><li><p>支持多处理机系统</p><p>对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行，这无疑将加速进程的完成。</p></li></ul><h2 id="进程的基本状态及状态转换的原因"><a href="#进程的基本状态及状态转换的原因" class="headerlink" title="进程的基本状态及状态转换的原因"></a>进程的基本状态及状态转换的原因</h2><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><h4 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h4><blockquote><p>当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。（万事俱备，只欠CPU）</p></blockquote><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624175251447.png" alt="image-20210624175251447"></p><h4 id="执行状态"><a href="#执行状态" class="headerlink" title="执行状态"></a>执行状态</h4><blockquote><p>进程已获得CPU，其程序正在执行。（获得CPU）</p></blockquote><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624175300019.png" alt="image-20210624175300019"></p><h4 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h4><blockquote><p>正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，把这种暂停状态称为阻塞状态，有时也称为等待状态。（无法继续执行，放弃处理机处于暂停状态）</p></blockquote><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624175309335.png" alt="image-20210624175309335"></p><h3 id="状态转换原因"><a href="#状态转换原因" class="headerlink" title="状态转换原因"></a>状态转换原因</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624175319650.png" alt="image-20210624175319650"></p><table><thead><tr><th><strong>起始状态</strong></th><th><strong>终止状态</strong></th><th><strong>转换原因</strong></th></tr></thead><tbody><tr><td>空</td><td>New</td><td><strong>新创建</strong>的进程首先处于新状态</td></tr><tr><td>New</td><td>Ready</td><td>当<strong>系统允许增加就绪进程</strong>时，操作系统接纳新建状态进程，将它变为就绪状态，<strong>插入就绪队列</strong>中</td></tr><tr><td>Ready</td><td>Running</td><td>当<strong>处理机空闲</strong>时，将<strong>从就绪队列中选择一个进程执行</strong>，该选择过程称为进程调度，或将处理机分派给一个进程，该进程状态从就绪转变为执行</td></tr><tr><td>Running</td><td>Exit</td><td>执行状态的进程<strong>执行完毕，或出现诸如访问地址越界、非法指令等错误</strong>，而被异常结束，则进程从执行状态转换为终止状态</td></tr><tr><td>Running</td><td>Ready</td><td>分时系统中，<strong>时间片用完，或优先级高的进程到来</strong>，将中断较低优先级进程的执行。进程从执行状态转变为就绪状态，等待下一次调度</td></tr><tr><td>Running</td><td>Blocked</td><td>执行进程<strong>需要等待某事件发生</strong>。通常，会因为进程需要的系统调用不能立即完成，如读文件、共享虚拟内存、等待I&#x2F;O操作、等待另一进程与之通信等事件而阻塞</td></tr><tr><td>Blocked</td><td>Ready</td><td>当<strong>阻塞进程等待的事件发生</strong>，就转换为就绪状态。进入就绪队列排队，等待被调度执行</td></tr></tbody></table><h2 id="PCB-的作用"><a href="#PCB-的作用" class="headerlink" title="PCB 的作用"></a>PCB 的作用</h2><ul><li>是进程存在的唯一标志</li><li>PCB (Process Control Block) 常驻内存</li></ul><h2 id="PCB-内的信息"><a href="#PCB-内的信息" class="headerlink" title="PCB 内的信息"></a>PCB 内的信息</h2><ul><li>进程标识符</li><li>处理机状态</li><li>进程调度信息</li><li>进程控制信息</li></ul><h2 id="进程控制的原语操作"><a href="#进程控制的原语操作" class="headerlink" title="进程控制的原语操作"></a>进程控制的原语操作</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622115301881.png" alt="image-20210622115301881"></p><h3 id="Create"><a href="#Create" class="headerlink" title="Create()"></a><code>Create()</code></h3><ol><li>申请空白 PCB</li><li>为新进程分配资源</li><li>初始化进程控制块<ol><li>初始化标识信息</li><li>初始化处理机状态信息</li><li>初始化处理机控制信息</li></ol></li><li>将新进程插入就绪队列</li></ol><h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><ol><li>根据进程ID，检索进程PCB，读取进程信息</li><li>若被终止进程处于执行状态，则立即终止进程，并置调度指示符为真，用于指示该进程被终止后重新进行调度</li><li>终止子孙进程</li><li>归还资源</li><li>移出已终止进程</li></ol><h3 id="block"><a href="#block" class="headerlink" title="block()"></a><code>block()</code></h3><ol><li>进程通过调用阻塞原语 <code>block()</code> 阻塞自己</li><li>更改进程状态，并插入阻塞队列</li><li>处理机重新调度，分配给另一就绪进程</li></ol><h3 id="wakeup"><a href="#wakeup" class="headerlink" title="wakeup()"></a><code>wakeup()</code></h3><ol><li>将进程移出阻塞队列，并更改PCB中现行状态</li><li>将PCB插入就绪队列</li></ol><h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend()"></a><code>suspend()</code></h3><ol><li>首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪</li><li>对于活动阻塞状态的进程，则将之改为静止阻塞状态</li></ol><h3 id="active"><a href="#active" class="headerlink" title="active()"></a><code>active()</code></h3><ol><li>将进程从外存调入内存，检查该进程的现行状态</li><li>若是静止就绪，便将之改为活动就绪；若为静止阻塞，便将之改为活动阻塞</li></ol><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><ol><li>保存进程上下文环境</li><li>更新当前运行进程的控制块内容，将其状态改为就绪或阻塞状态</li><li>将进程控制块移到相应队列</li><li>改变需投入运行进程的控制块内容，将其状态变为运行状态</li><li>恢复需投入运行进程的上下文环境</li></ol><h2 id="进程互斥、临界区、进程同步的基本概念、同步准则"><a href="#进程互斥、临界区、进程同步的基本概念、同步准则" class="headerlink" title="进程互斥、临界区、进程同步的基本概念、同步准则"></a>进程互斥、临界区、进程同步的基本概念、同步准则</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><p>任何时刻，只允许一个进程进入临界区，以此实现进程对临界资源的互斥访问。</p><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>访问临界资源的那段代码称为临界区。</p><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>使并发执行的主进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。</p><h3 id="同步准则"><a href="#同步准则" class="headerlink" title="同步准则"></a>同步准则</h3><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>信号量（Semaphores）机制:是一种卓有成效的进程同步工具</p><ul><li>整型信号量</li><li>记录型信号量</li><li>​    AND 型信号量</li><li>信号量集</li></ul><h2 id="信号量应用实现"><a href="#信号量应用实现" class="headerlink" title="信号量应用实现"></a>信号量应用实现</h2><ul><li>利用信号量实现进程互斥</li><li>利用信号量实现前趋关系</li></ul><h2 id="经典进程同步问题⭐"><a href="#经典进程同步问题⭐" class="headerlink" title="经典进程同步问题⭐"></a>经典进程同步问题⭐</h2><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622120531224.png" alt="image-20210622120531224"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622123326740.png" alt="image-20210622123326740"></p><ul><li>互斥信号量mutex：实现诸进程对缓冲池的互斥使用</li><li>资源信号量empty：表示缓冲池中空缓冲区的数量</li><li>资源信号量full：表示满缓冲区的数量</li><li>只要缓冲池未满，生产者便可将消息送入缓冲池</li><li>只要缓冲池未空，消费者便可从缓冲池中取走一个消息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> in=<span class="hljs-number">0</span>,  out=<span class="hljs-number">0</span>;<br>item buffer[n];<br>semapthore mutex=<span class="hljs-number">1</span>, empty=n, full=<span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">proceducer</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">do</span>&#123;<br>            producer an item nextp;<br>            …….<br>            wait(empty);<br>            wait(mutex);<br>            buffer[in]=nextp;<br>            in=(in+<span class="hljs-number">1</span>) %n;<br>            signal(mutex);<br>            signal(full);<br>       &#125; <span class="hljs-keyword">while</span>(TRUE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">do</span>&#123;<br>            wait(full);<br>            wait(mutex);<br>            nextc=buffer[out];<br>            out=(out+<span class="hljs-number">1</span>) %n;<br>            signal(mutex);<br>            signal(empty);<br>            consumer the item in nextc;<br>            ………<br>       &#125; <span class="hljs-keyword">while</span>(TRUE);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622124136627.png" alt="image-20210622124136627"></p><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622155103227.png" alt="image-20210622155103227"></p><p>特殊情况：死锁 。<br>解决办法：<br>至多只允许四位哲学家同时去哪左边的筷子。<br>仅当哲学家的左、右两只筷子同时可以时才允许他拿起筷子。<br>规定奇数号哲学家先拿他左边的筷子，然后再拿右边的；而偶数号哲学家则相反。</p><ul><li>记录型信号量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore  chopstick［<span class="hljs-number">5</span>］ =[<span class="hljs-number">1</span>，<span class="hljs-number">1</span>，<span class="hljs-number">1</span>，<span class="hljs-number">1</span>，<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">do</span>&#123;<br>    wait(chopstick[i]);<br>    wait(chopstick[(i+<span class="hljs-number">1</span>) %<span class="hljs-number">5</span>]);<br>    …<br>   <span class="hljs-comment">//eat</span><br>    …<br>   signal(chopstick[i]);<br>   signal(chopstick[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>    …<br>   <span class="hljs-comment">//think;</span><br>    …<br>&#125; <span class="hljs-keyword">while</span> (TRUE)<br><br></code></pre></td></tr></table></figure><ul><li>AND 型信号量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Var chopstick: <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>, …, <span class="hljs-number">4</span>] of semaphore:=(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>processi<br>Repeat<br>   think;<br>   Sswait(chopstick[(i+<span class="hljs-number">1</span>)mod <span class="hljs-number">5</span>],chopstick[i]);<br>   eat<br>   <span class="hljs-title function_">Ssignal</span><span class="hljs-params">(chopstick[(i+<span class="hljs-number">1</span>)mod <span class="hljs-number">5</span>],chopstick[i])</span>;<br>Until <span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><ul><li>信号量集</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> RN;<br>semaphore L=RN, mx=<span class="hljs-number">1</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Reader</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">do</span>&#123;<br>           Swait(L, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>           Swait(mx, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>           …….<br>           perform read operation;<br>            ……<br>            Ssignal(L, <span class="hljs-number">1</span>)<br>     &#125;<span class="hljs-keyword">while</span> (TRUE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Writer</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">do</span>&#123;<br>           Swait(mx, <span class="hljs-number">1</span>,<span class="hljs-number">1</span>; L, RN, <span class="hljs-number">0</span>);<br><br>           perform write operation;<br><br>           Ssignal(mx, <span class="hljs-number">1</span>);<br>      &#125; <span class="hljs-keyword">while</span>(TRUE);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="进程间通信的原理和实现方法"><a href="#进程间通信的原理和实现方法" class="headerlink" title="进程间通信的原理和实现方法"></a>进程间通信的原理和实现方法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>进程之间的信息交换</p><ul><li>共享存储器系统</li><li>消息传递系统</li><li>管道（Pipe）通信</li></ul><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>直接通信方式<ul><li><code>Send(Receiver，message);</code></li><li><code>Receive(Sender，message);</code></li></ul></li><li>间接通信方式<ul><li><code>Send(mailbox, message);</code></li><li><code>Receive(mailbox, message);</code></li></ul></li></ul><h1 id="第三章-处理机调度"><a href="#第三章-处理机调度" class="headerlink" title="第三章 处理机调度"></a>第三章 处理机调度</h1><h2 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><table><thead><tr><th></th><th><strong>高级</strong></th><th><strong>中级</strong></th><th><strong>低级</strong></th></tr></thead><tbody><tr><td><strong>调度对象</strong></td><td>作业</td><td>挂起的进程</td><td>就绪进程</td></tr><tr><td><strong>功能</strong></td><td>将外存作业调入内存，创建PCB等，插入就绪队列</td><td>把外存上那些已经具备运行条件的就绪进程重新载入内存。从静止就绪到活动就绪</td><td>决定就绪队列中的那个进程应获得处理机，并将处理机分配给选中的进程</td></tr><tr><td><strong>实现</strong></td><td>作业管理程序</td><td>内存管理中的对换进程</td><td>分派程序（dispatcher)</td></tr><tr><td><strong>频度</strong></td><td>最低，分钟级</td><td>中级</td><td>最频繁，毫秒级</td></tr></tbody></table><h2 id="调度算法的准则"><a href="#调度算法的准则" class="headerlink" title="调度算法的准则"></a>调度算法的准则</h2><p>不同的设计需求决定了不同的目标：</p><p>共同目标：</p><ul><li>资源利用率</li><li>公平性</li><li>平衡性</li><li>策略强制执行</li></ul><h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><ul><li>作业在外存的等待时间</li><li>进程在就绪队列的等待时间</li><li>进程占用CPU的时间</li><li>进程阻塞时间</li></ul><h3 id="带权周转时间"><a href="#带权周转时间" class="headerlink" title="带权周转时间"></a>带权周转时间</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622163718118.png" alt="image-20210622163718118"></p><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><h2 id="调度算法⭐"><a href="#调度算法⭐" class="headerlink" title="调度算法⭐"></a>调度算法⭐</h2><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p><strong>周转时间</strong></p><ul><li>作业在外存的等待时间</li><li>进程在就绪队列的等待时间</li><li>进程占用CPU的时间</li><li>进程阻塞时间</li></ul><p><strong>缺陷：</strong>对待短作业（进程）不公平，如果他们排在队列后面，则其等待时间远大于其执行时间。</p><h3 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h3><p>原理：</p><ul><li>FCFS策略+时钟中断+时间片原则</li></ul><p>进程切换时机：</p><ul><li>时间片内进程结束，进程结束事件激活进程调度，新进程可运行一个时间片。</li><li>时间片用完，时钟中断激活调度，旧进程到就绪队列尾，队头进程投入运行一个时间片。</li></ul><p>时间片大小的确定：</p><ul><li><p>太小：利于短作业，但增大调度和上下文切换频率，增大系统开销。</p></li><li><p>太长：退化为FCFS算法。</p></li><li><p>合适：略大于一次典型的交互所需的时间，使大多数交互式进程能在一个时间片内完成。 </p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622164449450.png" alt="image-20210622164449450"></p></li></ul><h3 id="基于优先权"><a href="#基于优先权" class="headerlink" title="基于优先权"></a>基于优先权</h3><p>赋予作业动态优先级，优先级随作业等待时间延长而增加，从而使长作业的优先级在等待期间不断增加。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622164143377.png" alt="image-20210622164143377"></p><h3 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h3><p>等待时间+要求服务时间&#x3D;响应时间<br>故优先级相当于响应比Rp。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622164232790.png" alt="image-20210622164232790"></p><ul><li>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。 </li><li>当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。 </li><li>对于长作业，作业的优先级可以随等待时间的增加而提高， 从而也可获得处理机。 </li><li>简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。</li></ul><h3 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h3><p>长短不同作业的矛盾。</p><p>调度机制</p><ul><li>设置多个就绪队列，并为各个队列赋予不同的优先级。</li><li>优先级愈高的队列的进程的执行时间片就愈小。</li><li>新进程首先进入最高优先级的队列。每个队列采用FCFS算法。队列中的进程运行一个时间片后未结束则降级排到下一个队列的末尾。最低优先权队列中的进程则按RR方式运行。</li><li>按队列优先级调度。只有比队列的优先级高的队列均空时，才运行该队列中的进程。</li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622164555339.png" alt="image-20210622164555339"></p><p>特点：长、短作业兼顾，有较好的响应时间</p><p>（1）短作业一次完成，响应时间性能好；</p><p>（2）中型作业周转时间不长；</p><p>（3）大型作业不会长期不处理。</p><h3 id="实时调度（了解）"><a href="#实时调度（了解）" class="headerlink" title="实时调度（了解）"></a>实时调度（了解）</h3><p>实时调度算法分类</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/22/image-20210622164657687.png" alt="image-20210622164657687"></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概念及原因"><a href="#概念及原因" class="headerlink" title="概念及原因"></a>概念及原因</h3><p><strong>死锁（Deadlock）</strong>，是指多个进程在运行过程中因争夺资源而造成的一种僵局（Deadly- Embrace），当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p><p><strong>产生死锁的原因可归结为如下两点：</strong></p><p> （1）竞争资源。</p><p> （2）进程间推进顺序非法。</p><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><p>（1）<strong>互斥条件：</strong>指进程对所分配到的资源进行排它性使用 。</p><p>（2）<strong>请求和保持条件：</strong>指进程已经保持了至少一个资源，但又提出了新的资源请求 。 </p><p>（3）<strong>不剥夺条件：</strong>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 </p><p>（4）<strong>环路等待条件：</strong>指在发生死锁时，必然存在一个进程——资源的环形链  。</p><h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><p>是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。至于<strong>必要条件1</strong>，因为它是由设备的固有属性所决定的，不仅不能改变，还应加以保证。</p><h4 id="破坏“请求和保持”条件"><a href="#破坏“请求和保持”条件" class="headerlink" title="破坏“请求和保持”条件"></a>破坏“请求和保持”条件</h4><p>系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。</p><p>从而进程在整个运行期间，便不会再提出资源要求，从而摒弃了请求和保持条件，由此可以避免发生死锁。</p><p><strong>优点：</strong>简单、易于实现且很安全。<br><strong>缺点：</strong>资源被严重浪费，使进程延迟运行。 </p><h4 id="摒弃“不剥夺”条件"><a href="#摒弃“不剥夺”条件" class="headerlink" title="摒弃“不剥夺”条件"></a>摒弃“不剥夺”条件</h4><p>当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源。待以后需要时再重新申请。从而摒弃了“不剥夺”条件。</p><p><strong>缺点：</strong>实现起来比较复杂且要付出很大代价。</p><ul><li>一个资源在使用一段时间后，它的被迫释放可能会造成前段工作的失效。</li><li>会使进程前后两次运行的信息不连续。 </li><li>因反复地申请和释放资源，致使进程执行被无限推迟，延长进程周转时间、增加系统开销、降低吞吐量 。</li></ul><h4 id="摒弃“环路等待”条件"><a href="#摒弃“环路等待”条件" class="headerlink" title="摒弃“环路等待”条件"></a>摒弃“环路等待”条件</h4><p>这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。 </p><p><strong>存在严重问题</strong></p><p>第一，为系统中各类资源分配的序号必须相对稳定，这就限制了新设备类型的增加；</p><p>第二，会经常发生作业使用的顺序与系统规定顺序不同的情况，造成资源浪费；</p><p>第三，增加了程序设计难度。</p><h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><p>是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。 </p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。</p><h3 id="解除"><a href="#解除" class="headerlink" title="解除"></a>解除</h3><p>当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤消或挂起一些进程。</p><h3 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h3><p>安全状态</p><ul><li>所谓安全状态，是指系统能按某种进程顺序，如&lt;P1，P2，…，Pn&gt;，依次为n个进程分配其所需资源，直至其最大需求，使每个进程都可顺利地完成，称系统处于安全状态。</li><li>称〈P1，P2，…，Pn〉序列为安全序列。否则，如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</li></ul><h2 id="银行家问题⭐"><a href="#银行家问题⭐" class="headerlink" title="银行家问题⭐"></a>银行家问题⭐</h2><h3 id="银行家算法中的数据结构"><a href="#银行家算法中的数据结构" class="headerlink" title="银行家算法中的数据结构"></a>银行家算法中的数据结构</h3><ul><li><strong>可利用资源向量Available。</strong>这是一个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。其数值随该类资源的分配和回收而动态地改变。 Available[j]&#x3D;k,表示系统中现有Rj类资源k个。</li><li><strong>最大需求矩阵Max。</strong>这是一个n × m的矩阵，它定义了n个进程中每一个进程对m类资源的最大需求。Max[i,j]&#x3D;K，表示进程i需要Rj类资源的最大数目为K。   </li><li><strong>分配矩阵Allocation。</strong>这是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。Allocation［i,j]&#x3D;K，表示进程i当前已分得Rj类资源的数目为K。</li><li><strong>需求矩阵Need。</strong>这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。Need[i,j]&#x3D;K，表示进程Pi还需要Rj类资源K个，方能完成其任务。</li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623094536182.png" alt="image-20210623094536182"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623094712811.png" alt="image-20210623094712811"></p><h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h1><h2 id="存储器结构层次"><a href="#存储器结构层次" class="headerlink" title="存储器结构层次"></a>存储器结构层次</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623100830334.png" alt="image-20210623100830334"></p><ul><li>寄存器、高速缓存、主存储器和磁盘缓存均属于操作系统存储管理的管辖范畴，掉电后它们存储的信息不再存在。</li><li>磁盘和可移动存储介质属于设备管理和文件系统的管辖范畴，它们存储的信息将被长期保存。</li></ul><h2 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h2><p><strong>绝对装入方式(Absolute Loading Mode) ：</strong>编译时，已知程序在内存的具体位置，则编译程序可产生实际存储地址（绝对地址）的目标代码。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623101231280.png" alt="image-20210623101231280"></p><p><strong>可重定位装入方式(Relocation Loading Mode)</strong> </p><p>重定位（地址映射）：</p><ul><li>经编译得到的目标模块中为相对地址（通常从0开始，也称逻辑地址），即地址都是相对于0开始的。</li><li>装入模块中的逻辑地址与实际装入内存的物理地址不同。</li><li>装入内存时，相对地址（数据和指令的地址）要作出相应的修改以得到正确的物理地址，这个修改的过程称为重定位。</li></ul><p>静态重定位：</p><ul><li>地址变换是在装入内存时一次完成的，且以后不能移动。</li><li>一般情况下,物理地址&#x3D;相对地址+内存中的起始地址。</li><li>适用于多道程序环境，可以将装入模块装入到内存中任何允许的位置。</li><li>优点：不需硬件支持，可以装入有限多道程序。</li><li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动，不易实现共享。</li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623101752155.png" alt="image-20210623101752155"></p><p>动态运行时装入方式(Denamle Run-time Loading) </p><ul><li>装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时进行。在硬件地址变换机构的支持下，随着对每条指令或数据的访问自动进行地址变换，故称为动态重定位。</li><li>最简单的办法是利用一个重定位寄存器(RR)。该寄存器的值是由进程调度程序根据作业分配到的存储空间起始地址来设定的。</li><li>在具有这种地址变换机构的计算机系统中，当执行作业时，不是根据CPU给出的有效地址去访问主存，而是将有效地址与重定位寄存器中的内容相加后得到的地址作为访问主存的地址。</li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623101840707.png" alt="image-20210623101840707"></p><p>访问地址时才确定物理地址，因此采用动态重定位技术后，可在运行中动态分配或者释放存储空间。</p><p>主要优点：</p><ul><li>主存的使用更加灵活有效。非连续分配和部分装入。</li><li>几个作业共享一程序段的单个副本比较容易。</li><li>有可能向用户提供一个比主存的存储空间大得多的地址空间。因而无需用户来考虑覆盖结构，而由系统来负责全部的存储管理。</li></ul><p>主要缺点：</p><ul><li>需要附加硬件支持。</li><li>实现存储器管理的软件比较复杂。</li></ul><h2 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h2><p><strong>静态链接： (Static Linking)</strong> </p><p>在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开。 </p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623102452321.png" alt="image-20210623102452321"></p><p>存在问题：</p><ul><li>不便于对目标模块的修改和更新（若要更新其中一个模块，需要打开装入模块）。</li><li>无法实现对目标模块的共享。</li></ul><p><strong>装入时动态链接</strong></p><p>用户源程序是主目标模块，装入内存时再链接需要的其他模块。即在装入目标模块时，若发现一个外部模块调用，则由装入程序找出相应的外部目标模块，并将其装入内存。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623102613247.png" alt="image-20210623102613247"></p><p>优点：</p><ul><li>便于软件版本的修改和更新。只需修改各个目标模块，不必将装入模块拆开，非常方便。</li><li>便于实现目标模块共享。即可以将一个目标模块链接到几个应用模块中，从而实现多个应用程序对该模块的共享。</li></ul><p>缺点：</p><ul><li>进程（程序）在整个执行期间，装入模块是不改变的。</li><li>每次运行时的装入所有涉及的模块，但许多模块并不是每次运行都需要的，占用内存。</li></ul><p><strong>运行时动态链接</strong></p><p>采用运行时动态链接可将某些目标模块的链接推迟到执行时才进行，即在执行过程中，若发现一个被调用模块尚未装入内存时，由操作系统去找到该模块，将它装入内存，并链接到调用模块上。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623102926460.png" alt="image-20210623102926460"></p><p>优点：</p><ul><li>凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</li><li>运行时动态链接是目前最常使用的链接方式。</li></ul><h2 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h2><p>连续分配方式，是指为一个用户程序分配一个连续的内存空间。 </p><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><ul><li>系统区</li><li>用户区</li><li>存贮保护<ul><li>一般不设置保护也可，因单任务。</li></ul></li></ul><h3 id="分区式分配"><a href="#分区式分配" class="headerlink" title="分区式分配"></a>分区式分配</h3><h4 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h4><p>特点：有n个分区，则可同时装入n个作业&#x2F;任务。</p><p>一、分区大小：</p><p>​相等:</p><p>​不相等：不相等利用率更高。</p><p>二、内存分配：</p><p>数据结构  </p><p>​将分区按大小排序，并将其地址、分配标识作记录</p><p>例：dos的MCB</p><p>三、特点：</p><p>简单，有碎片（内零头）</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623103326854.png" alt="image-20210623103326854"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623103822037.png" alt="image-20210623103822037"></p><h4 id="可变式分区（比固定式分区有改善）"><a href="#可变式分区（比固定式分区有改善）" class="headerlink" title="可变式分区（比固定式分区有改善）"></a>可变式分区（比固定式分区有改善）</h4><p><strong>一、数据结构</strong></p><p>​1．空闲分区表</p><p>​2．空闲分区链</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623103926053.png" alt="image-20210623103926053"></p><p><strong>二、顺序分配算法</strong></p><p>要求：空闲分区按照地址或者大小组织为链表。</p><p><strong>1．首次适应算法FF。</strong></p><p>方法：每次链首开始，直到找到满足大小的空闲分区，分割该分区。</p><p>特点：有外零头，低址内存使用频繁，查找慢。高地址区保留大分区。 </p><p><strong>2．循环首次适应算法。</strong></p><p>方法：从上次找到的空闲分区的下一个开始查找，直到找到满足大小的空闲分区，分割该分区。</p><p>特点：空闲分区分布均匀，提高了查找速度；缺乏大的空闲分区。</p><p><strong>3．最佳适应算法</strong></p><p>要求：分区按大小递增排序；分区释放时需插入到适当位置。</p><p>方法：从小分区开始，找大小满足要求，但空余最小的分区。</p><p>特点：单次分配看似最优，但存在许多难以利用的碎片。总体未必最优。</p><p><strong>4．最坏适应算法</strong></p><p>方法：总是选择最大的分区来分割分配。</p><p>特点: 缺乏大的空闲分区。对中小作业有利。查找效率高。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623104852404.png" alt="image-20210623104852404"></p><p><strong>三、分区分配</strong></p><p>1．分配：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623105056935.png" alt="image-20210623105056935"></p><p>2．回收：</p><p>（1）上邻空闲区：合并，改大小。</p><p>（2）下邻空闲区：合并，改大小，首址。</p><p>（3）上、下邻空闲区：合并，改大小。</p><p>（4）不邻接，则建立一新表项。</p><h3 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h3><p><strong>动态重定位的引入</strong></p><ul><li>内零头：分配给作业但作业并不需要的部分。</li><li>外零头：太小无法分配给任何作业的块。</li><li>连续式分配中，总量大于作业大小的多个小分区不能容纳作业。</li><li>紧凑<ul><li>通过作业移动将原来分散的小分区拼接成一个大分区。</li><li>作业的移动需重定位。是动态（因作业已经装入）</li></ul></li></ul><p><strong>动态重定位实现</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623110156258.png" alt="image-20210623110156258"></p><p><strong>动态分区分配算法</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623110237136.png" alt="image-20210623110237136"></p><h2 id="离散分配方式"><a href="#离散分配方式" class="headerlink" title="离散分配方式"></a>离散分配方式</h2><p><strong>离散分配方式的引入</strong></p><ul><li>连续分配方式会产生内&#x2F;外零头</li><li>为解决零头问题又要进行紧凑等高开销活动</li></ul><p><strong>什么是离散分配</strong></p><ul><li>程序在内存中不一定连续存放</li></ul><p><strong>根据离散时的基本单位不同，可分为三种：</strong></p><ul><li>分页存储管理</li><li>分段存储管理</li><li>段页式存储管理</li></ul><h3 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h3><h4 id="页面和物理块"><a href="#页面和物理块" class="headerlink" title="页面和物理块"></a>页面和物理块</h4><ul><li>将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。</li><li>相应地，也把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或页框。</li><li>在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。</li><li>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”或称为“内零头”。</li></ul><p>注：</p><ul><li>系统一旦启动，则页和页框大小固定不变，且两者相等。</li><li>从0开始编制页号，页内地址是相对于0编址。</li><li>在进程调度时，必须把它的所有页一次装入到主存的页框内；如果当时页框数不足，则该进程必须等待，系统再调度另外的进程。（纯分页方式）</li></ul><h4 id="实现分页存储管理的数据结构"><a href="#实现分页存储管理的数据结构" class="headerlink" title="实现分页存储管理的数据结构"></a>实现分页存储管理的数据结构</h4><ol><li><strong>页表：</strong>每个进程对应 1 个页表，描述该进程的各页面在内存中对应的物理块号。</li></ol><ul><li>页表中包括页号、物理块号（还可有存取控制字段，对存储块中的内容进行保护）。</li><li>注意：全部页表集中存放在主存的系统专用区中，只有系统有权访问页表，保证安全。</li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623135845025.png" alt="image-20210623135845025"></p><ol start="2"><li><p><strong>作业表</strong>：整个系统1张，记录作业的页表情况，包含进程号、页表长度、页表始址等信息。</p></li><li><p><strong>空闲块表：</strong>整个系统1张，记录主存当前空闲块。</p></li></ol><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624094122698.png" alt="image-20210624094122698"></p><h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><ul><li><p>分页系统：处理机每次存取指令或数据至少需要访问两次物理内存： 第一次访问页表，第二次存取指令或数据</p></li><li><p>为了提高地址变换速度，为进程页表设置一个专用的高速缓冲存储器，称为快表、TLB(Translation Lookaside Buffer)，或联想存储器（Associative Memory）</p></li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624094237285.png" alt="image-20210624094237285"></p><p><strong>内存的有效访问时间</strong></p><p>有快表时：命中率，指使用快表并在其中成功找到所需页面的表项的概率。</p><p>EAT &#x3D; a x λ + ( t + λ )(1-a) + t &#x3D; 2t + λ – t x a</p><p>λ为查找快表所需的时间，a为命中率，t表示一次内存访问需要的时间。</p><h4 id="两级或多级页表"><a href="#两级或多级页表" class="headerlink" title="两级或多级页表"></a>两级或多级页表</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624094346119.png" alt="image-20210624094346119"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624094639358.png" alt="image-20210624094639358"></p><h4 id="对分页存储管理的评价"><a href="#对分页存储管理的评价" class="headerlink" title="对分页存储管理的评价"></a>对分页存储管理的评价</h4><ul><li>彻底消除了外零头,仅存在很少的内零头, 提高了内存利用率。</li><li>分页操作由系统自动进行,一个页面不能实现某种逻辑功能。用户看到的逻辑地址是一维的，无法调试执行其中的某个子程序或子函数。</li><li>采用分页技术不易于实现存储共享，也不便于程序的动态链接。</li></ul><h3 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h3><ul><li>作业地址空间按逻辑信息的完整性被划分为若干个段。</li><li>每段有段名（或段号），每段从0开始编址。</li><li>段内的地址空间是连续的。</li><li>许多编译程序支持分段方式，自动根据源程序的情况产生若干个段。</li></ul><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><ul><li>为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区中。</li><li>应像分页系统那样，在系统中为每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址(又称为“基址”)和段的长度。</li><li>通常将段表放在内存中，执行中的进程可通过查找段表找到每个段所对应的内存区。</li><li>作用：实现从逻辑段到物理内存区的映射。</li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624100544870.png" alt="image-20210624100544870"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624100631794.png" alt="image-20210624100631794"></p><h4 id="地址变换机构-1"><a href="#地址变换机构-1" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624100719338.png" alt="image-20210624100719338"></p><h4 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h4><p><strong>可重入代码（Reentrant Code, 纯代码）</strong></p><p>是一种允许多个进程同时访问的代码（可共享），且是一种不允许任何进程对其进行修改的代码。</p><p><strong>分页共享</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624101142394.png" alt="image-20210624101142394"></p><p><strong>分段共享</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624101255376.png" alt="image-20210624101255376"></p><h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><p>先将用户程序分段，每段内再划分成若干页，每段有段名（段号），每段内部的页有一连续的页号。</p><p><strong>逻辑地址结构</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624101737964.png" alt="image-20210624101737964"></p><h4 id="地址变换机构-2"><a href="#地址变换机构-2" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624101957337.png" alt="image-20210624101957337"></p><ul><li>首先，从段表寄存器从获得进程段表的起始地址，根据该地址，查找进程的段表。</li><li>然后，根据逻辑地址指定的段号检索段表，找到对应段的页表起始地址。</li><li>再根据逻辑地址中指定的页号检索该页表，找到对应页所在的物理块号。</li><li>最后，用物理块号加上逻辑地址中指定的页内偏移量，形成物理地址。</li></ul><p>在段页式存储管理方式中，每访问一次数据，需访问三次内存。</p><ul><li>第一次访问内存中的段表</li><li>第二次访问内存中的页表</li><li>第三次访问相应数据。</li></ul><p>解决方法：</p><p>   可以设置快表，表项应包括段号、页号、物理块号。</p><h2 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h2><h3 id="常规存储管理方式的特征"><a href="#常规存储管理方式的特征" class="headerlink" title="常规存储管理方式的特征"></a>常规存储管理方式的特征</h3><p>“<strong>一次性</strong>”: 要求将一个作业全部装入内存才能运行。</p><p> 1）大作业无法运行。</p><p> 2）限制作业并发执行的程度。</p><p>“<strong>驻留性</strong>”: 作业装入后一直驻留内存直到作业完成。</p><p>内存中存在一些已无用的、或暂时不用的程序或数据，浪费内存空间。</p><h3 id="内存扩充方法"><a href="#内存扩充方法" class="headerlink" title="内存扩充方法"></a>内存扩充方法</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624103105363.png" alt="image-20210624103105363"></p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>时间局限性</p><ul><li>如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。</li><li>产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作。</li></ul><p>空间局限性</p><ul><li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问。</li><li>程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624103332874.png" alt="image-20210624103332874"></p><h3 id="实现虚拟存储的一般过程"><a href="#实现虚拟存储的一般过程" class="headerlink" title="实现虚拟存储的一般过程"></a>实现虚拟存储的一般过程</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624103433145.png" alt="image-20210624103433145"></p><h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><p> 1．多次性</p><p>​    多次性是指一个作业被分成多次调入内存运行。 </p><p> 2．对换性</p><p>​    对换性是指作业的运行过程中进行换进、换出，换进和换出能有效地提高内存利用率。 </p><p> 3．虚拟性</p><p>  虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</p><h3 id="虚拟存储管理的实现方法"><a href="#虚拟存储管理的实现方法" class="headerlink" title="虚拟存储管理的实现方法"></a>虚拟存储管理的实现方法</h3><p><strong>请求分页存储管理方式</strong> </p><p>这是在分页系统的基础上，增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。</p><p>允许只装入部分页面的程序（及数据），便启动运行。</p><p>以后，再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上。</p><p>置换时以页面为单位。</p><p><strong>硬件支持：</strong></p><p>①请求分页的页表机制上增加若干项，作为请求分页的数据结构。</p><p>②缺页中断机构:当要访问的页面尚未调入内存时，便产生缺页中断，请求调页。</p><p>③地址变换机构：虚地址到物理地址转换。</p><p><strong>软件支持：</strong></p><p>①实现请求调页的软件</p><p>②实现页面置换的软件</p><hr><p><strong>请求分段系统</strong> </p><p>它允许只装入若干段的用户程序和数据，即可启动运行。以后再通过调段功能和段的置换功能，将暂不运行的段调出，同时调入即将运行的段。</p><p>为了实现请求分段，系统同样需要必要的硬件支持。一般需要下列支持：  </p><p>（1）请求分段的段表机制，这是在纯分段的段表机制基础上增加若干项而形成的。</p><p>（2）缺段中断机构 </p><p>（3）地址变换机构。</p><p>实现请求调段和段的置换功能也须得到相应的软件支持。</p><hr><p><strong>段页式虚拟存储系统</strong></p><p>许多虚拟存储管理系统是建立在段页式系统的基础上的，通过增加了请求调页、页面置换两大功能所形成的段页式虚拟存储系统。</p><h3 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h3><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a><strong>页表机制</strong></h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624105328357.png" alt="image-20210624105328357"></p><p><strong>状态位：</strong>也称存在位，标志该页是否驻留内存。</p><p><strong>访问位：</strong>记录一段时间内该页被访问的情况，如一段时间内该页被访问的次数或者多长时间未被访问。</p><p><strong>修改位：</strong>标记该页是否被修改过。注：为减少置换开销，通常选择未被修改过的页面置换。</p><p><strong>外存地址：</strong>用于记录该页在外存上的存储地址。</p><h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><ul><li>在请求分页系统中，每当所要访问的页面不在内存时，便产生一缺页中断，请求OS将所缺之页调入内存。</li><li>地址转换时，检查页面的页表项中的存在位，如果为0，则产生一个缺页中断。</li></ul><p><strong>缺页中断处理过程</strong></p><p>（1）操作系统接收到进程产生的缺页中断信号，启动中断处理例程，保留处理机现场；</p><p>（2）操作系统通知处理机从外存读取指定的页面；</p><p>（3）处理机激活I&#x2F;O设备；</p><p>（4） 检查内存有无足够的空闲空间装入该页面？若有，转（6），否则，执行（5）；</p><p>（5） 利用页面置换算法，选择内存中的某个页面，换出内存；</p><p>（6） 将指定页面从外存装入内存；</p><p>（7） 更新该进程的页表；</p><p>（8） 更新快表；</p><p>（9）计算物理地址。</p><h4 id="地址变换机构-3"><a href="#地址变换机构-3" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624110028023.png" alt="image-20210624110028023"></p><h3 id="内存分配策略和分配算法"><a href="#内存分配策略和分配算法" class="headerlink" title="内存分配策略和分配算法"></a>内存分配策略和分配算法</h3><h4 id="物理块的分配策略"><a href="#物理块的分配策略" class="headerlink" title="物理块的分配策略"></a><strong>物理块的分配策略</strong></h4><h5 id="固定分配局部置换"><a href="#固定分配局部置换" class="headerlink" title="固定分配局部置换"></a>固定分配局部置换</h5><ul><li>为每个进程分配一定数目的物理块，在整个运行期间都不再改变。 </li><li>实现这种策略的困难在于：应为每个进程分配多少个物理块难以确定。<ul><li>若太少，会频繁地出现缺页中断，降低了系统的吞吐量。</li><li>若太多，又必然使内存中驻留的进程数目减少，进而可能造成CPU空闲或其它资源空闲的情况，而且在实现进程对换时，会花费更多的时间。</li></ul></li></ul><h5 id="可变分配全局置换-（常用方式）"><a href="#可变分配全局置换-（常用方式）" class="headerlink" title="可变分配全局置换 （常用方式）"></a>可变分配全局置换 （常用方式）</h5><p>在采用这种策略时，先为系统中的每个进程分配一定数目的物理块，而OS自身也保持一个空闲物理块队列。当某进程发现缺页时，由系统从空闲物理块队列中，取出一个物理块分配给该进程，并将欲调入的（缺）页装入其中。这样，凡产生缺页（中断）的进程，都将获得新的物理块；仅当空闲物理块队列中的物理块用完时， OS才能从内存中选择一页调出，该页可能是系统中任一进程的页，这样，自然又会使那个进程的物理块减少，进而使其缺页率增加。</p><h5 id="可变分配局部置换"><a href="#可变分配局部置换" class="headerlink" title="可变分配局部置换"></a>可变分配局部置换</h5><p>   吗为每个进程分配一定数目的物理块，但当某进程发现缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其它进程的运行。 </p><p>在进程运行过程中统计进程的缺页率，如果缺页率高，则为其增加一定的内存页，否则适当减少其内存的页面数。</p><p>实现复杂：对进程的缺页情况的统计需要额外的开销。</p><h4 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a><strong>物理块分配算法</strong></h4><p><strong>平均分配算法</strong></p><p>将系统中所有可供分配的物理块，平均分配给各个进程。 </p><p><strong>按比例分配算法</strong></p><p>根据进程的大小按比例分配物理块的算法。如果系统中共有n个进程，每个进程的页面数为Si，则系统中各进程页面数的总和为：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624121023682.png" alt="image-20210624121023682"></p><p>又假定系统中可用的物理块总数为m，则每个进程所能分到的物理块数为bi，将有：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624121046507.png" alt="image-20210624121046507"></p><p>bi应该取整，它必须大于最小物理块数。</p><p><strong>考虑优先权的分配算法</strong> </p><p>通常采取的方法是把内存中可供分配的所有物理块分成两部分：</p><ul><li>一部分按比例地分配给各进程。</li><li>另一部分则根据各进程的优先权，适当地增加其相应份额后，分配给各进程。</li></ul><h3 id="调页策略"><a href="#调页策略" class="headerlink" title="调页策略"></a>调页策略</h3><h4 id="预调页方式"><a href="#预调页方式" class="headerlink" title="预调页方式"></a>预调页方式</h4><p>可采用一种以预测为基础的预调页策略，将那些<strong>预计在不久之后便会被访问</strong>的页面，预先调入内存。</p><p><strong>处理过程：</strong></p><p>当进程创建时，预先为进程装入多个页面。</p><p>缺页中断时，系统为进程装入指定的页面以及与之相临的多个页面。</p><p>若局部性很差，预先装入的很多页面不会很快被引用，并会占用大量的内存空间，<strong>反而降低</strong>系统的效率。目前预调页的成功率仅约50％。</p><h4 id="请求调页"><a href="#请求调页" class="headerlink" title="请求调页"></a>请求调页</h4><ul><li>仅当进程执行过程中，通过检查页表发现相应页面不在内存时，才装入该页面。</li><li>采用请求调页方式，一次装入请求的一个页面，磁盘I&#x2F;O的启动频率较高，系统的开销较大。</li><li>当进程刚开始执行时，由于预先未装入进程的页面，故需要频繁地申请装入页面。执行一段时间以后，进程的缺页率将下降。</li></ul><h4 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h4><p>在请求分页系统中的外存分为两部分：</p><ul><li>用于存放文件的文件区</li><li>用于存放对换页面的对换区</li></ul><p><strong>（1）系统拥有足够的对换区空间</strong></p><ul><li>进程运行前需将全部有关文件从文件区拷贝到对换区。 </li><li>这时可以全部从对换区调入所需页面，以提高调页的速度。</li></ul><p><strong>（2）系统缺少足够的对换区空间</strong></p><ul><li>这时凡是不会被修改的文件，都直接从文件区调入。</li><li>而当换出这些页面时，若未被修改则直接丢弃，以后再调入时，仍从文件区调入。</li><li>但对于那些可能被修改的部分，在将它们换出时，便须调到对换区，以后需要时，再从对换区调入。</li></ul><p><strong>（3）UNIX方式</strong></p><ul><li>由于与进程有关的文件都放在文件区，应从文件区调入。</li><li>凡是未运行过的页面，都应从文件区调入。</li><li>而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。 </li><li>允许页面共享</li></ul><h4 id="页面调入过程"><a href="#页面调入过程" class="headerlink" title="页面调入过程"></a>页面调入过程</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624122808480.png" alt="image-20210624122808480"></p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul><li>最佳(优)置换算法</li><li>先进先出（FIFO）页面置换算法</li><li>最近最久未使用（LRU）置换算法</li><li>Clock置换算法</li><li>改进型Clock置换算法</li><li>其它置换算法</li></ul><h5 id="最佳-优-置换算法"><a href="#最佳-优-置换算法" class="headerlink" title="最佳(优)置换算法"></a>最佳(优)置换算法</h5><blockquote><p>所选择的被淘汰页面，将是以后永不使用的，或是在最长(未来)时间内不再被访问的页面。</p></blockquote><p>假定系统为某进程分配了三个物理块， 并考虑有以下的页面访问序列：</p><p>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</p><p>进程运行时， 先将7，0，1三个页面装入内存。 </p><p>以后，当进程要访问页面2时， 将会产生缺页中断。此时OS根据最佳置换算法， 将选择页面7予以淘汰。 </p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624123943775.png" alt="image-20210624123943775"></p><p><strong>先进先出（FIFO）页面置换算法</strong></p><blockquote><p>该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰 </p></blockquote><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624124109861.png" alt="image-20210624124109861"></p><p><strong>最近最久未使用（LRU）置换算法</strong></p><blockquote><p>LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。</p></blockquote><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624124203999.png" alt="image-20210624124203999"></p><h4 id="Clock置换算法"><a href="#Clock置换算法" class="headerlink" title="Clock置换算法"></a>Clock置换算法</h4><ul><li>当采用简单c1ock算法时，为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。</li><li>当某页被访问时，其访问位被置1。</li><li>置换程序从上次停止位置开始检查页面的访问位。<ul><li>如果是0，就选择该页换出。</li><li>若为1，则重新将它置0，暂不换出，而给该页第二次驻留内存的机会。</li></ul></li><li>由于该算法是循环地检查各页面的使用情况，故称为c1ock算法。</li><li>置换时是将未使用过的页面换出去，故又把该算法称为最近未用算法NRU。</li></ul><p><strong>Clock算法的流程</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624125141192.png" alt="image-20210624125141192"></p><p><strong>实例</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624125305622.png" alt="image-20210624125305622"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624125339098.png" alt="image-20210624125339098"></p><h4 id="改进型Clock置换算法"><a href="#改进型Clock置换算法" class="headerlink" title="改进型Clock置换算法"></a>改进型Clock置换算法</h4><p>由访问位A和修改位M可以组合成下面四种类型的页面：</p><ul><li>​    1类（A&#x3D;0，M&#x3D;0：表示该页最近既未彼访问，又未被修改，是最佳淘汰页。</li><li>​    2类（A&#x3D;0，M&#x3D;1）：表示该页最近未被访问，但已被修改，并不是很好的淘汰页。</li><li>​    3类（A&#x3D;1，M&#x3D;0）：最近已被访问，但未被修改：该页有可能再被访问。</li><li>​    4类（A&#x3D;1，M&#x3D;1）：最近已被访问且被修改，该页可能再被访问。</li></ul><h1 id="第五章-设备管理"><a href="#第五章-设备管理" class="headerlink" title="第五章 设备管理"></a>第五章 设备管理</h1><ul><li>设备管理的对象：主要是I&#x2F;O设备。</li><li>设备管理的基本任务：完成用户提出的I&#x2F;O请求，提高I&#x2F;O速率以及改善I&#x2F;O设备的利用率。  </li><li>设备管理的主要功能有：缓冲区管理、设备分配、设备处理、虚拟设备及实现设备独立性等。</li></ul><p><strong>I&#x2F;O 系统的基本功能</strong></p><ol><li><p>设备分配 </p></li><li><p>设备映射</p></li><li><p>设备驱动</p></li><li><p>I&#x2F;O缓冲区的管理</p></li></ol><h3 id="通用设备管理分层模型"><a href="#通用设备管理分层模型" class="headerlink" title="通用设备管理分层模型"></a><strong>通用设备管理分层模型</strong></h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624141938727.png" alt="image-20210624141938727"></p><h3 id="设备控制器的组成"><a href="#设备控制器的组成" class="headerlink" title="设备控制器的组成"></a><strong>设备控制器的组成</strong></h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624144016184.png" alt="image-20210624144016184"></p><h3 id="I-x2F-O-通道"><a href="#I-x2F-O-通道" class="headerlink" title="I&#x2F;O 通道"></a><strong>I&#x2F;O</strong> <strong>通道</strong></h3><p>I&#x2F;O通道设备的引入 目的是使一些原来由CPU处理的I&#x2F;O任务转由通道来承担，从而把CPU从繁杂的I&#x2F;O任务中解脱出来。</p><p> 采用通道有以下特点：</p><ul><li>① DMA（直接存储器存取）方式显著地减少了CPU的干预。</li><li>②只需向I&#x2F;O通道发送一条I&#x2F;O指令，即可完成一组相关的读（或写）操作及有关控制。</li><li>③可实现CPU、通道和I&#x2F;O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</li></ul><h3 id="中断简介"><a href="#中断简介" class="headerlink" title="中断简介"></a><strong>中断简介</strong></h3><p><strong>中断源：</strong>引起中断发生的事件</p><p><strong>中断请求：</strong>中断源向CPU发出的请求中断处理信号</p><p><strong>中断响应：</strong>CPU收到中断请求后转到相应的事件处理程序的过程</p><p><strong>关中断&#x2F;开中断：</strong>CPU内部的PSW的中断允许位被清除&#x2F;被设置，不允许&#x2F;允许CPU响应中断。用于保证某段程序执行的原子性</p><p><strong>中断屏蔽：</strong>在中断请求产生后，系统有选择地封锁一部分中断而允许另一部分仍能得到响应。有些具有最高优先级的中断不允许被屏蔽</p><p><strong>中断处理层的主要工作有：</strong></p><ul><li>进行进程上下文的切换</li><li>对处理中断信号源进行测试</li><li>读取设备状态和修改进程状态等</li></ul><p><strong>中断线程保护</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624144304059.png" alt="image-20210624144304059"></p><p><strong>中断处理流程</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624144327738.png" alt="image-20210624144327738"></p><h3 id="对I-x2F-O设备的控制方式"><a href="#对I-x2F-O设备的控制方式" class="headerlink" title="对I&#x2F;O设备的控制方式"></a>对I&#x2F;O设备的控制方式</h3><h4 id="轮询的可编程I-x2F-O方式"><a href="#轮询的可编程I-x2F-O方式" class="headerlink" title="轮询的可编程I&#x2F;O方式"></a><strong>轮询的可编程I&#x2F;O方式</strong></h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624144418677.png" alt="image-20210624144418677"></p><h4 id="中断的可编程I-x2F-O方式"><a href="#中断的可编程I-x2F-O方式" class="headerlink" title="中断的可编程I&#x2F;O方式"></a>中断的可编程I&#x2F;O方式</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624144438178.png" alt="image-20210624144438178"></p><h4 id="直接存储器访问方式"><a href="#直接存储器访问方式" class="headerlink" title="直接存储器访问方式"></a><strong>直接存储器访问方式</strong></h4><p><strong>DMA控制方式的特点：</strong></p><p>①数据传输的基本单位是数据块，即在CPU与I&#x2F;O设备之间，每次传送至少一个数据块；</p><p>②所传送的数据是从设备直接送入内存的，或者相反；</p><p>③仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。</p><p><strong>DMA控制器的组成</strong> </p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624144613415.png" alt="image-20210624144613415"></p><p><strong>DMA工作过程</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624144630693.png" alt="image-20210624144630693"></p><h4 id="I-x2F-O通道控制方式"><a href="#I-x2F-O通道控制方式" class="headerlink" title="I&#x2F;O通道控制方式"></a>I&#x2F;O通道控制方式</h4><p><strong>I&#x2F;O通道控制方式的引入</strong> </p><p>I&#x2F;O通道方式是DMA方式的发展，它可进一步减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。</p><p>可实现CPU、通道和I&#x2F;O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。 </p><h2 id="I-x2F-O控制方式"><a href="#I-x2F-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624144715519.png" alt="image-20210624144715519"></p><h2 id="磁盘存储管理"><a href="#磁盘存储管理" class="headerlink" title="磁盘存储管理"></a>磁盘存储管理</h2><p><strong>提高磁盘I&#x2F;O速度的主要途径：</strong></p><p>（1）选择性能好的磁盘</p><p>（2）采用好的磁盘调度算法</p><p>（3）设置磁盘高速缓存（Disk Cache）</p><p>（4）其它方法</p><p>（5）采用高度可靠、快速的容量磁盘系统–磁盘冗余阵列</p><p><strong>数据的组织和格式</strong></p><ul><li>存储面(surface)</li><li>磁道(track)</li><li>柱面</li><li>扇区(sectors)</li></ul><p><img src="C:\Users\Jason\AppData\Roaming\Typora\typora-user-images\image-20210624164444356.png" alt="image-20210624164444356"></p><h3 id="磁盘访问时间分成以下三部分："><a href="#磁盘访问时间分成以下三部分：" class="headerlink" title="磁盘访问时间分成以下三部分："></a>磁盘访问时间分成以下三部分：</h3><h4 id="寻道时间Ts-："><a href="#寻道时间Ts-：" class="headerlink" title="寻道时间Ts ："></a>寻道时间Ts ：</h4><p>这是指把磁臂（磁头）移动到指定磁道上所经历的时间。 </p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624164539003.png" alt="image-20210624164539003"></p><p>s：启动磁臂的时间</p><p>n：磁头移动n条磁道</p><p>m：移动每一条磁道所花费的时间</p><h4 id="旋转延迟时间Tτ："><a href="#旋转延迟时间Tτ：" class="headerlink" title="旋转延迟时间Tτ："></a>旋转延迟时间Tτ：</h4><p>这是指定扇区移动到磁头下面所经历的时间。</p><p>例如：</p><p>软盘旋转速度为 300 r&#x2F;min或600 r&#x2F;min，这样，平均Tτ 为50～100 ms。</p><p>硬盘旋转速度为15 000 r&#x2F;min，每转需时4 ms，平均旋转延迟时间Tτ为2 ms。</p><h4 id="传输时间Tt："><a href="#传输时间Tt：" class="headerlink" title="传输时间Tt："></a>传输时间Tt：</h4><p>这是指把数据从磁盘读出或向磁盘写入数据所经历的时间。 </p><p>Tt 的大小与每次所读&#x2F;写的字节数b 和旋转速度有关:</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624164722001.png" alt="image-20210624164722001"></p><p>r为磁盘每秒钟的转数；N为一条磁道上的字节数</p><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><h4 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h4><ul><li>根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，且每个进程的请求都能依次地得到处理，不会出现某一进程的请求长期得不到满足的情况。</li></ul><h4 id="最短寻道时间优先SSTF"><a href="#最短寻道时间优先SSTF" class="headerlink" title="最短寻道时间优先SSTF"></a>最短寻道时间优先SSTF</h4><ul><li>该算法选择这样的进程，其要求访问的磁道，与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，  </li><li>SSTF算法虽然能获得较好的寻道性能，但却可能导致某个进程发生“饥饿”现象。</li></ul><h4 id="扫描（SCAN）算法"><a href="#扫描（SCAN）算法" class="headerlink" title="扫描（SCAN）算法"></a>扫描（SCAN）算法</h4><ul><li>SSTF算法虽然能获得较好的寻道性能，但却可能导致某个进程发生“饥饿”(Starvation)现象。</li><li>该算法优先考虑的是磁头当前的移动方向。例如，磁头自里向外移动, 并同时自里向外地访问，直至再无更外的磁道需要访问时，才将磁臂换向自外向里移动。（又常称之为电梯调度算法 ）</li></ul><h4 id="循环扫描（CSCAN）算法"><a href="#循环扫描（CSCAN）算法" class="headerlink" title="循环扫描（CSCAN）算法"></a>循环扫描（CSCAN）算法</h4><p>CSCAN算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描。 </p><h1 id="第六章-文件管理"><a href="#第六章-文件管理" class="headerlink" title="第六章 文件管理"></a>第六章 文件管理</h1><h2 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h2><p>文件是存储和管理数据的容器</p><p>若文件中的数据有格式，可能是如下的结构：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624170615803.png" alt="image-20210624170615803"></p><p>文件是指由创建者所定义的、 具有文件名的一组相关元素的集合。</p><p>在有结构的文件中，文件由若干个相关记录组成；</p><p>而无结构文件则被看成是一个字符流。</p><p>文件在文件系统中是一个基本的管理单元，这个管理单元必然有一组属性。</p><h2 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h2><p>文件的属性可以包括：</p><p>(1) 文件类型 </p><p>(2) 文件长度  </p><p>(3) 文件的物理位置  </p><p>(4) 文件的建立时间   </p><h2 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h2><p>定义：操作系统中的各类文件、管理文件的软件，以及管理文件所涉及到的数据结构等信息的集合。</p><p>有少数实时操作系统没有文件系统功能。</p><p>绝大多数操作系统都包含文件管理系统部分。</p><h2 id="文件系统的功能"><a href="#文件系统的功能" class="headerlink" title="文件系统的功能"></a>文件系统的功能</h2><ul><li>有效地管理文件的存储空间；</li><li>管理文件目录；</li><li>完成文件的读&#x2F;写操作；</li><li>实现文件共享与保护；</li><li>为用户提供交互式命令接口和程序调用接口。</li></ul><h2 id="文件系统模型"><a href="#文件系统模型" class="headerlink" title="文件系统模型"></a>文件系统模型</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624170844359.png" alt="image-20210624170844359"></p><h2 id="文件操作概述"><a href="#文件操作概述" class="headerlink" title="文件操作概述"></a>文件操作概述</h2><p>1.最基本的文件操作有：创建文件、删除文件。读文件、写文件、截断文件和设置文件的读／写位置。</p><p>2.文件的“打开”和“关闭”操作：所谓“打开”，是指系统将指名文件的属性（包括该文件在外存上的物理位置）从外存拷贝到内存打开文件表的一个表目中，并将该表目的编号（或称为索引）返回给用户。 利用“关闭”（close）系统调用来关闭此文件，OS将会把该文件从打开文件表中的表目上删除掉。 </p><p>3．其它文件操作：对文件属性的操作，改变文件名、改变文件的拥有者，查询文件的状态等；  </p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624171142278.png" alt="image-20210624171142278"></p><h2 id="文件目录的管理要"><a href="#文件目录的管理要" class="headerlink" title="文件目录的管理要"></a>文件目录的管理要</h2><p>如何来组织和访问大量的文件？</p><p>对目录管理的要求如下：</p><p>(1)实现“按名存取”。 </p><p>(2) 提高对目录的检索速度。 </p><p>(3) 文件共享。 </p><p>(4) 允许文件重名。 </p><h3 id="文件控制块和索引节点"><a href="#文件控制块和索引节点" class="headerlink" title="文件控制块和索引节点"></a>文件控制块和索引节点</h3><p>文件控制块（FCB）：用于描述和控制文件的数据结构。</p><p>文件目录：文件控制块的有序集合。</p><p>通常，一个文件目录也被看做是一个文件，称为目录文件。</p><h4 id="文件控制块的内容"><a href="#文件控制块的内容" class="headerlink" title="文件控制块的内容"></a>文件控制块的内容</h4><p><strong>基本信息：</strong>文件名、文件类型等；</p><p><strong>地址信息：</strong>卷（存储文件的设备）、起始地址（起始物理地址）、文件长度（以字节、字或块为单位）等。</p><p><strong>访问控制信息：</strong>文件所有者、访问信息（用户名和口令等）、合法操作等；</p><p><strong>使用信息：</strong>创建时间、创建者身份、当前状态、最近修改时间、最近访问时间等。　 </p><h4 id="FCB"><a href="#FCB" class="headerlink" title="FCB"></a>FCB</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624171409892.png" alt="image-20210624171409892"></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><p>所有用户的全部文件目录保存在一张目录表中，每个文件的目录项占用一个表项。 </p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624171621519.png" alt="image-20210624171621519"></p><ul><li><p>单级目录的优点是简单且能实现目录管理的基本功能——按名存取</p></li><li><p>存在下述一些缺点：</p></li></ul><p>​      (1) 查找速度慢 </p><p>​      (2) 不允许重名 </p><p>​      (3) 不便于实现文件共享 </p><h3 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h3><p>主文件目录MFD、用户文件目录UFD</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624171715822.png" alt="image-20210624171715822"></p><ul><li>一定程度解决了重名问题</li><li>提高了文件目录检索效率</li><li>简单的文件共享</li></ul><p><strong>问题：</strong>不便用户文件的逻辑分类；进一步解决重名、共享、检索效率等问题</p><h3 id="树形结构目录"><a href="#树形结构目录" class="headerlink" title="树形结构目录"></a>树形结构目录</h3><p>多级目录结构又称为树型目录结构，主目录在这里被称为根目录，把数据文件称为树叶，其它的目录均作为树的结点。</p><p>树叶是数据文件。</p><p>树的节点是目录，或称为子目录。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624171815129.png" alt="image-20210624171815129"></p><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p><strong>创建目录：</strong>在用户要创建一个新文件时，只需查看在自己的UFD及其子目录中，有无与新建文件相同的文件名。若无，便可在UFD或其某个子目录中增加一个新目录项。 </p><p><strong>目录删除</strong>采用下述两种方法处理： </p><p>（1）不删除非空目录。 </p><p>（2）可删除非空目录。 </p><p><strong>改变目录：</strong>改变工作目录</p><p><strong>移动目录：</strong>将子目录或者文件移动到其他目录下。</p><p><strong>链接操作：</strong>通过链接让同一个文件具有多个父目录。</p><p><strong>查找：</strong>在目录中查找某个文件或者子目录。</p><h2 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h2><h3 id="线性检索法"><a href="#线性检索法" class="headerlink" title="线性检索法"></a>线性检索法</h3><p>线性检索法又称为顺序检索法。 </p><p>①在单级目录中，利用用户提供的文件名，用顺序查找法直接从文件目录中找到指名文件的目录项。</p><p>②在树型目录中，用户提供的文件名是由多个文件分量名组成的路径名，此时须对多级目录进行查找。 </p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624172104627.png" alt="image-20210624172104627"></p><h3 id="文件系统外存管理"><a href="#文件系统外存管理" class="headerlink" title="文件系统外存管理"></a>文件系统外存管理</h3><p>磁盘管理的主要任务和目标是；</p><ul><li>有效地利用外存空间</li><li>提高对文件的访问速度</li><li>提高磁盘系统的可靠性</li></ul><p>目前，常见的文件磁盘块的组织方法有:</p><ul><li>连续组织</li><li>链接组织</li><li>索引组织</li></ul><h3 id="连续组织"><a href="#连续组织" class="headerlink" title="连续组织"></a>连续组织</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624173103718.png" alt="image-20210624173103718"></p><p>假设磁盘的容量是1MB，每个磁盘块的大小为512个字节</p><p>磁盘块数量：1MB&#x2F;512B&#x3D;2048块</p><p>编码磁盘块需要位数：2∧10 &lt; 2048 &lt;&#x3D; 2 ∧11，因此需要11个二进制位</p><p>如果文件的长度不大于512K</p><p>长度需要10位来表示：512K&#x2F;512 &#x3D; 1024, 2∧10 &#x3D; 1024</p><p>因此，每个文件需要在目录中额外占用21个二进制位。</p><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a><strong>空闲链表法</strong></h3><p><strong>空闲盘区链</strong></p><ul><li><p>将磁盘上的所有空闲盘区(每个盘区可包含若干个盘块)拉成一条链。</p></li><li><p>在每个盘区上含有用于指示下一个空闲盘区的指针和能指明本盘区大小(盘块数)的信息。</p></li><li><p>分配盘区的方法与内存的动态分区分配类似，通常采用首次适应算法。</p></li><li><p>在回收盘区时，同样也要将回收区与相邻接的空闲盘区相合并。</p></li><li><p>为了提高对空闲盘区的检索速度，可以采用显式链接方法，亦即，在内存中为空闲盘区建立一张链表。</p></li><li><p>每个分区结点内容：起始盘块号、盘块数、指向下一个空闲盘区的指针。</p></li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624173547334.png" alt="image-20210624173547334"></p><p> <strong>问题</strong></p><ul><li>一段时间以后，可能会使空闲分区链表中包含太多小分区，使文件分配到的存储空间过分离散。</li><li>删除一个由许多离散小分区组成的文件时，将回收的小分区链接到空闲分区链表中需要很长时间。</li><li>若一个文件申请连续存储空间，则需要花费较长的时间查找相邻的空闲分区。</li><li>因此，这种空闲空间组织方法适合于非连续存储文件。</li></ul><h3 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a><strong>位示图</strong></h3><p>利用二进制位0、1表示存储空间中存储块的使用状态。空闲分区:0，已分配分区:1（或者相反）。</p><p>磁盘上的所有盘块都有一个二进制位与之对应，这样，由所有盘块所对应的位构成一个集合，称为位示图。</p><p>通常可用m × n 个位数来构成位示图，并使m × n等于磁盘的总块数。</p><p>位示图也可描述为一个二维数组map：</p><p><code>Var map: array of bit;</code></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/24/image-20210624173727639.png" alt="image-20210624173727639"></p><p><strong>位示图优点</strong></p><ul><li>可以容易地找到一个或一组连续的空闲分区。</li><li>例如，我们需要找到4个相邻接的空闲盘块，这只需在位示图中找出4个其值连续为“0”的位即可。</li></ul><p><strong>位示图的其他问题</strong></p><ul><li>一个位示图需要占用的存储空间大小为：</li></ul><p><strong>磁盘容量（字节数）&#x2F; （8 * 数据块大小）</strong></p><ul><li>对于容量较小的磁盘，位示图占用的空间会很小。</li><li>但是，对于一个16GB的磁盘，若数据块大小为512字节，则位示图大小为4MB，大约需要占用8000个磁盘块的存储空间。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>重点：</p><ul><li>文件和文件系统的概念；文件是具有符号名的信息（数据）项的集合；文件是具有符号名的记录的集合；文件是具有符号名的数据项的集合。</li><li>文件逻辑结构；顺序文件、索引顺序文件、索引文件、HASH文件；</li><li>磁盘存储分配方法；连续分配、链接分配、索引分配；</li><li>文件目录及文件控制块；文件存储器分区和空间管理。</li><li>磁盘存储管理；位示图、空闲链表、索引。</li></ul><p>难点：</p><ul><li><p>磁盘存储管理；</p></li><li><p>位示图、空闲链表、</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs</tag>
      
      <tag>review</tag>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora + Chevereto图床Markdown图片自动上传</title>
    <link href="/2021/06/typora-chevereto-markdown/"/>
    <url>/2021/06/typora-chevereto-markdown/</url>
    
    <content type="html"><![CDATA[<h2 id="Typora-配置"><a href="#Typora-配置" class="headerlink" title="Typora 配置"></a>Typora 配置</h2><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623142424581.png"></p><h2 id="编写上传脚本"><a href="#编写上传脚本" class="headerlink" title="编写上传脚本"></a>编写上传脚本</h2><h3 id="upload-py图床上传API调用程序"><a href="#upload-py图床上传API调用程序" class="headerlink" title="upload.py图床上传API调用程序"></a>upload.py图床上传API调用程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> mimetypes<br><span class="hljs-keyword">import</span> argparse<br><span class="hljs-keyword">import</span> sys<br><br>APP_DESC = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">一个上传图片到chevereto图床的命令行工具</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-built_in">print</span>(APP_DESC)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) == <span class="hljs-number">1</span>:<br>    sys.argv.append(<span class="hljs-string">&#x27;--help&#x27;</span>)<br><br>parser = argparse.ArgumentParser()<br>parser.add_argument(<span class="hljs-string">&#x27;-s&#x27;</span>, <span class="hljs-string">&#x27;--source&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, nargs=<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;&quot;</span>, required=<span class="hljs-literal">True</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;--config&#x27;</span>, default=<span class="hljs-string">&quot;./config.json&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;读取配置文件&quot;</span>, required=<span class="hljs-literal">True</span>)<br>args = parser.parse_args()<br><br><span class="hljs-comment"># 从参数中获取要上传的文件列表</span><br>img_list = args.source<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_conf</span>(<span class="hljs-params">path</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        confstr = f.read()<br>        conf = json.loads(confstr)<br>        <span class="hljs-comment">#print(conf)</span><br>    <span class="hljs-keyword">return</span> conf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">up_to_chevereto</span>(<span class="hljs-params">img_list</span>):<br>    <span class="hljs-comment"># 获得本地图片路径后，上传至图床并记录返回的json字段</span><br>    <span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> img_list:<br>        <span class="hljs-comment"># 先判断传过来的是本地路径还是远程图片地址</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;http&quot;</span> == img[:<span class="hljs-number">4</span>]:<br>            <span class="hljs-comment"># 非本地图片的话可以考虑下载到本地再上传，但是没这个必要</span><br>            <span class="hljs-built_in">print</span>(img)<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">try</span>:<br>                res_json = upload(formatSource(img))<br>                parse_response_url(res_json,img)<br>            <span class="hljs-keyword">except</span>:<br>                <span class="hljs-built_in">print</span>(img+<span class="hljs-string">&quot;\t上传失败&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">upload</span>(<span class="hljs-params">files</span>):<br>    <span class="hljs-comment"># 图床api</span><br>    APIKEY = <span class="hljs-string">&quot;你的key&quot;</span><br>    conf = read_conf(args.config)<br>    url = conf[<span class="hljs-string">&#x27;url&#x27;</span>] + <span class="hljs-string">&quot;?key=&quot;</span> + APIKEY<br>    r = requests.post(url, files=files)<br>    <span class="hljs-keyword">return</span> json.loads(r.text)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">formatSource</span>(<span class="hljs-params">filename</span>):<br>    imageList = []<br>    mime_type = mimetypes.guess_type(filename)[<span class="hljs-number">0</span>]<br>    imageList.append(<br>        (<span class="hljs-string">&#x27;source&#x27;</span>, (filename, <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;rb&#x27;</span>), mime_type))<br>    )<br>    <span class="hljs-keyword">return</span> imageList<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_response_url</span>(<span class="hljs-params">json, img_path</span>):<br>        <span class="hljs-comment"># 从返回的json中解析字段</span><br>    <span class="hljs-keyword">if</span> json[<span class="hljs-string">&#x27;status_code&#x27;</span>] != <span class="hljs-number">200</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;\tweb端返回失败,可能是APIKey不对. status_code &#123;&#125; .&quot;</span>.<span class="hljs-built_in">format</span>(<br>            img_path, json[<span class="hljs-string">&#x27;status_code&#x27;</span>])<br>        )<br>    <span class="hljs-keyword">else</span>:<br>        img_url = json[<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-string">&quot;url&quot;</span>]<br>        <span class="hljs-built_in">print</span>(img_url)<br><br>up_to_chevereto(img_list)<br></code></pre></td></tr></table></figure><h3 id="config-json配置文件"><a href="#config-json配置文件" class="headerlink" title="config.json配置文件"></a>config.json配置文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;APIKEY&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;你的key&quot;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://你的域名/api/1/upload/&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Windows下上传命令"><a href="#Windows下上传命令" class="headerlink" title="Windows下上传命令"></a>Windows下上传命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">python <span class="hljs-literal">-u</span> <span class="hljs-string">&quot;脚本路径\upload.py&quot;</span> <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;C:配置文件路径\config.json&quot;</span> <span class="hljs-literal">-s</span><br><span class="hljs-comment"># python -u &quot;C:\Program Files\Typora\upload.py&quot; -c &quot;C:\Program Files\Typora\config.json&quot; -s</span><br></code></pre></td></tr></table></figure><h3 id="工作效果"><a href="#工作效果" class="headerlink" title="工作效果"></a>工作效果</h3><p><strong>上传测试</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623143140288.png" alt="image-20210623143140288"></p><p><strong>实际测试</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623143228624.png" alt="image-20210623143228624"></p><p><strong>图片链接已自动更新</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/06/23/image-20210623143315195.png" alt="image-20210623143315195"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>IT小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
      <tag>Chevereto</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和廖老师一起学嵌入式操作系统</title>
    <link href="/2021/05/eosreview/"/>
    <url>/2021/05/eosreview/</url>
    
    <content type="html"><![CDATA[<h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><h3 id="任务概念"><a href="#任务概念" class="headerlink" title="任务概念"></a>任务概念</h3><ul><li>任务是一个程序运行的实体，资源占用的基本单位，也可能是系统调度的基本单元。</li><li>动态性、并发性、异步独立性。</li><li>一个任务也称作一个线程。</li></ul><h3 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C">OSTCBStkPtr<br>OSTCBNext<br>OSTCBPrev<br>OSTCBDly<br>OSTCBStat<br>OSTCBPrio<br><br>OSTCBX<br>OSTCBY<br>OSTCBBitX<br>OSTCBBitYCOPY<br></code></pre></td></tr></table></figure><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p>睡眠状态、就绪状态、运行状态、等待状态、中断服务状态。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/05/18/image-20210518104737047.png" alt="image-20210518104737047"></p><h3 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/05/18/OSTaskCreat.png" alt="OSTaskCreat"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c">INT8U  <span class="hljs-title function_">OSTaskCreate</span> <span class="hljs-params">(<span class="hljs-type">void</span> (*task)(<span class="hljs-type">void</span> *p_arg), <span class="hljs-type">void</span> *p_arg, OS_STK *ptos,INT8U prio)</span><br>&#123;<br>    OS_STK    *psp;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> OS_CRITICAL_METHOD == 3               </span><br>     OS_CPU_SR  cpu_sr = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    OS_ENTER_CRITICAL();   <br>    <span class="hljs-keyword">if</span> (OSIntNesting &gt; <span class="hljs-number">0</span>) &#123;<br>           OS_EXIT_CRITICAL();<br>           <span class="hljs-keyword">return</span> (OS_ERR_TASK_CREATE_ISR);<br>    &#125;                                                                       <br><span class="hljs-keyword">if</span> (OSTCBPrioTbl[prio] == (OS_TCB *)<span class="hljs-number">0</span>) &#123;<br>           OSTCBPrioTbl[prio] = (OS_TCB *)<span class="hljs-number">1</span>;   <br>           OS_EXIT_CRITICAL();<br>    psp = (OS_STK *)OSTaskStkInit(task, pdata, ptos, <span class="hljs-number">0</span>); <br>    err = OS_TCBInit(prio, psp, (OS_STK *)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>     <span class="hljs-keyword">if</span> (err == OS_NO_ERR) &#123;<br>                OS_ENTER_CRITICAL();<br>                OSTaskCtr++;                                      <br>                OS_EXIT_CRITICAL();<br>                <span class="hljs-keyword">if</span> (OSRunning == TRUE) &#123;   <br>                      OS_Sched();<br>                &#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>            OS_ENTER_CRITICAL();<br>            OSTCBPrioTbl[prio] = (OS_TCB *)<span class="hljs-number">0</span>;<br>            OS_EXIT_CRITICAL();<br>        &#125;<br>        <span class="hljs-keyword">return</span> (err);<br>    &#125;<br>    OS_EXIT_CRITICAL();<br>    <span class="hljs-keyword">return</span> (OS_PRIO_EXIST);<br>&#125;<br>COPY<br></code></pre></td></tr></table></figure><h4 id="装入优先级位图"><a href="#装入优先级位图" class="headerlink" title="装入优先级位图"></a>装入优先级位图</h4><p><strong>用优先级初始化参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">ptcb-&gt;OSTCBY = prio &gt;&gt; <span class="hljs-number">3</span>;                                  <br>ptcb-&gt;OSTCBBitY= OSMapTbl[ptcb-&gt;OSTCBY];<span class="hljs-comment">//掩码表中查询</span><br>ptcb-&gt;OSTCBX = prio &amp; <span class="hljs-number">0x07</span>;<br>ptcb-&gt;OSTCBBitX = OSMapTbl[ptcb-&gt;OSTCBX];COPY<br></code></pre></td></tr></table></figure><p><strong>更新位图</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">OSRdyGrp |= ptcb-&gt;OSTCBBitY;        <br>OSRdyTbl[ptcb-&gt;OSTCBY] |= ptcb-&gt;OSTCBBitX;COPY<br></code></pre></td></tr></table></figure><h3 id="临界区代码保护"><a href="#临界区代码保护" class="headerlink" title="临界区代码保护"></a>临界区代码保护</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span>  OS_CRITICAL_METHOD==1 </span><br>     <span class="hljs-meta">#<span class="hljs-keyword">define</span>  OS_ENTER_CRITICAL()   (Cli()) </span><br>     <span class="hljs-meta">#<span class="hljs-keyword">define</span>  OS_EXIT_CRITICAL()      (Sti())  </span><br><br><span class="hljs-meta">#elseif   OS_CRITICAL_METHOD == 2  </span><br>     <span class="hljs-meta">#<span class="hljs-keyword">define</span>  OS_ENTER_CRITICAL()   (PushAndCli())  </span><br>     <span class="hljs-meta">#<span class="hljs-keyword">define</span>  OS_EXIT_CRITICAL()     (Pop()) </span><br><br><span class="hljs-meta">#elseif   OS_CRITICAL_METHOD == 3  </span><br>     <span class="hljs-meta">#<span class="hljs-keyword">define</span>  OS_ENTER_CRITICAL()  (cpu_sr = OSCPUSaveSR())</span><br>     <span class="hljs-meta">#<span class="hljs-keyword">define</span>  OS_EXIT_CRITICAL()   (OSCPURestoreSR(cpu_sr))</span><br>#endifCOPY<br></code></pre></td></tr></table></figure><h4 id="OS-CRITICAL-METHOD-x3D-x3D-1"><a href="#OS-CRITICAL-METHOD-x3D-x3D-1" class="headerlink" title="OS_CRITICAL_METHOD&#x3D;&#x3D;1"></a>OS_CRITICAL_METHOD&#x3D;&#x3D;1</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/05/18/image-20210518105735334.png" alt="image-20210518105735334"></p><h4 id="OS-CRITICAL-METHOD-x3D-x3D-2"><a href="#OS-CRITICAL-METHOD-x3D-x3D-2" class="headerlink" title="OS_CRITICAL_METHOD&#x3D;&#x3D;2"></a>OS_CRITICAL_METHOD&#x3D;&#x3D;2</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/05/18/image-20210518105921392.png" alt="image-20210518105921392"></p><h4 id="OS-CRITICAL-METHOD-x3D-x3D-3"><a href="#OS-CRITICAL-METHOD-x3D-x3D-3" class="headerlink" title="OS_CRITICAL_METHOD&#x3D;&#x3D;3"></a>OS_CRITICAL_METHOD&#x3D;&#x3D;3</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/05/18/image-20210518105953615.png" alt="image-20210518105953615"></p><h3 id="挂载到就绪队列"><a href="#挂载到就绪队列" class="headerlink" title="挂载到就绪队列"></a>挂载到就绪队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> OS_LOWEST_PRIO &lt;= 63  </span><br>    INT8U  y;<br>    y= OSUnMapTbl[OSRdyGrp];           <br>    OSPrioHighRdy = (INT8U)((y &lt;&lt; <span class="hljs-number">3</span>) + OSUnMapTbl[OSRdyTbl[y]]); COPY<br></code></pre></td></tr></table></figure><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/05/18/image-20210518111852456.png" alt="image-20210518111852456"></p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/05/18/image-20210518111924582.png" alt="image-20210518111924582"></p><h4 id="上下文切换过程"><a href="#上下文切换过程" class="headerlink" title="上下文切换过程"></a>上下文切换过程</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/05/18/image-20210518112053885.png" alt="image-20210518112053885"></p><p><strong>保存上文</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">OSCtxSw:<br>    STMFD   SP!, &#123;LR&#125;   ;PC ----------------------------------------（1）<br>    STMFD   SP!, &#123;R0-R12, LR&#125;   ;R0-R12 LR--------------------------（2）<br>    MRS     R0,  CPSR   ;Push CPSR                      <br>    STMFD   SP!, &#123;R0&#125;   <br>    ;----------------------------------------------------------------------<br>    ;       OSTCBCur-&gt;OSTCBStkPtr = SP<br>    ;-------------------------------------------------------------------<br>    LDR     R0, =OSTCBCur<br>    LDR     R0, [R0]<br>    STR     SP, [R0]COPY<br></code></pre></td></tr></table></figure><p>（1）此时想要保存的<strong>PC</strong>已经变化，正好等于LR。如果直接保存，此时的<strong>PC</strong>指向当前正在执行的代码。</p><p>（2）此时的<strong>LR</strong>内的值具体是什么分两种情况。</p><ul><li><p>主动发起任务切换</p><p>此时两个<strong>LR</strong>的值相等，都保存的是进入上下文切换之前的的<strong>PC</strong>。</p></li><li><p>中断触发任务切换</p><p>第一个<strong>LR</strong>是<strong>IRQ_LR</strong>是进入上下文切换之前的的<strong>PC</strong>，第二个<strong>LR</strong>是<strong>SVC_LR</strong>，是就任务的<strong>LR</strong>。</p></li></ul><p><strong>获取当前最高优先级任务</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">;----------------------------------------------------------------------<br>; OSTCBCur = OSTCBHighRdy;<br>;----------------------------------------------------------------------<br>LDR     R0, =OSTCBHighRdy<br>LDR     R1, =OSTCBCur<br>LDR     R0, [R0]<br>STR     R0, [R1]COPY<br></code></pre></td></tr></table></figure><p>将当前TCP指针指向当前最高优先级任务TCB。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">;----------------------------------------------------------------------<br>; OSPrioCur = OSPrioHighRdy;<br>;----------------------------------------------------------------------<br>LDR           R0, =OSPrioHighRdy<br>LDR           R1, =OSPrioCur<br>LDRB              R0, [R0]<br>STRB              R0, [R1]  COPY<br></code></pre></td></tr></table></figure><p>将当前最高优先级赋值到当前任务优先级。</p><p><strong>恢复现场</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">    ;----------------------------------------------------------------------<br>    ;  OSTCBHighRdy-&gt;OSTCBStkPtr;<br>    ;----------------------------------------------------------------------<br>    LDR     R0, =OSTCBHighRdy                                            <br>    LDR     R0, [R0]<br>    LDR     SP, [R0]<br>    ;----------------------------------------------------------------------<br>    ;Restore New task context<br>    ;----------------------------------------------------------------------<br>    LDMFD   SP!, &#123;R0&#125;   ;POP CPSR<br>    MSR     SPSR_cxsf, R0<br>    LDMFD   SP!, &#123;R0-R12, LR, PC&#125;^<br>COPY<br></code></pre></td></tr></table></figure><p>赋值堆栈指针，指向新任务堆栈，先恢复LR，随即出栈。</p><h3 id="调度点"><a href="#调度点" class="headerlink" title="调度点"></a>调度点</h3><ul><li>中断服务程序结束的时刻。</li><li>运行任务因资源缺乏被阻塞的时刻。</li><li>任务周期的开始或者结束的时刻。</li><li>高优先级任务就绪的时刻。</li></ul><h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><blockquote><p>什么是任务？任务有哪几种状态？任务和线程有什么区别？</p><p>什么是任务切换？</p></blockquote><p>见任务切换相关概念处。</p><blockquote><p>叙述RTOS如何创建一个任务。</p></blockquote><p><strong>初始化栈</strong></p><p>拿到ptos，模拟压栈，顺序。</p><p>满递减堆栈，从高位开始往下生长，最先压任务地址，LR、R12、R11……R0，CPSR，栈顶返回psp</p><p>*(–stk) &#x3D; (int32u) 0;</p><p>弹出的时候，先出cpsr，最后任务地址弹到PC。</p><p><strong>初始化任务TCB</strong></p><p>到临界区，去OSTCBFreeList中申请第一个空白TCB。拿到后，往里面放东西</p><p>同时XY bitX bitY直接使用prio通过优先级表进行定位查找。<br>Y &#x3D; prio &gt;&gt;3（高3位）<br>bitY &#x3D; OSMapTbl[Y]<br>X &#x3D; prio &amp; 0x07（低3位）<br>bitX &#x3D; OSMapTbl[X]</p><p>装完后，用上之前那OSTCBPrioTbl[prio] &#x3D; ptcb 的占位符，然后和OSTCBList里的TCB双向链上（next、prev），作为队首</p><p>然后将OSRdyGrp |&#x3D; bitY 与 OSRdyTbl[Y] |&#x3D; bitX；OStaskCtr++，退出临界区</p><p>OSRdyGrp 表示逻辑上优先级表中有哪些组的优先级有任务就绪。</p><p>OSRdyTbl[]表示某一组的8个优先级中有哪些任务就绪</p><p><strong>初始化TCBList</strong></p><p>先清空OSTCBTbl和OSTCBPrioTbl的空间；</p><p>然后两个OS_TCB指针ptcb1 ptcb2来对OSTCBTbl链Next；</p><p>最后给TCBList &#x3D; (OS_TCB*)0 与TCBFreeList &#x3D; &amp;OSTCBTbl[0]；</p><p>（真实存在的连续数据结构表就只有）TCB、OSTCBTbl，其他的都是在这个里面的指针串起来的数据结构。</p><h2 id="任务调度策略"><a href="#任务调度策略" class="headerlink" title="任务调度策略"></a>任务调度策略</h2><h3 id="提高实时任务响应的措施"><a href="#提高实时任务响应的措施" class="headerlink" title="提高实时任务响应的措施"></a>提高实时任务响应的措施</h3><ul><li>内核可抢占</li><li>调度时间的确定性</li><li>中断处理优化</li><li>数据结构优化</li><li>内存管理的确定性</li></ul><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2021/05/19/image-20210519124332664.png" alt="image-20210519124332664"></p><h2 id="中断和时间管理"><a href="#中断和时间管理" class="headerlink" title="中断和时间管理"></a>中断和时间管理</h2><ul><li>硬中断：传统意义的外部中断，触发的响应属于异步事件</li><li>自陷：软中断，内部中断，内部显式触发</li><li>异常：CPU自动产生的自陷，如被0除，非法访问等……</li></ul><h3 id="中断请求处理方式"><a href="#中断请求处理方式" class="headerlink" title="中断请求处理方式"></a>中断请求处理方式</h3><ul><li>中断作为任务切换</li><li>中断作为系统调用</li><li>中断作为前台任务</li></ul><h3 id="ARM裸板中断机制"><a href="#ARM裸板中断机制" class="headerlink" title="ARM裸板中断机制"></a>ARM裸板中断机制</h3><p>两级中断机制，第一级（异常向量表，里面放的时B xxx指令，发生异常后PC会被强制转到对应的位置取值，然后跳转到二级）：</p><ul><li>复位异常：开发板复位时进入管理模式，屏蔽IRQ和FIQ，进入ARM指令模式，PC强制为0，从0处去指执行</li><li>未定义异常：遇到无法处理的指令时触发，PC强制为0x04</li><li>软中断异常：SWI……PC强制0x08，进管理</li><li>预取指异常：……</li><li>数据终止异常：……</li><li>IRQ：CPU收到外部设备发来的中断请求后，PC强制0x18，进第二级</li><li>FIQ：优先级高于IRQ</li></ul><h4 id="2440前后台系统实现"><a href="#2440前后台系统实现" class="headerlink" title="2440前后台系统实现"></a>2440前后台系统实现</h4><p>外部中断来了，PC被强转到0x18，然后跳转到服务程序，然后执行服务程序。ISR中间涉及清中断的处理。</p><p>中断返回：中断结束后如何返回原程序.</p><ul><li>进入中断的时候LR的值是当前PC+4，中断返回的时候该是LR-4：<code>SUB PC，LR，#4</code></li><li>CPSR存入当前SPSR。</li><li>CPSR设置为相应中断模式（是否屏蔽I位F为）。</li><li>PC强制更新。</li><li>中断注册：多个中断源如何区分？</li></ul><p> 2440有一个寄存器叫<code>INTOFFSET</code>，存中断源分配到的整数，这个整数可以为负数，跳到内部异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">ldr r0,=INTOFFSET<br><br>ldr r0,[r0]<br><br>ldr r1,=HandleEINT0;HandleEINT0是一个内存地址，内容对应一个中断服务程序函数入口<br><br>ldr pc,[r1,r0 lsl #2];进入二级向量表，进行注册COPY<br></code></pre></td></tr></table></figure><ul><li>状态保存与现场恢复</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">ISR<br>    SUB LR,LR,#4 ;减4  四级流水<br>    STMFD SP!,&#123;R0-R12,LR&#125; ;保存现场<br>    MRS R0,SPSR     取spsr<br>    STMFD SP!,&#123;R0&#125;  保存<br>    LDR R0,=INTOFFSET<br>    LDR R0,[R0]<br>    LDR R1,=HandleEINT0<br>    ADD R1,R1,R0 LSL #2<br>    LDR R1,[R1]<br>    MOV LR,PC<br>    MOV PC,R1<br>    LDMFD SP!,&#123;R0&#125;<br>    MSR SPSR_cxsf,R0<br>    LDMFD SP!,&#123;R0-R12,LR&#125;<br>    MOVS PC,LRCOPY<br></code></pre></td></tr></table></figure><h3 id="uCOSII中断管理"><a href="#uCOSII中断管理" class="headerlink" title="uCOSII中断管理"></a>uCOSII中断管理</h3><h4 id="中断发生与响应"><a href="#中断发生与响应" class="headerlink" title="中断发生与响应"></a>中断发生与响应</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs asm">ISR STMDB SP!,&#123;R0-R2&#125;;存r0-r2到当前IRQ模式的堆栈中<br>    MOV R0,SP   ;R0存着SP<br>    ADD SP,SP,#12 ;SP+12留3个位置<br>    SUB R1,LR,#4  ;LR-4放R1<br>    MRS R2,SPSR   ;SPSR放R2<br><br>    MSR CPSE_cxsf，#SVCMODE|NOINT ;转到SVC模式，都是SVC的堆栈<br><br>    STMDB SP!,&#123;R0&#125; ;压IRQ_SP<br>    STMDB SP!,&#123;R3-R12,LR&#125; ;压剩下的到SVC的堆栈<br>    LDMIA R0!,&#123;R3-R5&#125;   ;出原来IRQ的R0-R2到现在SVC的R3-R5<br>    STMDB SP!,&#123;R2-R5&#125;   ;再和前面的SPSR压回SVC的栈<br><br>    LDR R0,=OSIntNesting ;中断嵌套计数<br>    LDR R1,[R0]<br>    ADD R1,R1,#1<br>    STRB R1,[R0]<br>    TEQ R1,#1       ;判断是否是1，，如果是1没嵌套，不是就嵌套了<br>    BNE %F1<br><br>    LDR R0,=OSTCBCur <br>    LDR R0,[R0]<br>    STR SP,[R0]     ;sp给到当前TCB的堆栈顶<br><br>F1  MSR CPSR_c,#IRQMODE|NOINT 出SVC模式，回到IRQ<br><br>    LDR R0,=0X4A000014 <br>    LDR R0,[R0]<br>    LDR R1,=HandleEINT0<br>    MOV LR,PC<br>    LDR PC,[R1,R0 LSL #2] ;向量表偏移后入口指令给PC，然后执行ISR后回来<br><br>    MSR CPSR_c,#SVCMODE|NOINT ;切到SVC<br>    BL OSIntExit    ;中断返回，有调度点<br>    LDR R0,[SP],#4  ;出栈，把状态字出到R0<br>    MSR SPSR_cxsf,R0 ;恢复状态字<br>    LDMIA SP!,&#123;R0-R12,LR,PC&#125;^ ;全部出栈，恢复COPY<br></code></pre></td></tr></table></figure><h4 id="中断返回"><a href="#中断返回" class="headerlink" title="中断返回"></a>中断返回</h4><p>判断是否嵌套，没有嵌套就从就绪队列中找到最高优先级的任务，把TCB给OSTCBHighRdy，进入中断的上下文切换。</p><h3 id="课后习题-1"><a href="#课后习题-1" class="headerlink" title="课后习题"></a>课后习题</h3><blockquote><p>阐述中断的概念，说明中断、自陷、异常之间的区别。</p><p>以一个开源RTOS为例，给出中断的层次结构，并对总流程及关键步骤进行解释。</p><p>开发人员如何在2440的uC环节下实现中断注册？</p><p>裸板中断和uC中断处理有哪些主要区别？</p><p>uC的TimeTick函数主要功能是什么？如何实现差分时间链算法？提供代码</p></blockquote><h2 id="任务的同步与通信"><a href="#任务的同步与通信" class="headerlink" title="任务的同步与通信"></a>任务的同步与通信</h2><h3 id="任务之间的通信、ECB结构与初始化"><a href="#任务之间的通信、ECB结构与初始化" class="headerlink" title="任务之间的通信、ECB结构与初始化"></a>任务之间的通信、ECB结构与初始化</h3><p> ECB是一个单独的连续表结构体<code>OSEventFreeList</code>，每一个ECB和一个优先级（任务绑定）</p><p> <code>OS_EventWaitListInit()</code>：初始化一个ECB的等待队列</p><p> <code>OS_EventTaskRdy()</code>：使一个任务进入就绪状态（从等待队列中删除最高优先级，然后将该任务就绪）</p><p> <code>OS_EventWait()</code>：使一个任务进入事件的等待队列</p><p> <code>OS_EventTo()</code>：因为超时是而使得一个任务进入就绪状态</p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p> 同步信号量（初始0，加）、互斥信号量（初始1，减）、计数信号量（初始n，加减），不支持中断创建信号量。</p><p> <code>OSSemCreate(cnt)</code>：创建一个信号量</p><p> <code>OSSemPend()</code>：获取一个信号量</p><p> <code>OSSemPost()</code>：释放一个信号量</p><p> <code>OSSemAccept()</code>：无等待的获取一个信号量</p><p> <code>OSSemQuery()</code>：查询信号量当前状态</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p> <code>OSMutexCreat()</code> <code>OSMutexAccept()</code> <code>OSMutexDel()</code> <code>OSMutexPend()</code> <code>OSMutexPost()</code> <code>OSMutexQuery()</code></p><h3 id="邮箱机制"><a href="#邮箱机制" class="headerlink" title="邮箱机制"></a>邮箱机制</h3><p> 实现任务之间或者任务与中断之间通信，发送一个指针类型的变量，该指针包含特定消息的数据结构</p><p> <code>OSMboxCreate(*msg)</code> <code>OSMboxDel()</code> <code>OSMboxPend()</code> <code>OSMboxPost()</code> <code>OSMboxAccept()</code> <code>OSMboxQuery()</code></p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p> <code>OSQCreate()</code> <code>OSQPend()</code> <code>OSQPost()</code> <code>OSQPostFront()</code> <code>OSQAccept()</code> <code>OSQFlush()</code> <code>OSQQuery()</code></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs</tag>
      
      <tag>review</tag>
      
      <tag>eos</tag>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC模拟Jetson（Jetpack）运行环境</title>
    <link href="/2021/01/pc2jetpack/"/>
    <url>/2021/01/pc2jetpack/</url>
    
    <content type="html"><![CDATA[<h2 id="硬件平台"><a href="#硬件平台" class="headerlink" title="硬件平台"></a>硬件平台</h2><p>HUAWEI Matebook 14</p><p>CPU：Intel® Core™ i5-8265U CPU @ 1.60GHz × 8</p><p>GPU：GeForce MX250&#x2F;PCIe&#x2F;SSE2 &#x2F; GeForce MX250&#x2F;PCIe&#x2F;SSE2</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/Ubuntu_nvidia/1.png" alt="img"></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>推荐：Ubuntu 18.04 LTS</p><h2 id="Nvidia显卡驱动安装"><a href="#Nvidia显卡驱动安装" class="headerlink" title="Nvidia显卡驱动安装"></a>Nvidia显卡驱动安装</h2><ol><li><p>更换国内的系统源，推荐Aliyun源</p></li><li><p>update, upgrade</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt upgradeCOPY<br></code></pre></td></tr></table></figure></li><li><p>加入N卡驱动源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo add-apt-repository ppa:graphics-drivers/ppa<br>sudo apt-get updateCOPY<br></code></pre></td></tr></table></figure></li><li><p>查看显卡驱动，会列出当前的显卡和可安装的驱动</p></li><li><pre><code class="bash">ubuntu-drivers devicesCOPY<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada"><br>```bash<br>jason@Jason-Matebook:~$ ubuntu-drivers devices<br>== /sys/devices/pci0000:<span class="hljs-number">00</span>/<span class="hljs-number">0000</span>:<span class="hljs-number">00</span>:<span class="hljs-number">1</span>c.<span class="hljs-number">0</span>/<span class="hljs-number">0000</span>:<span class="hljs-number">01</span>:<span class="hljs-number">00.0</span> ==<br>modalias : <span class="hljs-type">pci</span>:v000010DEd00001D13sv000019E5sd00003E0Abc03sc02i00<br>vendor   : <span class="hljs-type">NVIDIA</span> Corporation<br>model    : <span class="hljs-type">GP108M</span> [GeForce MX250]<br>driver   : <span class="hljs-type">nvidia</span>-driver-<span class="hljs-number">440</span> - distro non-free recommended<br>driver   : <span class="hljs-type">nvidia</span>-driver-<span class="hljs-number">435</span> - distro non-free<br>driver   : <span class="hljs-type">xserver</span>-xorg-video-nouveau - distro free builtinCOPY<br></code></pre></td></tr></table></figure></code></pre></li><li><p>直接安装推荐的驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ubuntu-drivers autoinstallCOPY<br></code></pre></td></tr></table></figure></li><li><p>安装完重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo rebootCOPY<br></code></pre></td></tr></table></figure></li><li><p>查看一下显卡信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvidia-smiCOPY<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">Sat Jul 11 11:39:23 2020       <br>+-----------------------------------------------------------------------------+<br>| NVIDIA-SMI 440.100      Driver Version: 440.100      CUDA Version: 10.2     |<br>|-------------------------------+----------------------+----------------------+<br>| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |<br>| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |<br>|===============================+======================+======================|<br>|   0  GeForce MX250       Off  | 00000000:01:00.0 Off |                  N/A |<br>| N/A   46C    P0    N/A /  N/A |    228MiB /  2002MiB |      0%      Default |<br>+-------------------------------+----------------------+----------------------+<br><br>+-----------------------------------------------------------------------------+<br>| Processes:                                                       GPU Memory |<br>|  GPU       PID   Type   Process name                             Usage      |<br>|=============================================================================|<br>|    0       976      G   /usr/lib/xorg/Xorg                            61MiB |<br>|    0      1540      G   /usr/lib/xorg/Xorg                            70MiB |<br>|    0      1784      G   /usr/bin/gnome-shell                          88MiB |<br>+-----------------------------------------------------------------------------+<br>COPY<br></code></pre></td></tr></table></figure></li></ol><p>如果有信息显示出来，就说明安装成功</p><h2 id="环境检查"><a href="#环境检查" class="headerlink" title="环境检查"></a>环境检查</h2><p>1.验证自己的电脑是否有一个可以支持CUDA的GPU：</p><p>你可以在电脑的配置信息中找到显卡的具体型号，如果你是双系统，在windows下的设备管理器中也可以查到显卡的详细信息;在ubuntu下面的话，你可以通过下面这行命令来简单查看一下NVIDIA GPU版本信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">lspci | grep -i nvidia<br><br>jason@Jason-Matebook:~$ lspci | grep -i nvidia<br>01:00.0 3D controller: NVIDIA Corporation GP108M [GeForce MX250] (rev a1)COPY<br></code></pre></td></tr></table></figure><p>2.验证自己的linux版本是否支持CUDA：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -m &amp;&amp; <span class="hljs-built_in">cat</span> /etc/*release<br><br>jason@Jason-Matebook:~$ <span class="hljs-built_in">uname</span> -m &amp;&amp; <span class="hljs-built_in">cat</span> /etc/*release<br>x86_64<br>DISTRIB_ID=Ubuntu<br>DISTRIB_RELEASE=20.04<br>DISTRIB_CODENAME=focal<br>DISTRIB_DESCRIPTION=<span class="hljs-string">&quot;Ubuntu 20.04 LTS&quot;</span><br>NAME=<span class="hljs-string">&quot;Ubuntu&quot;</span><br>VERSION=<span class="hljs-string">&quot;20.04 LTS (Focal Fossa)&quot;</span><br>ID=ubuntu<br>ID_LIKE=debian<br>PRETTY_NAME=<span class="hljs-string">&quot;Ubuntu 20.04 LTS&quot;</span><br>VERSION_ID=<span class="hljs-string">&quot;20.04&quot;</span><br>HOME_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/&quot;</span><br>SUPPORT_URL=<span class="hljs-string">&quot;https://help.ubuntu.com/&quot;</span><br>BUG_REPORT_URL=<span class="hljs-string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br>PRIVACY_POLICY_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br>VERSION_CODENAME=focal<br>UBUNTU_CODENAME=focalCOPY<br></code></pre></td></tr></table></figure><p>3.验证系统是否安装了gcc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc --version<br><br>jason@Jason-Matebook:~$ gcc --version<br>gcc (Ubuntu 9.3.0-10ubuntu2) 9.3.0<br>Copyright (C) 2019 Free Software Foundation, Inc.<br>This is free software; see the <span class="hljs-built_in">source</span> <span class="hljs-keyword">for</span> copying conditions.  There is NO<br>warranty; not even <span class="hljs-keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.COPY<br></code></pre></td></tr></table></figure><p>其实这个刚装完系统的话应该都装好了，但是为了保险起见，你还是可以查看一下，如果你没有安装的话，你可以采取下面的命令对其进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install build-essentialCOPY<br></code></pre></td></tr></table></figure><p>4.验证系统是否安装了kernel header和package development:</p><p>a.查看正在运行的系统内核版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br><br>jason@Jason-Matebook:~$ <span class="hljs-built_in">uname</span> -r<br>5.4.0-40-genericCOPY<br></code></pre></td></tr></table></figure><p>b.安装对应kernel版本的kernel header和package development：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install linux-headers-$(<span class="hljs-built_in">uname</span> -r)<br><br>jason@Jason-Matebook:~$ sudo apt-get install linux-headers-$(<span class="hljs-built_in">uname</span> -r)<br>正在读取软件包列表... 完成<br>正在分析软件包的依赖关系树       <br>正在读取状态信息... 完成       <br>linux-headers-5.4.0-40-generic 已经是最新版 (5.4.0-40.44)。<br>linux-headers-5.4.0-40-generic 已设置为手动安装。<br>升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。COPY<br></code></pre></td></tr></table></figure><p>这个的话表示系统中已经有了，不用重复安装。</p><p>如果以上各项检查均满足要求的话，接下来就可以正式地进入安装界面了，如果有些地方没有满足要求的话，你需要参考cuda的官方文档，里面有详细的针对每个问题的解决方案。在以下链接中可以找到：<a href="https://docs.nvidia.com/cuda/">https://docs.nvidia.com/cuda/</a></p><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p>CUDA11.1安装：<a href="https://developer.nvidia.com/zh-cn/cuda-downloads">CUDA 工具包 11.1 下载 | NVIDIA Developer</a></p><p>根据自己的<strong>操作系统、构架、发行版本、系统版本</strong>选择</p><p>比如我选择的是：Linux-&gt;x86_64-&gt;Ubuntu-&gt;18.04-&gt;deb(network)</p><p>然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/cuda-ubuntu1804.pin<br>sudo <span class="hljs-built_in">mv</span> cuda-ubuntu1804.pin /etc/apt/preferences.d/cuda-repository-pin-600<br>sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pub<br>sudo add-apt-repository <span class="hljs-string">&quot;deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/ /&quot;</span><br>sudo apt-get update<br>sudo apt-get -y install cudaCOPY<br></code></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>输入gedit ~&#x2F;.bashrc命令打开文件，在文件结尾输入以下语句，保存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/usr/local/cuda-11.2/bin<span class="hljs-variable">$&#123;PATH:+:<span class="hljs-variable">$&#123;PATH&#125;</span>&#125;</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/usr/local/cuda-11.2/lib64<span class="hljs-variable">$&#123;LD_LIBRARY_PATH:+:<span class="hljs-variable">$&#123;LD_LIBRARY_PATH&#125;</span>&#125;</span>COPY<br></code></pre></td></tr></table></figure><p>至此cuda安装完成，输入nvcc -V命令查看cuda信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">jason@Jason-Matebook:~$ nvcc -V<br>nvcc: NVIDIA (R) Cuda compiler driver<br>Copyright (c) 2005-2020 NVIDIA Corporation<br>Built on Thu_Jun_11_22:26:38_PDT_2020<br>Cuda compilation tools, release 11.2, V11.2.194<br>Build cuda_11.2_bu.TC445_37.28540450_0COPY<br></code></pre></td></tr></table></figure><h2 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h2><p>cuDNN安装：<a href="https://developer.nvidia.com/rdp/cudnn-download">cuDNN Download | NVIDIA Developer</a></p><p>根据自己的<strong>系统版本</strong>下载deb安装包直接安装。</p><p>例如我下载的是：</p><p><a href="https://developer.nvidia.com/compute/machine-learning/cudnn/secure/8.0.5/11.1_20201106/Ubuntu18_04-x64/libcudnn8_8.0.5.39-1+cuda11.1_amd64.deb">cuDNN Runtime Library for Ubuntu18.04 x86_64 (Deb)</a></p><p><a href="https://developer.nvidia.com/compute/machine-learning/cudnn/secure/8.0.5/11.1_20201106/Ubuntu18_04-x64/libcudnn8-dev_8.0.5.39-1+cuda11.1_amd64.deb">cuDNN Developer Library for Ubuntu18.04 x86_64 (Deb)</a></p><p><a href="https://developer.nvidia.com/compute/machine-learning/cudnn/secure/8.0.5/11.1_20201106/Ubuntu18_04-x64/libcudnn8-samples_8.0.5.39-1+cuda11.1_amd64.deb">cuDNN Code Samples and User Guide for Ubuntu18.04 x86_64 (Deb)</a></p><p>安装顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg -i libcudnn8_8.0.5.39-1+cuda11.1_amd64.deb<br>sudo dpkg -i libcudnn8-dev_8.0.5.39-1+cuda11.1_amd64.deb<br>sudo dpkg -i libcudnn8-samples_8.0.5.39-1+cuda11.1_amd64.debCOPY<br></code></pre></td></tr></table></figure><h2 id="安装cuDNN额外依赖"><a href="#安装cuDNN额外依赖" class="headerlink" title="安装cuDNN额外依赖"></a>安装cuDNN额外依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get upgrade -yCOPY<br></code></pre></td></tr></table></figure><h2 id="安装TensorRT"><a href="#安装TensorRT" class="headerlink" title="安装TensorRT"></a>安装TensorRT</h2><p>TensorRT 7安装：<a href="https://developer.nvidia.com/nvidia-tensorrt-7x-download">NVIDIA TensorRT 7.x Download | NVIDIA Developer</a></p><p>根据自己的<strong>系统版本</strong>和<strong>CUDA版本</strong>下载deb安装包直接安装。</p><p>例如我下载的是：</p><p><a href="https://developer.nvidia.com/compute/machine-learning/tensorrt/secure/7.2.2/local_repos/nv-tensorrt-repo-ubuntu1804-cuda11.1-trt7.2.2.3-ga-20201211_1-1_amd64.deb">TensorRT 7.2.2 for Ubuntu 18.04 and CUDA 11.1 &amp; 11.2 DEB local repo package</a></p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg -i nv-tensorrt-repo-ubuntu1804-cuda11.1-trt7.2.2.3-ga-20201211_1-1_amd64.debCOPY<br></code></pre></td></tr></table></figure><h2 id="安装TensorRT额外依赖"><a href="#安装TensorRT额外依赖" class="headerlink" title="安装TensorRT额外依赖"></a>安装TensorRT额外依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get upgrade -yCOPY<br></code></pre></td></tr></table></figure><h2 id="部署jetson-inference"><a href="#部署jetson-inference" class="headerlink" title="部署jetson-inference"></a>部署jetson-inference</h2><p>详细教程查看：<a href="https://github.com/dusty-nv/jetson-inference">jetson-inference</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get update<br>$ sudo apt-get install git cmake libpython3-dev python3-numpy python3-opencv<br>$ git <span class="hljs-built_in">clone</span> --recursive https://github.com/dusty-nv/jetson-inference<br>$ <span class="hljs-built_in">cd</span> jetson-inference<br>$ <span class="hljs-built_in">mkdir</span> build<br>$ <span class="hljs-built_in">cd</span> build<br>$ cmake ../<br>$ make -j$(<span class="hljs-built_in">nproc</span>)<br>$ sudo make install<br>$ sudo ldconfigCOPY<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>ENV</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>ubuntu</tag>
      
      <tag>nvidia</tag>
      
      <tag>jetpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四轴飞行器设计之系统集成</title>
    <link href="/2020/11/wuhutakeoff-v1-0/"/>
    <url>/2020/11/wuhutakeoff-v1-0/</url>
    
    <content type="html"><![CDATA[<p>项目仓库：<a href="https://github.com/Jason-xy/WuhuTakeOff.git">https://github.com/Jason-xy/WuhuTakeOff.git</a></p><h2 id="目标需求"><a href="#目标需求" class="headerlink" title="目标需求"></a>目标需求</h2><h3 id="1-模块单独运行"><a href="#1-模块单独运行" class="headerlink" title="1.模块单独运行"></a>1.模块单独运行</h3><p> （1）串口能够输出调试信息。</p><p> （2）OLED可以在飞控PCB上显示实时参数。</p><p> （3）单片机可以读取GY-86传感器数据。</p><p> （4）单片机可以控制电机以不同转速转动。</p><p> （5）单片机可以捕获接收机信号。</p><h3 id="2-模块联动"><a href="#2-模块联动" class="headerlink" title="2.模块联动"></a>2.模块联动</h3><p> （1）OLED和串口可以同步输出各项参数。</p><p> （2）将GY-86实时数据作为调试信息输出。</p><p> （3）根据接收机信号来调整电机转速。</p><h3 id="3-用户程序"><a href="#3-用户程序" class="headerlink" title="3.用户程序"></a>3.用户程序</h3><p> （1）系统初始化。</p><p> （2）基础外设初始化。</p><p> （3）硬件模块初始化。</p><p> a.调试信息输出设备初始化。</p><p> b.电机初始化。</p><p> c.传感器初始化。</p><p> d.电机自动解锁。</p><p> e.接收机初始化。</p><p> f.参数显示界面绘制。</p><p> （4）后台程序：参数输出。</p><p> （5）前台程序：串口中断、TIM中断。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="硬件集成方案"><a href="#硬件集成方案" class="headerlink" title="硬件集成方案"></a>硬件集成方案</h3><h4 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h4><p><strong>机械部分（略）：</strong>机架、电机、电调、电池。</p><p><strong>飞控部分：</strong></p><ol><li><p>主控芯片：STM32F411CEU6</p><p>板型：最小系统板。裁剪多余模块，仅留下供系统运行的最小系统，体积小，自定义潜力大。</p><p>优点：Cortex-M4、128K SRAM、512K Flash、100MHz主频、以及丰富的外设接口和较小的体积。</p><p>方便在进一步迭代中运行操作系统，以及添加红外测距、WiFi图传等外设。</p></li><li><p>上位机通讯：WIFI-ESP8266</p><p>优点：数据传输距离远、速度快，可以接入互联网。</p><p>在进一步迭代中方便飞控实现长距离、大数据量上位机传输任务，实现远程OTA固件更新、远程PID参数一键调整，同时还可扩展为WIFI图传、串口接收机、一旦接入互联网即可实现真正意义上的远距离控制等丰富功能。</p></li><li><p>板载参数显示：0.96存I2C OLED小屏幕</p><p>优点：方便在飞控上直接获取实时数据，即便不连接上位机也可以初步了解飞控运行情况。</p></li><li><p>姿态传感器：GY-86</p><p>优点：麻雀虽小，五脏俱全。</p></li><li><p>接收机：FS-IA10B</p><p>优点：提供10通道数据传输，可以实现更多自定义功能。</p></li><li><p>遥控器：Jumper T18</p><p>优点：兼容性以及自定义程度最高的Open TX开源操作系统。</p></li></ol><h4 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h4><p>借助CubeMX快速规划。</p><p>如图所示：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/11/28/image.png" alt="image.png"></p><h4 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h4><p><strong>原理图绘制（扩展板）</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/11/29/image.png" alt="image.png"></p><p>根据CubeMX生成引脚号进行连线即可。</p><p>可以考虑预留调试接口和其他外设的电源接口。</p><p><strong>PCB绘制</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/11/29/imaged5490fa743844796.png" alt="imaged5490fa743844796.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/11/29/imagec3550508fe0875fe.png" alt="imagec3550508fe0875fe.png"></p><p><strong>注意：</strong></p><p>1.布局安排。</p><p>2.封装选择。</p><p>3.器件方向。</p><p>4.特殊网络规则。</p><p><strong>原理图绘制（一体化半成品）</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/11/29/image279a73c0e6f45ec5.png" alt="image279a73c0e6f45ec5.png"></p><h3 id="软件集成方案"><a href="#软件集成方案" class="headerlink" title="软件集成方案"></a>软件集成方案</h3><h4 id="STM32基于HAL库的的软件开发。"><a href="#STM32基于HAL库的的软件开发。" class="headerlink" title="STM32基于HAL库的的软件开发。"></a>STM32基于HAL库的的软件开发。</h4><p>优点：效率高、逻辑性强、资料多、可移植性强。</p><p>缺点：复杂的代码量、极慢的编译速度、略微低下的效率、屏蔽硬件差异，需要挖掘库函数源码才能了解底层运作。</p><h4 id="HAL库软件层级"><a href="#HAL库软件层级" class="headerlink" title="HAL库软件层级"></a>HAL库软件层级</h4><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/11/29/image7478609ec90ffd4a.png" alt="image7478609ec90ffd4a.png"></p><h5 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:.<br>│  F411CEU6_V1.ioc<br>│  tree.txt<br>│  <br>├─Core  <span class="hljs-comment">#用户代码</span><br>│  ├─Inc<br>│  │      gpio.h<br>│  │      i2c.h<br>│  │      main.h<br>│  │      stm32f4xx_hal_conf.h<br>│  │      stm32f4xx_it.h<br>│  │      tim.h<br>│  │      usart.h<br>│  │      <br>│  └─Src<br>│          gpio.c<br>│          i2c.c<br>│          main.c<br>│          stm32f4xx_hal_msp.c<br>│          stm32f4xx_it.c<br>│          system_stm32f4xx.c<br>│          tim.c<br>│          usart.c<br>│          <br>├─Drivers<br>│  |—CMSIS......    <span class="hljs-comment">#硬件抽象层</span><br>│  ├─HW <span class="hljs-comment">#外部硬件模块驱动</span><br>│  │  ├─inc<br>│  │  │      controller.h<br>│  │  │      esp8266.h<br>│  │  │      hmc5883l.h<br>│  │  │      motor.h<br>│  │  │      mpu6050.h<br>│  │  │      oled.h<br>│  │  │      oledfont.h<br>│  │  │      <br>│  │  └─src<br>│  │          controller.c<br>│  │          esp8266.c<br>│  │          hmc5883l.c<br>│  │          motor.c<br>│  │          mpu6050.c<br>│  │          oled.c<br>│  │          <br>│  └─STM32F4xx_HAL_Driver   <span class="hljs-comment">#HAL库文件</span><br>│      ├─Inc<br>│      │  │  stm32f4xx_hal.h<br>│      │  │  stm32f4xx_hal_adc.h<br>│      │  │  stm32f4xx_hal_adc_ex.h<br>│      │  │  stm32f4xx_hal_can.h<br>│      │  │  stm32f4xx_hal_cec.h<br>│      │  │  stm32f4xx_hal_conf_template.h<br>│      │  │  stm32f4xx_hal_cortex.h<br>│      │  │  stm32f4xx_hal_crc.h<br>│      │  │  stm32f4xx_hal_cryp.h<br>│      │  │  stm32f4xx_hal_cryp_ex.h<br>│      │  │  stm32f4xx_hal_dac.h<br>│      │  │  stm32f4xx_hal_dac_ex.h<br>│      │  │  stm32f4xx_hal_dcmi.h<br>│      │  │  stm32f4xx_hal_dcmi_ex.h<br>│      │  │  stm32f4xx_hal_def.h<br>│      │  │  stm32f4xx_hal_dfsdm.h<br>│      │  │  stm32f4xx_hal_dma.h<br>│      │  │  stm32f4xx_hal_dma2d.h<br>│      │  │  stm32f4xx_hal_dma_ex.h<br>│      │  │  stm32f4xx_hal_dsi.h<br>│      │  │  stm32f4xx_hal_eth.h<br>│      │  │  stm32f4xx_hal_exti.h<br>│      │  │  stm32f4xx_hal_flash.h<br>│      │  │  stm32f4xx_hal_flash_ex.h<br>│      │  │  stm32f4xx_hal_flash_ramfunc.h<br>│      │  │  stm32f4xx_hal_fmpi2c.h<br>│      │  │  stm32f4xx_hal_fmpi2c_ex.h<br>│      │  │  stm32f4xx_hal_fmpsmbus.h<br>│      │  │  stm32f4xx_hal_gpio.h<br>│      │  │  stm32f4xx_hal_gpio_ex.h<br>│      │  │  stm32f4xx_hal_hash.h<br>│      │  │  stm32f4xx_hal_hash_ex.h<br>│      │  │  stm32f4xx_hal_hcd.h<br>│      │  │  stm32f4xx_hal_i2c.h<br>│      │  │  stm32f4xx_hal_i2c_ex.h<br>│      │  │  stm32f4xx_hal_i2s.h<br>│      │  │  stm32f4xx_hal_i2s_ex.h<br>│      │  │  stm32f4xx_hal_irda.h<br>│      │  │  stm32f4xx_hal_iwdg.h<br>│      │  │  stm32f4xx_hal_lptim.h<br>│      │  │  stm32f4xx_hal_ltdc.h<br>│      │  │  stm32f4xx_hal_ltdc_ex.h<br>│      │  │  stm32f4xx_hal_mmc.h<br>│      │  │  stm32f4xx_hal_nand.h<br>│      │  │  stm32f4xx_hal_nor.h<br>│      │  │  stm32f4xx_hal_pccard.h<br>│      │  │  stm32f4xx_hal_pcd.h<br>│      │  │  stm32f4xx_hal_pcd_ex.h<br>│      │  │  stm32f4xx_hal_pwr.h<br>│      │  │  stm32f4xx_hal_pwr_ex.h<br>│      │  │  stm32f4xx_hal_qspi.h<br>│      │  │  stm32f4xx_hal_rcc.h<br>│      │  │  stm32f4xx_hal_rcc_ex.h<br>│      │  │  stm32f4xx_hal_rng.h<br>│      │  │  stm32f4xx_hal_rtc.h<br>│      │  │  stm32f4xx_hal_rtc_ex.h<br>│      │  │  stm32f4xx_hal_sai.h<br>│      │  │  stm32f4xx_hal_sai_ex.h<br>│      │  │  stm32f4xx_hal_sd.h<br>│      │  │  stm32f4xx_hal_sdram.h<br>│      │  │  stm32f4xx_hal_smartcard.h<br>│      │  │  stm32f4xx_hal_smbus.h<br>│      │  │  stm32f4xx_hal_spdifrx.h<br>│      │  │  stm32f4xx_hal_spi.h<br>│      │  │  stm32f4xx_hal_sram.h<br>│      │  │  stm32f4xx_hal_tim.h<br>│      │  │  stm32f4xx_hal_tim_ex.h<br>│      │  │  stm32f4xx_hal_uart.h<br>│      │  │  stm32f4xx_hal_usart.h<br>│      │  │  stm32f4xx_hal_wwdg.h<br>│      │  │  stm32f4xx_ll_adc.h<br>│      │  │  stm32f4xx_ll_bus.h<br>│      │  │  stm32f4xx_ll_cortex.h<br>│      │  │  stm32f4xx_ll_crc.h<br>│      │  │  stm32f4xx_ll_dac.h<br>│      │  │  stm32f4xx_ll_dma.h<br>│      │  │  stm32f4xx_ll_dma2d.h<br>│      │  │  stm32f4xx_ll_exti.h<br>│      │  │  stm32f4xx_ll_fmc.h<br>│      │  │  stm32f4xx_ll_fmpi2c.h<br>│      │  │  stm32f4xx_ll_fsmc.h<br>│      │  │  stm32f4xx_ll_gpio.h<br>│      │  │  stm32f4xx_ll_i2c.h<br>│      │  │  stm32f4xx_ll_iwdg.h<br>│      │  │  stm32f4xx_ll_lptim.h<br>│      │  │  stm32f4xx_ll_pwr.h<br>│      │  │  stm32f4xx_ll_rcc.h<br>│      │  │  stm32f4xx_ll_rng.h<br>│      │  │  stm32f4xx_ll_rtc.h<br>│      │  │  stm32f4xx_ll_sdmmc.h<br>│      │  │  stm32f4xx_ll_spi.h<br>│      │  │  stm32f4xx_ll_system.h<br>│      │  │  stm32f4xx_ll_tim.h<br>│      │  │  stm32f4xx_ll_usart.h<br>│      │  │  stm32f4xx_ll_usb.h<br>│      │  │  stm32f4xx_ll_utils.h<br>│      │  │  stm32f4xx_ll_wwdg.h<br>│      │  │  stm32_assert_template.h<br>│      │  │  <br>│      │  └─Legacy<br>│      │          stm32f4xx_hal_can_legacy.h<br>│      │          stm32_hal_legacy.h<br>│      │          <br>│      └─Src<br>│              stm32f4xx_hal.c<br>│              stm32f4xx_hal_adc.c<br>│              stm32f4xx_hal_adc_ex.c<br>│              stm32f4xx_hal_can.c<br>│              stm32f4xx_hal_cec.c<br>│              stm32f4xx_hal_cortex.c<br>│              stm32f4xx_hal_crc.c<br>│              stm32f4xx_hal_cryp.c<br>│              stm32f4xx_hal_cryp_ex.c<br>│              stm32f4xx_hal_dac.c<br>│              stm32f4xx_hal_dac_ex.c<br>│              stm32f4xx_hal_dcmi.c<br>│              stm32f4xx_hal_dcmi_ex.c<br>│              stm32f4xx_hal_dfsdm.c<br>│              stm32f4xx_hal_dma.c<br>│              stm32f4xx_hal_dma2d.c<br>│              stm32f4xx_hal_dma_ex.c<br>│              stm32f4xx_hal_dsi.c<br>│              stm32f4xx_hal_eth.c<br>│              stm32f4xx_hal_exti.c<br>│              stm32f4xx_hal_flash.c<br>│              stm32f4xx_hal_flash_ex.c<br>│              stm32f4xx_hal_flash_ramfunc.c<br>│              stm32f4xx_hal_fmpi2c.c<br>│              stm32f4xx_hal_fmpi2c_ex.c<br>│              stm32f4xx_hal_fmpsmbus.c<br>│              stm32f4xx_hal_gpio.c<br>│              stm32f4xx_hal_hash.c<br>│              stm32f4xx_hal_hash_ex.c<br>│              stm32f4xx_hal_hcd.c<br>│              stm32f4xx_hal_i2c.c<br>│              stm32f4xx_hal_i2c_ex.c<br>│              stm32f4xx_hal_i2s.c<br>│              stm32f4xx_hal_i2s_ex.c<br>│              stm32f4xx_hal_irda.c<br>│              stm32f4xx_hal_iwdg.c<br>│              stm32f4xx_hal_lptim.c<br>│              stm32f4xx_hal_ltdc.c<br>│              stm32f4xx_hal_ltdc_ex.c<br>│              stm32f4xx_hal_mmc.c<br>│              stm32f4xx_hal_msp_template.c<br>│              stm32f4xx_hal_nand.c<br>│              stm32f4xx_hal_nor.c<br>│              stm32f4xx_hal_pccard.c<br>│              stm32f4xx_hal_pcd.c<br>│              stm32f4xx_hal_pcd_ex.c<br>│              stm32f4xx_hal_pwr.c<br>│              stm32f4xx_hal_pwr_ex.c<br>│              stm32f4xx_hal_qspi.c<br>│              stm32f4xx_hal_rcc.c<br>│              stm32f4xx_hal_rcc_ex.c<br>│              stm32f4xx_hal_rng.c<br>│              stm32f4xx_hal_rtc.c<br>│              stm32f4xx_hal_rtc_ex.c<br>│              stm32f4xx_hal_sai.c<br>│              stm32f4xx_hal_sai_ex.c<br>│              stm32f4xx_hal_sd.c<br>│              stm32f4xx_hal_sdram.c<br>│              stm32f4xx_hal_smartcard.c<br>│              stm32f4xx_hal_smbus.c<br>│              stm32f4xx_hal_spdifrx.c<br>│              stm32f4xx_hal_spi.c<br>│              stm32f4xx_hal_sram.c<br>│              stm32f4xx_hal_tim.c<br>│              stm32f4xx_hal_timebase_rtc_alarm_template.c<br>│              stm32f4xx_hal_timebase_rtc_wakeup_template.c<br>│              stm32f4xx_hal_timebase_tim_template.c<br>│              stm32f4xx_hal_tim_ex.c<br>│              stm32f4xx_hal_uart.c<br>│              stm32f4xx_hal_usart.c<br>│              stm32f4xx_hal_wwdg.c<br>│              stm32f4xx_ll_adc.c<br>│              stm32f4xx_ll_crc.c<br>│              stm32f4xx_ll_dac.c<br>│              stm32f4xx_ll_dma.c<br>│              stm32f4xx_ll_dma2d.c<br>│              stm32f4xx_ll_exti.c<br>│              stm32f4xx_ll_fmc.c<br>│              stm32f4xx_ll_fmpi2c.c<br>│              stm32f4xx_ll_fsmc.c<br>│              stm32f4xx_ll_gpio.c<br>│              stm32f4xx_ll_i2c.c<br>│              stm32f4xx_ll_lptim.c<br>│              stm32f4xx_ll_pwr.c<br>│              stm32f4xx_ll_rcc.c<br>│              stm32f4xx_ll_rng.c<br>│              stm32f4xx_ll_rtc.c<br>│              stm32f4xx_ll_sdmmc.c<br>│              stm32f4xx_ll_spi.c<br>│              stm32f4xx_ll_tim.c<br>│              stm32f4xx_ll_usart.c<br>│              stm32f4xx_ll_usb.c<br>│              stm32f4xx_ll_utils.c<br>│              <br>└─MDK-ARM<br>    │  EventRecorderStub.scvd<br>    │  F411CEU6_V1.uvguix.Jason<br>    │  F411CEU6_V1.uvoptx<br>    │  F411CEU6_V1.uvprojx<br>    │  startup_stm32f411xe.lst<br>    │  startup_stm32f411xe.s<br>    │  <br>    ├─DebugConfig<br>    │      F411CEU6_V1_STM32F411CEUx.dbgconf<br>    │      <br>    ├─F411CEU6_V1<br>    │      controller.crf<br>    │      controller.d<br>    │      controller.o<br>    │      esp8266.crf<br>    │      esp8266.d<br>    │      esp8266.o<br>    │      ExtDll.iex<br>    │      F411CEU6_V1.axf<br>    │      F411CEU6_V1.build_log.htm<br>    │      F411CEU6_V1.hex<br>    │      F411CEU6_V1.htm<br>    │      F411CEU6_V1.lnp<br>    │      F411CEU6_V1.map<br>    │      F411CEU6_V1.sct<br>    │      F411CEU6_V1_F411CEU6_V1.dep<br>    │      gpio.crf<br>    │      gpio.d<br>    │      gpio.o<br>    │      hmc5883l.crf<br>    │      hmc5883l.d<br>    │      hmc5883l.o<br>    │      i2c.crf<br>    │      i2c.d<br>    │      i2c.o<br>    │      main.crf<br>    │      main.d<br>    │      main.o<br>    │      motor.crf<br>    │      motor.d<br>    │      motor.o<br>    │      mpu6050.crf<br>    │      mpu6050.d<br>    │      mpu6050.o<br>    │      oled.crf<br>    │      oled.d<br>    │      oled.o<br>    │      startup_stm32f411xe.d<br>    │      startup_stm32f411xe.o<br>    │      stm32f4xx_hal.crf<br>    │      stm32f4xx_hal.d<br>    │      stm32f4xx_hal.o<br>    │      stm32f4xx_hal_cortex.crf<br>    │      stm32f4xx_hal_cortex.d<br>    │      stm32f4xx_hal_cortex.o<br>    │      stm32f4xx_hal_dma.crf<br>    │      stm32f4xx_hal_dma.d<br>    │      stm32f4xx_hal_dma.o<br>    │      stm32f4xx_hal_dma_ex.crf<br>    │      stm32f4xx_hal_dma_ex.d<br>    │      stm32f4xx_hal_dma_ex.o<br>    │      stm32f4xx_hal_exti.crf<br>    │      stm32f4xx_hal_exti.d<br>    │      stm32f4xx_hal_exti.o<br>    │      stm32f4xx_hal_flash.crf<br>    │      stm32f4xx_hal_flash.d<br>    │      stm32f4xx_hal_flash.o<br>    │      stm32f4xx_hal_flash_ex.crf<br>    │      stm32f4xx_hal_flash_ex.d<br>    │      stm32f4xx_hal_flash_ex.o<br>    │      stm32f4xx_hal_flash_ramfunc.crf<br>    │      stm32f4xx_hal_flash_ramfunc.d<br>    │      stm32f4xx_hal_flash_ramfunc.o<br>    │      stm32f4xx_hal_gpio.crf<br>    │      stm32f4xx_hal_gpio.d<br>    │      stm32f4xx_hal_gpio.o<br>    │      stm32f4xx_hal_i2c.crf<br>    │      stm32f4xx_hal_i2c.d<br>    │      stm32f4xx_hal_i2c.o<br>    │      stm32f4xx_hal_i2c_ex.crf<br>    │      stm32f4xx_hal_i2c_ex.d<br>    │      stm32f4xx_hal_i2c_ex.o<br>    │      stm32f4xx_hal_msp.crf<br>    │      stm32f4xx_hal_msp.d<br>    │      stm32f4xx_hal_msp.o<br>    │      stm32f4xx_hal_pwr.crf<br>    │      stm32f4xx_hal_pwr.d<br>    │      stm32f4xx_hal_pwr.o<br>    │      stm32f4xx_hal_pwr_ex.crf<br>    │      stm32f4xx_hal_pwr_ex.d<br>    │      stm32f4xx_hal_pwr_ex.o<br>    │      stm32f4xx_hal_rcc.crf<br>    │      stm32f4xx_hal_rcc.d<br>    │      stm32f4xx_hal_rcc.o<br>    │      stm32f4xx_hal_rcc_ex.crf<br>    │      stm32f4xx_hal_rcc_ex.d<br>    │      stm32f4xx_hal_rcc_ex.o<br>    │      stm32f4xx_hal_tim.crf<br>    │      stm32f4xx_hal_tim.d<br>    │      stm32f4xx_hal_tim.o<br>    │      stm32f4xx_hal_tim_ex.crf<br>    │      stm32f4xx_hal_tim_ex.d<br>    │      stm32f4xx_hal_tim_ex.o<br>    │      stm32f4xx_hal_uart.crf<br>    │      stm32f4xx_hal_uart.d<br>    │      stm32f4xx_hal_uart.o<br>    │      stm32f4xx_it.crf<br>    │      stm32f4xx_it.d<br>    │      stm32f4xx_it.o<br>    │      system_stm32f4xx.crf<br>    │      system_stm32f4xx.d<br>    │      system_stm32f4xx.o<br>    │      tim.crf<br>    │      tim.d<br>    │      tim.o<br>    │      usart.crf<br>    │      usart.d<br>    │      usart.o<br>    │      <br>    └─RTE<br>        └─_F411CEU6_V1<br>                RTE_Components.hCOPY<br></code></pre></td></tr></table></figure><p>文件类型详解参考资料：<a href="https://blog.csdn.net/ZCShouCSDN/article/details/81354197">Keil 项目&#x2F;生成的各种文件类型（.AXF、.D、.crf、.exf）说明</a></p><h4 id="HAL库用户文件"><a href="#HAL库用户文件" class="headerlink" title="HAL库用户文件"></a>HAL库用户文件</h4><p><strong>主函数：</strong>main.c&#x2F;.h</p><p><strong>MSP初始化：</strong> stm32f2xx_hal_msp_template.c ……</p><p><strong>中断服务函数：</strong> stm32f2xx_it.c&#x2F;.h</p><p><strong>硬件模块驱动：</strong>mpu6050.c&#x2F;.h ……</p><h4 id="HAL库用户代码"><a href="#HAL库用户代码" class="headerlink" title="HAL库用户代码"></a>HAL库用户代码</h4><p>HAL 库对底层进行了抽象，在此结构下，用户代码处理可分为三大部分：</p><ul><li><strong>句柄</strong></li><li><strong>MSP</strong></li><li><strong>回调函数</strong></li></ul><h5 id="1-句柄"><a href="#1-句柄" class="headerlink" title="1.句柄"></a><strong>1.句柄</strong></h5><p>在STM32的标准库中，假设我们要初始化一个外设（这里以USART为例）<br>我们首先要初始化他们的各个寄存器。在标准库中，这些操作都是利用固件库结构体变量+固件库Init函数实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">USART_InitTypeDef USART_InitStructure;<br><br>USART_InitStructure.USART_BaudRate = bound;<span class="hljs-comment">//串口波特率</span><br>USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="hljs-comment">//字长为8位数据格式</span><br>USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="hljs-comment">//一个停止位</span><br>USART_InitStructure.USART_Parity = USART_Parity_No;<span class="hljs-comment">//无奇偶校验位</span><br>USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="hljs-comment">//无硬件数据流控制</span><br>USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; <span class="hljs-comment">//收发模式</span><br><br>USART_Init(USART3, &amp;USART_InitStructure); <span class="hljs-comment">//初始化串口1COPY</span><br></code></pre></td></tr></table></figure><p>可以看到，要初始化一个串口，需要对六个位置进行赋值，然后引用Init函数，并且USART_InitStructure并不是一个全局结构体变量，而是只在函数内部的局部变量，初始化完成之后，USART_InitStructure就失去了作用。</p><p>而在HAL库中，同样是USART初始化结构体变量，我们要定义为全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">UART_HandleTypeDef UART1_Handler;   <span class="hljs-comment">//串口处理结构体COPY</span><br></code></pre></td></tr></table></figure><p>相关结构体成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>      USART_TypeDef                 *Instance;        <span class="hljs-comment">/*!&lt; UART registers base address        */</span><br>      UART_InitTypeDef              Init;             <span class="hljs-comment">/*!&lt; UART communication parameters      */</span><br>      <span class="hljs-type">uint8_t</span>                       *pTxBuffPtr;      <span class="hljs-comment">/*!&lt; Pointer to UART Tx transfer Buffer */</span><br>      <span class="hljs-type">uint16_t</span>                      TxXferSize;       <span class="hljs-comment">/*!&lt; UART Tx Transfer size              */</span><br>      <span class="hljs-type">uint16_t</span>                      TxXferCount;      <span class="hljs-comment">/*!&lt; UART Tx Transfer Counter           */</span><br>      <span class="hljs-type">uint8_t</span>                       *pRxBuffPtr;      <span class="hljs-comment">/*!&lt; Pointer to UART Rx transfer Buffer */</span><br>      <span class="hljs-type">uint16_t</span>                      RxXferSize;       <span class="hljs-comment">/*!&lt; UART Rx Transfer size              */</span><br>      <span class="hljs-type">uint16_t</span>                      RxXferCount;      <span class="hljs-comment">/*!&lt; UART Rx Transfer Counter           */</span>  <br>      DMA_HandleTypeDef             *hdmatx;          <span class="hljs-comment">/*!&lt; UART Tx DMA Handle parameters      */</span> <br>      DMA_HandleTypeDef             *hdmarx;          <span class="hljs-comment">/*!&lt; UART Rx DMA Handle parameters      */</span><br>      HAL_LockTypeDef               Lock;             <span class="hljs-comment">/*!&lt; Locking object                     */</span><br>      __IO HAL_UART_StateTypeDef    State;            <span class="hljs-comment">/*!&lt; UART communication state           */</span><br>      __IO <span class="hljs-type">uint32_t</span>                 ErrorCode;        <span class="hljs-comment">/*!&lt; UART Error code                    */</span><br>&#125;UART_HandleTypeDef;COPY<br></code></pre></td></tr></table></figure><p>我们发现，与标准库不同的是，该成员不仅包含了之前标准库就有的六个成员（波特率，数据格式等），还包含过采样、（发送或接收的）数据缓存、数据指针、串口 DMA 相关的变量、各种标志位等等要在整个项目流程中都要设置的各个成员。</p><p>该 <strong>UART1_Handler</strong> 就被称为串口的<strong>句柄</strong><br>它被贯穿整个USART收发的流程，比如开启中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_UART_Receive_IT</span><span class="hljs-params">(&amp;UART1_Handler, (u8 *)aRxBuffer, RXBUFFERSIZE)</span>;COPY<br></code></pre></td></tr></table></figure><p>比如后面要讲到的MSP与Callback回调函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_MspInit</span><span class="hljs-params">(UART_HandleTypeDef *huart)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_RxCpltCallback</span><span class="hljs-params">(UART_HandleTypeDef *huart)</span>;COPY<br></code></pre></td></tr></table></figure><p>在这些函数中，只需要调用初始化时定义的句柄UART1_Handler就好。</p><h5 id="2-MSP函数"><a href="#2-MSP函数" class="headerlink" title="2.MSP函数"></a>2.MSP函数</h5><p>MCU Specific Package 单片机的具体方案</p><p><strong>MSP是指和MCU相关的初始化：</strong><br>1.一部分是与MCU无关的，协议层。<br>2.一部分是与MCU相关的，物理层。</p><p><strong>举个例子：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">我们要初始化一个串口，首先要设置和 MCU 无关的东西，例如波特率，奇偶校验，停止位等，这些参数设置和 MCU 没有任何关系，可以使用 STM32F1，也可以是 STM32F2/F3/F4/F7上的串口。<br>而一个串口设备它需要一个 MCU 来承载，例如用 STM32F4 来做承载，PA9 做为发送，PA10 做为接收，MSP 就是要初始化 STM32F4 的 PA9,PA10，配置这两个引脚。所以 HAL驱动方式的初始化流程就是：HAL_USART_Init()—&gt;HAL_USART_MspInit() ，先初始化与 MCU无关的串口协议，再初始化与 MCU 相关的串口引脚。<br>在 STM32 的 HAL 驱动中HAL_PPP_MspInit()作为回调，被HAL_PPP_Init()函数所调用。当我们需要移植程序到 STM32F1平台的时候，我们只需要修改 HAL_PPP_MspInit 函数内容而不需要修改 HAL_PPP_Init 入口参数内容。COPY<br></code></pre></td></tr></table></figure><p><strong>优点：</strong>可移植性强。</p><p><strong>缺点：</strong>增加代码量、增加代码嵌套层级。</p><p><strong>同样，MSP函数又可以配合句柄，达到非常强的移植性：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_MspInit</span><span class="hljs-params">(UART_HandleTypeDef *huart)</span>;COPY<br></code></pre></td></tr></table></figure><p>入口参数仅仅需要一个串口句柄，这样有能看出句柄的方便。</p><h5 id="3-Callback函数"><a href="#3-Callback函数" class="headerlink" title="3.Callback函数"></a>3.Callback函数</h5><p>类似于MSP函数，Callback函数主要帮助用户<strong>应用层</strong>的代码编写。<br>还是以USART为例，在标准库中，串口触发中断了以后，我们要先在中断中判断是否是接收中断，然后读出数据，顺便清除中断标志位，然后再是对数据的处理，这样如果我们在一个中断函数中写这么多代码，就会显得很混乱：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">USART3_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>    <span class="hljs-comment">//串口1中断服务程序</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> Res;<br>    <span class="hljs-keyword">if</span>(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)   <span class="hljs-comment">//接收中断(接收到的数据必须是0x0d 0x0a结尾)</span><br>    &#123;<br>        Res =USART_ReceiveData(USART3); <span class="hljs-comment">//读取接收到的数据</span><br>        <span class="hljs-comment">/*数据处理区*/</span><br>        &#125;            <br>     &#125; <br>&#125; COPY<br></code></pre></td></tr></table></figure><p>而在HAL库中，进入串口中断后，直接由HAL库中断函数进行托管：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">USART1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>                    <br>&#123; <br>    HAL_UART_IRQHandler(&amp;UART1_Handler);    <span class="hljs-comment">//调用HAL库中断处理公用函数</span><br>    <span class="hljs-comment">/***************省略无关代码****************/</span> <br>&#125;COPY<br></code></pre></td></tr></table></figure><p>HAL_UART_IRQHandler这个函数完成了判断是哪个中断（接收？发送？或者其他？），然后读出数据，保存至缓存区，顺便清除中断标志位等等操作。<br>比如我提前设置了，串口每接收五个字节，我就要对这五个字节进行处理。<br>在一开始我定义了一个串口接收缓存区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*HAL库使用的串口接收缓冲,处理逻辑由HAL库控制，接收完这个数组就会调用HAL_UART_RxCpltCallback进行处理这个数组*/</span><br><span class="hljs-comment">/*RXBUFFERSIZE=5*/</span><br><span class="hljs-type">uint8_t</span> aRxBuffer[RXBUFFERSIZE];COPY<br></code></pre></td></tr></table></figure><p>在初始化中，我在句柄里设置好了缓存区的地址，缓存大小（五个字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*该代码在HAL_UART_Receive_IT函数中，初始化时会引用*/</span><br>    huart-&gt;pRxBuffPtr = pData;<span class="hljs-comment">//aRxBuffer</span><br>    huart-&gt;RxXferSize = Size;<span class="hljs-comment">//RXBUFFERSIZE</span><br>    huart-&gt;RxXferCount = Size;<span class="hljs-comment">//RXBUFFERSIZECOPY</span><br></code></pre></td></tr></table></figure><p>则在接收数据中，每接收完五个字节，HAL_UART_IRQHandler才会执行一次<strong>Callback</strong>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_RxCpltCallback</span><span class="hljs-params">(UART_HandleTypeDef *huart)</span>;COPY<br></code></pre></td></tr></table></figure><p>在这个Callback回调函数中，我们只需要对这接收到的五个字节（保存在aRxBuffer[]中）进行处理就好了，完全不用再去手动清除标志位等操作。<br>所以说Callback函数是一个应用层代码的函数，我们在一开始只设置句柄里面的各个参数，然后就等着HAL库把自己安排好的代码执行完毕就行了。</p><h4 id="HAL库编程方式"><a href="#HAL库编程方式" class="headerlink" title="HAL库编程方式"></a>HAL库编程方式</h4><p>在 HAL 库中对外设模型进行了统一，支持三种编程方式：</p><ul><li><strong>轮询模式&#x2F;阻塞模式</strong></li><li><strong>中断方式</strong></li><li><strong>DMA模式</strong></li></ul><p>以IIC为例，三种编程模式对应的函数如下：</p><p><strong>1、轮询模式&#x2F;阻塞模式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Master_Transmit</span><span class="hljs-params">()</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Master_Receive</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Slave_Transmit</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Slave_Receive</span><span class="hljs-params">()</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Mem_Write</span><span class="hljs-params">()</span>;    <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Mem_Read</span><span class="hljs-params">()</span>;   <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_IsDeviceReady</span><span class="hljs-params">()</span>;COPY<br></code></pre></td></tr></table></figure><p><strong>2、中断模式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Master_Transmit_IT</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Master_Receive_IT</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Slave_Transmit_IT</span><span class="hljs-params">()</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Slave_Receive_IT</span><span class="hljs-params">()</span>;    <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Mem_Write_IT</span><span class="hljs-params">()</span>;    <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Mem_Read_IT</span><span class="hljs-params">()</span>;COPY<br></code></pre></td></tr></table></figure><p><strong>3、DMA模式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Master_Transmit_DMA</span><span class="hljs-params">()</span>;   <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Master_Receive_DMA</span><span class="hljs-params">()</span>;   <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Slave_Transmit_DMA</span><span class="hljs-params">()</span>;    <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Slave_Receive_DMA</span><span class="hljs-params">()</span>;    <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Mem_Write_DMA</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">HAL_I2C_Mem_Read_DMA</span><span class="hljs-params">()</span>;COPY<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Robotics</category>
      
      <category>System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>robotic</tag>
      
      <tag>drone</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理复习</title>
    <link href="/2020/11/csp-review/"/>
    <url>/2020/11/csp-review/</url>
    
    <content type="html"><![CDATA[<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="冯诺依曼体系"><a href="#冯诺依曼体系" class="headerlink" title="冯诺依曼体系"></a>冯诺依曼体系</h3><p>冯·诺依曼结构的特点是： <strong>计算机硬件系统由五大部件（存储器、运算器、控制器、输入设备和输出设备）组成</strong>；<strong>计算机中采用二进制形式表示信息</strong>；<strong>采用存储程序的工作方式</strong> 。</p><blockquote><p><strong>冯诺依曼思想包含三个方面</strong>？</p><p>计算机硬件系统由五大部件（存储器、运算器、控制器、输入设备和输出设备）组成；计算机中采用二进制形式表示信息；采用存储程序的工作方式 。</p></blockquote><h3 id="计算机及硬件系统"><a href="#计算机及硬件系统" class="headerlink" title="计算机及硬件系统"></a>计算机及硬件系统</h3><p>计算机硬件系统由 <strong>CPU</strong> 、 <strong>存储器</strong> 、 <strong>输入&#x2F;输出设备</strong> 、 <strong>总线</strong> 、 <strong>接口</strong> 部件组成。</p><h3 id="计算机软件系统"><a href="#计算机软件系统" class="headerlink" title="计算机软件系统"></a>计算机软件系统</h3><p>软件系统分为 <strong>系统软件</strong> 和 <strong>应用软件</strong> 两大类。</p><blockquote><p><strong>编译方式和解释方式对源程序处理有什么区别</strong>？</p><p>1、编译程序是整体编译完了，再一次性执行。</p><p>2、而解释程序是一边解释，一边执行。</p><p>3、编译器是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快。</p><p>4、而解释器则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的。</p><p><strong>汇编程序、汇编语言（汇编源程序）</strong></p><p><strong>控制流驱动和数据流驱动</strong></p><p>控制流驱动方式：即，指令控制数据，执行指令即可进行相关操作。著名的冯诺依曼机就是这种模式。</p><p>数据流驱动方式：需要的数据准备齐全即可执行操作.</p></blockquote><h3 id="计算机性能的主要评价指标"><a href="#计算机性能的主要评价指标" class="headerlink" title="计算机性能的主要评价指标"></a>计算机性能的主要评价指标</h3><h4 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h4><p><strong>基本字长：</strong>处理器中参加一次定点计算的操作数的位数。</p><p><strong>外频：</strong>主板上振荡器输出的时钟频率。</p><p><strong>存储字长（按字节&#x2F;字&#x2F;双字节编址）：</strong>存储单元的位数。MDR的位数反映了存储字长。</p><p><strong>存储单元的个数：</strong>存储器中存储单元的个数。MAR的位数反映了存储单元的个数。 如果MAR为N位，则存储单元的个数为2的N次幂。</p><p><strong>地址线条数：</strong>决定了存储单元的最大寻址范围，决定了MAR的位数和存储单元个数。</p><p><strong>存储容量：</strong>存储容量&#x3D;存储单元的个数*存储字长。单位B（byte）。</p><p><strong>指令字长：</strong>一条指令中包含的二进制代码的位数。指令字长一般是存储字长的整数倍，如果指令字长等于存储字长的2倍，需要2次访存来取出指令，因此，取指周期是机器周期的2倍。</p><blockquote><p><strong>某主存总容量为64MB，按字编址，需要多少条地址线，MAR位数是多少？</strong></p><p><strong>若数据传输指令的元和目的操作数都采用变址寻址，指令字长为48bit（包含形式地址），数据总线和地址总线为16bit，则该指令的执行需要从存储器取指令、取源操作数，并送到目的存储单元，需要多少次访存？</strong></p></blockquote><h4 id="CPU综合性能"><a href="#CPU综合性能" class="headerlink" title="CPU综合性能"></a>CPU综合性能</h4><p><strong>主频：</strong>CPU内核工作频率。</p><p><strong>平均每秒执行指令数IPS</strong></p><p><strong>平均每条指令的时钟周期数CPI</strong></p><p><strong>每秒执行定点&#x2F;浮点运算的次数FLOPS</strong>（标志系统性能）</p><p><strong>CPU功耗P：</strong>P&#x3D;CU^2f</p><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p><strong>数据通路宽度：</strong>总线一次能并行传输的数据位数。</p><p><strong>数据传输率DTR：</strong>单位时间内信道的数据传输量。DTR &#x3D; Wf(bps)</p><p>W:数据通路宽度</p><p>f：工作频率</p><h2 id="数据的表示、运算和校验"><a href="#数据的表示、运算和校验" class="headerlink" title="数据的表示、运算和校验"></a>数据的表示、运算和校验</h2><h3 id="数值型数据"><a href="#数值型数据" class="headerlink" title="数值型数据"></a>数值型数据</h3><h4 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h4><h4 id="带符号数的表示"><a href="#带符号数的表示" class="headerlink" title="带符号数的表示"></a>带符号数的表示</h4><p> <strong>原码：</strong></p><p> 最高位是符号位**+：0<strong>；</strong>-：1**。</p><p> 范围：-127~+127</p><p> <strong>补码：</strong></p><p> 整数的补码：与原码相同。</p><p> 负数的补码：符号位为1，其余各位取反，在末位加一。</p><p> 范围：-128~+127</p><blockquote><p>( X + Y )补 &#x3D; X补 + Y补 （1）<br>( X – Y )补 &#x3D; X补 + (-Y)补 （2）</p></blockquote><p> <strong>反码：</strong></p><p> 正数的反码：与原码相同。</p><p> 负数的反码：符号位为1，其余各位变反。</p><p> 范围：-127~+127</p><p> <strong>移码：</strong></p><p> 正数的移码:与原码相同。</p><p> 负数的移码：补码的符号位取反。</p><blockquote><p>1)若寄存器的内容为111111，若它等于-1，则为（B）<br>A、原码 B、补码 C、反码 D、移码</p><p>2)若寄存器的内容为11111111，若它的真值为+127，则机器数为（D）<br>A、反码 B、补码 C、原码 D、移码</p></blockquote><h3 id="浮点数与-定点数"><a href="#浮点数与-定点数" class="headerlink" title="浮点数与 定点数"></a>浮点数与 定点数</h3><h3 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h3><p>IEE754表示法，掌握十进制和IEEE754（32位）之间的相互转换。<br>浮点数的表示方法（数符、尾数、阶码、阶符、尾数规格化）</p><h3 id="定点加减运算"><a href="#定点加减运算" class="headerlink" title="定点加减运算"></a>定点加减运算</h3><p>算术移位、逻辑移位规则、溢出判断规则</p><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a><strong>逻辑移位</strong></h4><p>对于逻辑移位，就是不考虑符号位，移位的结果只是数据所有的位数进行移位。根据移位操作的目的，左移时，低位补0，右移时，高位补0。</p><h4 id="算术移位"><a href="#算术移位" class="headerlink" title="算术移位"></a><strong>算术移位</strong></h4><p>算术是带有符号的数据，所以我们不能直接移动所有的位数，这可能会使得符号不正确。</p><p><strong>负数补码移位</strong></p><p>数符不变 （单：符号位不变；双：第1符号位不变)</p><p>左移空位补0</p><p>右移空位补1 （第二符号位移至尾数最高位）</p><blockquote><p><strong>一个很重要的知识：</strong><br>关于数的移位，特别需要注意正数，三码相同，所以无论左移还是右移都是补0.而负数的补码就需要注意，左移在右边补0，右移需要在左边补1，有一个很有趣的误区是，认为符号位保持不变，仅仅移动数据位，这是不对的，因为无论数据位还是符号位，都是二进制，在整体大迁移的过程中，符号位也是要跟随潮流的。只不过，为了保证右移后，和原来的符号数一样，因此，负数在右移时左边补1。</p></blockquote><h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><p><strong>溢出：</strong>运算结果超出机器数的表示范围。</p><p><strong>正溢：</strong>两正数相加绝对值超出允许的表示范围。</p><p><strong>负溢：</strong>两负数相加绝对值超出允许的表示范围。</p><p>数A有4位尾数，1位符号<strong>SA</strong></p><p>数B有4位尾数，1位符号<strong>SB</strong></p><p>结果符号<strong>Sf</strong></p><p>符号位进位<strong>Cf</strong></p><p>尾数最高位进位<strong>C</strong></p><p><strong>硬件判断逻辑一（SA SB Sf的关系）</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/11/05/9.jpg" alt="9.jpg"></p><p><strong>硬件判断逻辑二（Cf 与 C的关系）</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/11/05/3.jpg" alt="3.jpg"></p><p><strong>硬件判断逻辑三（双符号位）</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/11/05/2.jpg" alt="2.jpg"></p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><h2 id="CPU子系统"><a href="#CPU子系统" class="headerlink" title="CPU子系统"></a>CPU子系统</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="运算部件（多路选择器、锁存器）"><a href="#运算部件（多路选择器、锁存器）" class="headerlink" title="运算部件（多路选择器、锁存器）"></a><strong>运算部件</strong>（多路选择器、锁存器）</h4><h4 id="数据缓存部件（Cache-L1、L2、L3）"><a href="#数据缓存部件（Cache-L1、L2、L3）" class="headerlink" title="数据缓存部件（Cache L1、L2、L3）"></a><strong>数据缓存部件</strong>（Cache L1、L2、L3）</h4><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h4><blockquote><p>各种寄存器的作用（R0~R3、PSW 、PC、SP 、IR 、MAR、MDR、C、D）：哪些是可编程寄存器，哪些是不能编程访问的。</p></blockquote><h4 id="控制部件"><a href="#控制部件" class="headerlink" title="控制部件"></a><strong>控制部件</strong></h4><p>（1）控制部件的输入信号包括 <strong>IR</strong>、<strong>PSW</strong>、<strong>PC</strong>、<strong>时序系统</strong>、<strong>I&#x2F;O请求</strong>、<strong>复位信号</strong>。</p><p>（2）按照微命令产生方式，控制器分为<strong>组合逻辑控制器</strong>和<strong>微程序控制器</strong>。</p><p>（3）一般指令的读取和执行分为<strong>取指令</strong>、<strong>取源操作数</strong>、<strong>取目的操作数</strong>、<strong>执行</strong>阶段。</p><p>（4）微命令：在计算机中用来控制微操作（如逻辑门的开或关、寄存器的打入或清除等操作）的控制命令称为微命令，也称为微操作控制信号。</p><p>（5）组合逻辑控制：简单地讲，<strong>由硬连逻辑电路产生微命令</strong>的方式称为组合逻辑控制方式。它的基本思想如下：<br>综合、化简产生微命令的条件，形成相应逻辑式，并用组合逻辑电路实现；执行指令时，由组合逻辑电路(微命令发生器)在相应时间发出所需微命令，控制有关操作。</p><p>（6）微程序控制：简单地讲，<strong>由微指令译码产生微命令</strong>的方式称为微程序控制方式。它的基本思想如下：<br>将若干微命令编制成一条微指令，控制实现一步操作；将若干微指令组成一段微程序，解释执行一条机器指令；将微程序事先存放在控制存储器中，执行机器指令时再取出。</p><h4 id="时序部件"><a href="#时序部件" class="headerlink" title="时序部件"></a>时序部件</h4><p>（1）时序信号：周期、节拍、脉冲<br>（2）时序系统：产生时序信号的部件，由1个低频振荡器和倍频逻辑组成<br>（3）指令周期、工作周期、总线周期、时钟周期、时钟信号<br>（4）同步控制、异步控制、扩展同步控制</p><h4 id="数据通路和控制通路"><a href="#数据通路和控制通路" class="headerlink" title="数据通路和控制通路"></a>数据通路和控制通路</h4><p>（1）分立寄存器的CPU数据通路</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/11/05/06.jpg" alt="06.jpg"></p><p>（2）集成寄存器结构的CPU数据通路</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/11/05/44.jpg" alt="44.jpg"></p><blockquote><p>1、PSW寄存器的特征位是程序员设置的（ ）<br>x</p><p>2、MAR寄存器是采用双向三态门或者OC组件构成。（ ）<br>x</p><p>3、暂存器C用于存放源操作数或者源操作数地址，暂存器D存放目的操作数或者目的操作数地址（ ）<br>v</p><p>4、IR寄存器适用于存放当前指令地址（ ）<br>x</p><p>5、现代微处理器缓存采用三级缓存L1、L2和L3，三级缓存都部署与CPU内部。（ ）<br>v</p><p>6、CM属于CPU的一部分（ ）<br>V</p><p>7、时序系统里面有一个启停控制逻辑，它的作用是<br><strong>保证可靠的送出完整脉冲，并且产生一个总清信号&#x2F;复位信号，对计算机相关部件进行初始化。</strong></p><p>8、晶体振荡器产生的时钟频率低于CPU的主频（ ）<br>V</p><p>9、同步控制的同一时序信号都由CPU产生（）<br>x</p><p>10、同步控制的时钟周期长度固定不变（）<br>v</p><p>11、异步控制方式是指（）<br>各项操作不受统一时序信号【如时钟周期】的约束，各部件之间数据传输采用应答方式。</p><p>12、扩展同步控制根据实际时间分配时钟周期数，时钟周期长度不变（ ）<br>V</p><p>13、计算机工作的最小时间周期是（ ）<br>A、时钟周期 B、指令周期 C、总线周期 D、工作脉冲<br>D</p><p>14、时序控制方式中，有一种方式，是总线周期中允许插入延长周期，其含义是（ ）<br>A、将一个总线周期延长为多个总线周期<br>B、在一个时钟周期内插入新的总线周期<br>C、在总线周期内增加新的总线周期<br>D、在一个总线周期内，延长时钟周期长度<br>B</p></blockquote><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p>简化地址结构、操作码（固定操作码、扩展操作码、复合型操作码）</p><p><strong>（1）简化地质结构的基本途径</strong><br>在指令中减少显地址的数量，即使用隐地址方式给出地址，指令中的地址（段）个数就可减少。</p><p><strong>（2）减少指令中地址信息的位数的方法</strong><br>采用寄存器寻址、寄存器间址等以寄存器为基础的寻址方式可以大大减少指令中一个地址的信息位数。</p><p><strong>（3）显地址</strong><br>在指令代码中明显给出的地址，如在指令中写明操作数的主存单元地址或寄存器号，则这种地址称为显地址。</p><p><strong>（4）隐地址</strong><br>在指令中不明显给出地址码，地址以隐含方式约定，这种隐含约定的地址称为隐地址。</p><blockquote><p><strong>1、指令长度和机器字长有什么关系？ 半字长指令、单字长指令、双字长指令分别表示什么意思？</strong><br>解：指令长度与机器字长没有固定的关系，指令长度可以等于机器字长，也可以大于或小于机器字长。通常，把指令长度等于机器字长的指令称为单字长指令；指令长度等于半个机器字长的指令称为半字长指令；指令长度等于两个机器字长的指令称为双字长指令。</p><p><strong>2、假设指令系统的指令字长16位，地址位4位，若两地址指令需要12条，单地址指令需要12条，那么零地址指令最多有（ ）条。</strong><br>256</p></blockquote><h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><p>指令中以什么方式提供操作数或操作数地址，称为寻址方式。</p><p><strong>立即寻址：</strong>由指令直接给出操作数，在取出指令的同时也就取出了可以立即使用的操作数，这种寻址方式称为立即寻址。</p><p><strong>直接寻址：</strong>由指令直接给出操作数地址，根据该地址可以从主存（或寄存器）中取出操作数，或向主存（或寄存器）写入数据，这种寻址方式称为直接寻址。</p><p><strong>寄存器寻址：</strong>在指令中给出寄存器号，从该寄存器号所指的寄存器中取出操作数或将数据传送到该寄存器号所指的寄存器中。这种寻址方式实为寄存器直接寻址。</p><p><strong>间接寻址：</strong>在指令中给出间址单元地址码（即操作数地址的存放单元地址），按照该地址访问主存中该间址单元，从中读取操作数地址，接着按操作数地址再次访问主存，从该单元中读取或向该单元写入操作数。</p><p><strong>寄存器间址：</strong>由指令给出寄存器号，在该寄存器号所指定的寄存器中存放着操作数地址，按此地址访问主存，读取或写入操作数。</p><p><strong>间址单元：</strong>在间接寻址方式中，存放操作数地址的主存编址单元称为间址单元。</p><p><strong>变址寻址：</strong>在指令中的地址部分给出一个形式地址，并且指定一个寄存器作为变址寄存器，将变址寄存器的内容（称为变址量）与形式地址相加，得到操作数地址（称为有效地址）；按有效地址访问主存，从相应的主存单元中读得操作数或向该单元写入数据。</p><p><strong>基址寻址：</strong>在指令中给出一个形式地址（作为位移量），并且指定一个寄存器作为基址寄存器（该基址寄存器内容作为基准地址）；将基址寄存器内容和形式地址相加，其和作为操作数有效地址；按有效地址访问主存，从该单元读取操作数或向该单元写入数据。</p><p><strong>相对寻址：</strong>指用程序计数器PC的内容作为基准地址，指令中给出的形式地址作为位移量的基址寻址方式。</p><p><strong>页面寻址：</strong>将程序计数器PC的高位段作为操作数有效地址的高位段，指令中给出的形式地址作为操作数有效地址的低位段，将这两部分拼接构成操作数有效地址，这种寻址方式称为页面寻址方式。</p><p><strong>堆栈：</strong><br>一种按“后进先出”（或称“先进后出”）存取顺序进行存取的存储结构。<br><strong>a）栈顶：</strong>堆栈是一个连续的存储区，其一端固定称为栈底，存放最先压入的数；堆栈的另一端是浮动的，称为栈顶，对堆栈的读写都是对栈顶单元进行的；对堆栈的寻址也就是对栈顶单元的寻址，随着堆栈操作的进行，栈顶位置也发生变化。<br><strong>b）堆栈指针：</strong>指用于指向栈顶位置的寄存器SP，堆栈指针SP的内容是栈顶单元地址。</p><blockquote><p><strong>模型机：</strong>双重间址@(R)+、变址X(R)</p><p><strong>1、若某个主存储器部分的地址单元与主存内容对应关系如下：</strong><br><strong>地址码 存储内容</strong><br><strong>1000H A307H</strong><br><strong>1001H 0B3FH</strong><br><strong>1002H 1200H</strong><br><strong>1003H F03CH</strong><br><strong>1004H D024H</strong><br><strong>（1）若采用寄存器间接寻址方式读取操作数，指定寄存器R0的内容是1002H，则操作数是多少？</strong><br>操作数是1200H<br><strong>（2）若采用自增型寄存器间址方式(R1)+读取操作数，R1内容是1000H，则操作数是多少？指令执行完后R1内容是多少？</strong><br>操作数是A307H，指令执行后R0的内容变为1001H<br><strong>（3）若采用自减型寄存器间址-(R2)读取操作数，R2内容为1003H，则操作数是多少？指令执行完后R2内容是多少？</strong><br>操作数是1200H，指令执行后R1的内容为1002H<br><strong>（4）若采用变址寻址方式X(R3)读取操作数，指令中给出的形式地址d&#x3D;3H，变址寄存器R3的内容是1000H，则操作数是多少？</strong><br>操作数为F03CH。</p><p><strong>2、假设R0的内容为2000H，R1的内容为2500H，（2000H）&#x3D;3000H，</strong><br><strong>(3000H)&#x3D;4000H，则指令“MOV R1，@(R0)+”执行后，R0的内容为（），R1的内容为（），(2000H)的内容为（），(3000H)的内容为（ ）。</strong><br>2001H，4000H，3000H，4000H</p><p><strong>3、若数据传输指令的源和目的操作数都采用变址寻址，指令字长为48bit（包含形式地址），数据总线和地址总线为16bit，则该指令的执行需要从存储器取指令、取源操作数，并送到目的存储单元，需要多少次访存？（ ）</strong><br>5 &#x3D; 3 + 1 + 1</p><p><strong>4、隐地址是指()的地址。</strong><br><strong>A. 用寄存器号表示 B. 存放在主存单元中</strong><br><strong>C. 事先约定,指令中不必给出 D. 存放在寄存器中</strong><br>C</p><p><strong>5、指令ADD（R0），@（R1）+的指令长度是3字节（存储器按字节编址），则指令从取指开始执行，共需要（ ）次访问存储器。</strong><br>7</p></blockquote><h3 id="加法器与运算部件"><a href="#加法器与运算部件" class="headerlink" title="加法器与运算部件"></a>加法器与运算部件</h3><p>运算器的核心部件是（ ALU ）,一般应具有（ 算术运算 ）与（ 逻辑运算 ）两大类运算能力。</p><blockquote><p><strong>1、并行加法器的运算速度取决于全加器单元的速度。</strong>（ x）</p><p><strong>2、串行进位链是串行加法器中的进位链。</strong>（ v）</p><p><strong>3、用4片74181和1片74182可组成（ ）</strong><br><strong>A、组内并行进位，组间串行进位的16位ALU</strong><br><strong>B、组内并行进位，组间并行进位的16位ALU</strong><br><strong>C、组内串行进位，组间串行进位的16位ALU</strong><br><strong>D、组内串行进位，组间并行进位的16位ALU</strong><br>B</p><p><strong>【例1】已知操作数Ai,Bi,初始进位C0。试写出C6的逻辑表达式</strong></p><p>（Ci：本位进位。 Gi：绝对进位。 Pi：条件进位。 Ci-1：传递进位。）</p><p>串行进位：<br>C6 &#x3D; G6 + P6C5;</p><p>并行进位：<br>C6 &#x3D; G6 + P6G5 + P6P5G4 + P6P5P4G3 + P6P5P4P3G2 + P6P5P4P3P2G1 + P6P5P4P3P2P1C0</p></blockquote><h3 id="模型机"><a href="#模型机" class="headerlink" title="模型机"></a>模型机</h3><h4 id="指令系统、"><a href="#指令系统、" class="headerlink" title="指令系统、"></a>指令系统、</h4><h4 id="寻址方式："><a href="#寻址方式：" class="headerlink" title="寻址方式："></a>寻址方式：</h4><p> 寄存器寻址、寄存器间址、自减型寄存器间址、自增型寄存器间址、自增型双重间址、相对寻址、跳步</p><h4 id="指令类型："><a href="#指令类型：" class="headerlink" title="指令类型："></a>指令类型：</h4><p> 双地址指令、单地址指令、转移指令</p><h4 id="模型机的数据通路结构P133-图3-34"><a href="#模型机的数据通路结构P133-图3-34" class="headerlink" title="模型机的数据通路结构P133 图3-34"></a>模型机的数据通路结构P133 图3-34</h4><h4 id="指令流程和微命令P137-P145"><a href="#指令流程和微命令P137-P145" class="headerlink" title="指令流程和微命令P137-P145"></a>指令流程和微命令P137-P145</h4><p> 传送指令、双操作数指令<br>​ 中断周期P145</p><h4 id="组合逻辑控制器"><a href="#组合逻辑控制器" class="headerlink" title="组合逻辑控制器"></a>组合逻辑控制器</h4><p> 时序系统（工作周期【6个触发器】、时钟周期【计数器】、工作脉冲）</p><p><strong>机器字长：</strong>CPU一次能处理数据的位数。通常与CPU的寄存器的位数有关, 单位b（bit）</p><p><strong>存储字长（按字节&#x2F;字&#x2F;双字节编址）：</strong>存储单元的位数。MDR的位数反映了存储字长。</p><p><strong>存储单元的个数：</strong>存储器中存储单元的个数。MAR的位数反映了存储单元的个数。 如果MAR为N位，则存储单元的个数为2的N次幂。</p><p><strong>地址线条数：</strong>决定了存储单元的最大寻址范围，决定了MAR的位数和存储单元个数。</p><p><strong>存储容量：</strong>存储容量&#x3D;存储单元的个数*存储字长。单位B（byte）。</p><blockquote><p><strong>【例1】某主存总容量为64MB，按字编址，需要多少条地址线，MAR位数是多少？</strong><br>（25，25）</p><p><strong>【例2】若数据传输指令的源和目的操作数都采用变址寻址，指令字长为48bit（包含形式地址），数据总线和地址总线为16bit，则该指令的执行需要从存储器取指令、取源操作数，并送到目的存储单元，需要多少次访存？</strong><br>（5）</p><p><strong>【例3】模型机中，MOV (R0)， @(R1)+，则该指令的执行需要从存储器取指令、取源操作数，并送到目的存储单元，需要多少次访存？</strong><br>（4）</p><p><strong>【例4】模型机中，执行指令JSR @(R0)+后，PC和SP的值如何改变？</strong><br>（ SP-1-&gt;SP ，PC值压栈后，PC值变为子程序入口地址 ）<br><strong>执行RST (SP)+指令后， PC和SP的值如何改变？</strong><br>（PC出栈，SP+1-&gt;SP）</p></blockquote><h4 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h4><p> 一条机器指令的执行分为若干步，将每一步操作所需的微命令按照固定格式进行编码，并存储成一条<strong>微指令</strong>，多条微指令构成一段<strong>微程序</strong>，这段微程序对应一条机器指令。<br>​ 机器在执行指令过程中，每一步（时钟周期）取出一条微指令，经过译码后，产生一组控制信号（微命令），控制各个部件的操作。<br>​ <strong>控制存储器（Control memory,CM,控存）：只读存储器</strong>，存储可以经过译码产生控制信号的微程序（经过按照一定规则进行编制）。</p><blockquote><p><strong>1、控制存储器CM是（）的一种存储器</strong><br><strong>A、用于存储汇编指令 B、用于存储显示字符</strong><br><strong>C、位于CPU内部 D、用于存储指令流程</strong><br>C</p><p><strong>2、后续微地址的形成有（</strong>增量和断定<strong>）两种，其中按照目的操作数寻址方式实现分支属于（</strong>断定<strong>）方式</strong></p><p><strong>3、对微指令编码，采用分段编译法，下面说法正确的是（）</strong><br><strong>A、如果K个字段，则可提供K个微命令</strong><br><strong>B、微命令的数量与段的数量和各段长度都有关系</strong><br><strong>C、微命令的数量和段的数量没有关系，只与微指令的总长度有关</strong><br><strong>D、以上三种都不正确。</strong><br>B</p></blockquote><h2 id="存储子系统"><a href="#存储子系统" class="headerlink" title="存储子系统"></a>存储子系统</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><p><strong>主存：</strong><br>CPU可直接访问，存放CPU当前使用的指令和数据。<br>特点：能随机访问、工作速度快、容量有限。</p><p><strong>辅存（外存）：</strong><br>存放大量的后备程序和数据。<br>特点：速度较慢、容量大。</p><p><strong>高速缓冲存储器(Cache)：</strong><br>存放CPU在当前一小段时间内多次使用的程序和数据，以缓解CPU和主存的速度差异。<br>特点：速度很快、容量小。</p><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="按存储介质（物理存储机制）分类："><a href="#按存储介质（物理存储机制）分类：" class="headerlink" title="按存储介质（物理存储机制）分类："></a>按存储介质（物理存储机制）分类：</h4><h5 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h5><p>静态存储器：利用双稳态触发器存储信息，功耗较大，速度快，做Cache。<br>动态存储器：依靠电容上的电荷暂存信息，功耗较小，容量较大，速度较快适合做主存。</p><h5 id="磁表面存储器：磁带、存盘、硬盘"><a href="#磁表面存储器：磁带、存盘、硬盘" class="headerlink" title="磁表面存储器：磁带、存盘、硬盘"></a>磁表面存储器：磁带、存盘、硬盘</h5><p>利用磁层上不同方向的磁化区域表示信息。<br>特点：存储容量大；非破坏性读出、永久保存；读写速度比半导体存储器慢；适合用于外存。</p><h5 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h5><p>利用光斑的有无存储信息。<br>特点：容量大；非破坏性读出、永久保存；速度慢；适合用于外存。</p><h4 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h4><h5 id="随机存取存储器-RAM，ROM、Flash-memory"><a href="#随机存取存储器-RAM，ROM、Flash-memory" class="headerlink" title="随机存取存储器(RAM，ROM、Flash memory)"></a>随机存取存储器(RAM，ROM、Flash memory)</h5><p><strong>随机存取：</strong>可按地址访问存储器中的任一单元，与访问时间和单元地址无关。<br><strong>技术指标：</strong>存取周期、存取时间。</p><h5 id="顺序存取存储器（SAM）"><a href="#顺序存取存储器（SAM）" class="headerlink" title="顺序存取存储器（SAM）"></a>顺序存取存储器（SAM）</h5><p>访问时读&#x2F;写部件按顺序查找目标地址，访问时间与数据位置有关。<br>例如，磁带机 — 与磁带录音机工作原理类似, 但存储信息为数字信息, 而非模拟信息。<br><strong>技术指标：</strong>平均存取时间、数据传输率。</p><h5 id="直接存取存储器（DAM）"><a href="#直接存取存储器（DAM）" class="headerlink" title="直接存取存储器（DAM）"></a>直接存取存储器（DAM）</h5><p>访问时读&#x2F;写部件先直接指向一个小区域，再在该区域内顺序查找。访问时间与数据位置有关，如磁盘、硬盘、光盘。<br><strong>技术指标：</strong>平均定位&#x2F;寻道时间、平均等待&#x2F;旋转时间、数据传输率。</p><h4 id="半导体存储原理"><a href="#半导体存储原理" class="headerlink" title="半导体存储原理"></a>半导体存储原理</h4><p><strong>静态存储器SRAM(双极型、静态MOS型):</strong> 依靠双稳态电路内部交叉反馈机制，功耗较大,速度快,作Cache、（六管单元构成1位，有VCC供电）非破坏性读出，读出后不需重写。</p><p><strong>动态存储器DRAM：</strong>依靠电容存储电荷的原理存储信息，功耗较小,容量大,速度较快,作主存。（4管单元、无VCC供电）四管单元是非破坏性读出，读出过程即实现刷新；需定期向电容补充电荷（动态刷新）。</p><p><strong>单管单元（无VCC）：</strong>单管单元是破坏性读出，读出后需重写。</p><p><strong>存储器的逻辑设计：</strong><br>计算芯片数量（位扩展、单元数扩展）、地址分配和片选逻辑、电路连接（数据线、地址线、片选线、读&#x2F;写线）、3:8译码器或2:4译码器的连线、与门、与非门、或门、或非门的画法。</p><blockquote><p>步骤：</p><p>（1）确定芯片数量（先位扩展，然后扩展单元数）</p><p>（2）地址分配，确定片选逻辑</p><p>（3）画连线图</p></blockquote><h4 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h4><p><strong>刷新和重写的区别：</strong>刷新是动态存储芯片，需补充电荷以保持原信息；重写是破坏性读出后重写，以恢复原来的信息。</p><p><strong>刷新原因：</strong>动态存储器依靠电容电荷存储信息。电容电荷随时间推移会缓慢泄放，需定期向电容补充电荷，以保持信息不变。</p><p><strong>最大刷新间隔：</strong>2ms内，必须对所有动态单元刷新一遍。</p><p><strong>刷新方法：</strong>各DRAM芯片同时刷新，片内按行刷新(按行读)</p><p><strong>刷新周期(存取周期)：</strong>刷新一行所用的时间。刷新周期数：刷新一块芯片所需的周期数，由芯片矩阵的行数决定。</p><p><strong>刷新周期的安排方式：</strong><br>（a）集中刷新<br>（b）分散刷新<br>（c）异步刷新：每隔一定时间(2ms&#x2F;芯片的行数)提出一次刷新请求（DMA请求），刷新一行。</p><h4 id="主存储器校验"><a href="#主存储器校验" class="headerlink" title="主存储器校验"></a>主存储器校验</h4><p><strong>奇偶校验编码规则：</strong>编码中“1”的个数为奇数或者偶数</p><blockquote><p><strong>1、某计算机主存空间是4GB，字长为32位，按字节编制，采用32位字长的指令格式，则程序计数器PC和指令寄存器IR的位数分别是（）</strong><br><strong>A、30，30 B、30，32 C、32,30 D、32,32</strong><br>D</p><p><strong>2、半导体SRAM的存储信息原理是（ )</strong><br><strong>A、依靠双稳态电路 B. 依靠定时刷新</strong><br><strong>C. 依靠读后再生 D. 信息不再变化</strong><br>A</p><p><strong>3、下列选项不属于动态刷新的方式为（ )</strong><br><strong>A、集中刷新 B. 分散刷新 C. 同步刷新 D. 异步刷新</strong><br>C</p><p><strong>4、主存按字节编址，地址从A400H到DFFFH，共有容量 15KB ；若用存储容量为3K*4的存储芯片，至少需要( )片</strong><br>10</p><p><strong>5、在计算机系统中存储器按介质分类，它们可以分为（ ）。</strong><br><strong>A、半导体存储器，磁表面存储器，光盘存储器； B、硬盘，软盘，光盘；</strong><br><strong>C、U盘，磁带，RAM； D、RAM，ROM，EPROM。</strong><br>A</p><p><strong>6、存储器按存取方式分为：</strong><br>随机存取存储器，顺序存取存储器（SAM），直接存取存储器（DAM）。</p><p><strong>7、地址总线A0∽A15，用4K*4的存储芯片组成16KB的存储器，则用于存储芯片内部寻址的地址线是（ ）</strong><br><strong>A. A16∽A15 B. A0∽A9 C. A0∽A11 D. A4∽A15</strong><br>C</p><p><strong>8、某主存容量为32KB，由16片16K*1位（内部采用128*128存储阵列）的DRAM芯片组成，若采用集中式刷新方式，且刷新周期为2ms，那么所有存储单元刷新一遍需要至少需要安排 个刷新周期。</strong><br>128</p><p><strong>9、16片2K*4位的存储器可以设计存储容量为 的16位存储器</strong><br>8K</p><p><strong>10、磁盘属于（ ）类型的存储器</strong><br><strong>A．随机存取存储器（RAM） B.只读存储器（ROM） C.顺序存取存储器（SAM） D.直接存取存储器（DAM）</strong><br>D</p><p><strong>11、下列几种存储器中，CPU不能直接访问的是（ ）</strong><br><strong>A、硬盘 B、内存 C、Cache D、寄存器</strong><br>A</p><p><strong>12、DRAM的刷新是以（ ）为单位进行的。</strong><br><strong>A、存储单元 B、行 C、列 D、存储字</strong><br>B</p><p><strong>13、某存储器容量为32K×16位，则地址线有 条。</strong><br>15</p><p><strong>14、某DRAM芯片，采用地址复用技术，其容量为1024×8位，除电源和接地外，该芯片的引脚最少是 条（读写控制线为2条）</strong><br>17</p></blockquote><h2 id="总线与输入-x2F-输出子系统"><a href="#总线与输入-x2F-输出子系统" class="headerlink" title="总线与输入&#x2F;输出子系统"></a>总线与输入&#x2F;输出子系统</h2><h3 id="I-x2F-O系统包括："><a href="#I-x2F-O系统包括：" class="headerlink" title="I&#x2F;O系统包括："></a>I&#x2F;O系统包括：</h3><p>I&#x2F;O设备：实现与主机的信息交换和人机交互</p><p>I&#x2F;O接口：主机与外设之间的连接逻辑，控制外设的I&#x2F;O操作</p><p>系统总线：连接系统各大部件的公共信息通道</p><blockquote><p><strong>为什么在外设与CPU之间需要接口?</strong></p><p>（1）时间同步：不同速度外设如何与CPU之间进行时间同步</p><p>（2）数据格式的转换(如果需要)：外设数据格式可能与CPU数据格式不同</p><p>（3）CPU与外设之间一次数据传送量的控制</p><p>（4）其它因素(如电平转换)</p></blockquote><h3 id="接口分类"><a href="#接口分类" class="headerlink" title="接口分类"></a>接口分类</h3><h4 id="按数据传送格式划分"><a href="#按数据传送格式划分" class="headerlink" title="按数据传送格式划分"></a>按数据传送格式划分</h4><p><strong>并行接口:</strong> 接口与系统总线、接口与外设均按并行方式传送数据；数据各位同时传送；适合设备本身并行工作，距主机较近的场合。<br><strong>串行接口:</strong> 接口与系统总线并行传送，接口与外设串行传送；数据逐位分时传送。</p><h4 id="按时序控制方式划分"><a href="#按时序控制方式划分" class="headerlink" title="按时序控制方式划分"></a>按时序控制方式划分</h4><p><strong>同步接口：</strong>连接同步总线，接口与系统总线的信息传送由统一时序信号控制。<br><strong>异步接口：</strong>连接异步总线，接口与系统总线的信息传送采用异步应答方式。</p><h4 id="按I-x2F-O传送控制方式划分"><a href="#按I-x2F-O传送控制方式划分" class="headerlink" title="按I&#x2F;O传送控制方式划分"></a>按I&#x2F;O传送控制方式划分</h4><p><strong>程序控制接口：</strong>通过硬件或软件方式按指定优先级查询各设备是否要进行输入&#x2F;输出<br><strong>中断接口：</strong>设备提出中断请求，主机响应后与设备交换信息，接口中包含中断控制逻辑<br><strong>DMA接口：</strong>支持高速外设与主机之间进行DMA方式交换数据</p><h3 id="I-x2F-O接口主要功能"><a href="#I-x2F-O接口主要功能" class="headerlink" title="I&#x2F;O接口主要功能"></a>I&#x2F;O接口主要功能</h3><p><strong>寻址：</strong>接收CPU送来的地址码，选择接口中的寄存器供CPU访问<br><strong>数据缓冲：</strong>实现主机与外设的速度匹配；缓冲深度与传送的数据量有关。<br><strong>预处理：</strong>串-并格式转换（串口）；数据通路寬度转换（并口）；电平转换<br><strong>控制功能：</strong>传送控制命令与状态信息，实现I&#x2F;O传送控制方式</p><h3 id="接口编址"><a href="#接口编址" class="headerlink" title="接口编址"></a>接口编址</h3><p><strong>统一编址：</strong>将一部分总线地址（高区）分配给设备接口中的寄存器（占用了主存地址）。通用的访存指令<br><strong>单独编址：</strong>为接口中的每个寄存器分配独立的端口号（与主存地址无关），有专门的I&#x2F;O指令</p><h4 id="接口传送信息包括控制命令、数据、状态"><a href="#接口传送信息包括控制命令、数据、状态" class="headerlink" title="接口传送信息包括控制命令、数据、状态"></a>接口传送信息包括控制命令、数据、状态</h4><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p><strong>定义：</strong>一组能为多个部件分时共享的信息传送线路。通常作法：发送部件通过OC组件或三态门分时发送信息，由打入脉冲将信息送入指定接收部件。<br><strong>实体：</strong>一组传送线与相应控制逻辑</p><h3 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h3><h4 id="按时序控制方式划分-1"><a href="#按时序控制方式划分-1" class="headerlink" title="按时序控制方式划分"></a>按时序控制方式划分</h4><p><strong>同步总线:</strong> 由统一时序信号控制总线传送操作；在固定时钟周期内完成数据传送，由同步脉冲定时打入。<br>**异步总线:**无固定时钟周期划分，以异步应答方式控制传送<br><strong>扩展同步总线：</strong>以时钟周期为时序基础，允许总线周期中的时钟数可变。<br><strong>时钟周期：</strong>CPU执行一步操作的时间<br><strong>总线周期：</strong>经过总线的一次数据传送(访存)时间，通常包含若干时钟周期<br><strong>工作周期：</strong>指令周期中的一个操作阶段；可包含多个总线周期</p><h4 id="计算机设计中，不同类型的总线可能采用的时序控制方式和数据传送格式："><a href="#计算机设计中，不同类型的总线可能采用的时序控制方式和数据传送格式：" class="headerlink" title="计算机设计中，不同类型的总线可能采用的时序控制方式和数据传送格式："></a>计算机设计中，不同类型的总线可能采用的时序控制方式和数据传送格式：</h4><p><strong>CPU内总线：</strong>同步、并行<br><strong>局部总线：</strong>同步、异步、扩展同步、并行<br><strong>系统总线：</strong>同步、异步、扩展同步、并行<br><strong>外总线：</strong>异步、并行、串行</p><h4 id="总线的技术指标"><a href="#总线的技术指标" class="headerlink" title="总线的技术指标"></a>总线的技术指标</h4><p>总线宽度、总线频率、总线数据传输率</p><h4 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h4><p><strong>内总线(典型)：</strong>ISA、EISA、VESA、PCI、PCI-e<br><strong>外总线(典型)：</strong>RS232、RS485、USB、IEEE1394</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p><strong>定义：</strong>CPU暂时中止现行程序的执行，转去执行为某个随机事态服务的中断处理程序。处理完毕后自动恢复原程序的执行。<br><strong>实质：</strong>程序切换。在一条指令结束时切换，保证程序的完整性；切换前需保存断点、保护现场，中断服务程序执行结束后，需要恢复现场，返回断点。<br><strong>特点：</strong>随机性</p><h4 id="中断与转子程序："><a href="#中断与转子程序：" class="headerlink" title="中断与转子程序："></a>中断与转子程序：</h4><p>（1）转子程序的执行由程序员事先安排,而中断服务程序的执行则是由随机中断事件触发。<br>（2）转子程序的执行受主程序或上层程序控制,而中断服务程序一般与被中断的现行程序无关。<br>（3）一般不存在同时调用多个子程序的情况,但可能发生多个外设同时向CPU发出中断服务请求的情况。</p><h4 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h4><p>硬中断和软中断<br>内中断和外中断<br>可屏蔽中断和非屏蔽中断<br>向量中断和非向量中断</p><h4 id="中断组成"><a href="#中断组成" class="headerlink" title="中断组成"></a>中断组成</h4><p><strong>软件：</strong>中断服务程序和中断向量表<br><strong>硬件：</strong>接口（中断请求、传递、判优逻辑）、CPU（中断响应逻辑）</p><h4 id="中断优先级判断"><a href="#中断优先级判断" class="headerlink" title="中断优先级判断"></a>中断优先级判断</h4><p>优先顺序: 故障、内中断、DMA、外中断；高速操作优于低速操作，输入优于输出。<br>CPU现行程序与外设请求的判优<br>CPU设置允许中断标志<br>CPU设置程序状态字的优先级字段，为现行程序赋予优先级</p><p>中断接口判优：中断请求寄存器、中断屏蔽寄存器、中断服务寄存器，判断是否发出INT请求。</p><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p><strong>响应条件：</strong>外设有请求，且未被屏蔽；CPU开中断；中断源优先级高于当前程序的优先级；一条指令(非停机)结束，即ET之后。</p><h5 id="如何获取中断程序的入口地址"><a href="#如何获取中断程序的入口地址" class="headerlink" title="如何获取中断程序的入口地址"></a>如何获取中断程序的入口地址</h5><p><strong>（a）非向量中断：</strong>将服务程序入口组织在查询程序中，CPU响应时，执行查询程序，查询中断源，转入相应的服务程序。<br><strong>（b）向量中断：</strong>将中断源的服务程序入口（中断向量）组织在中断向量表中，CPU响应时，由硬件直接产生相应的向量地址，按地址查表，取得服务程序入口，转入相应的服务程序。<br><strong>中断向量：</strong>中断服务程序入口地址<br><strong>中断向量表：</strong>存放各中断向量的表（一段存储区）<br><strong>向量地址：</strong>访问中断向量表的地址（指向中断向量首址）,可通过中断号（中断类型码）计算得到</p><h5 id="响应过程"><a href="#响应过程" class="headerlink" title="响应过程"></a>响应过程</h5><p><strong>（a）中断周期IT流程</strong>（关中断；保存断点；获取服务程序入口地址；转向程序状态1-&gt;FT）<br><strong>（b）中断服务程序流程</strong><br>单级中断：保护现场、中断服务处理、恢复现场、开中断、返回。<br>多重中断：保护现场、送屏蔽字和开中断、中断服务处理、关中断、恢复现场及屏蔽字、开中断、返回。</p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p><strong>定义：</strong>直接由硬件实现主存与I&#x2F;O间的数据传送, 传送期间不需CPU程序干预。传送结束以后，通过中断的方式通知CPU。<br>\1) 传送发生在I&#x2F;O与主存之间;<br>\2) 由DMA控制器来控制传送,DMA控制器接管总线权,传送完毕再将总线权交还CPU<br>\3) 只要CPU不访存, DMA操作与CPU可并行操作<br>\4) 传送前和传送后需要CPU程序干预。</p><p><strong>特点：</strong><br>(1)响应随机请求<br>(2)一般不影响CPU程序的执行，仅占用总线、无程序切换<br>(3)大批量数据的简单传送</p><p><strong>应用场景：</strong><br>(1)主存与高速I&#x2F;O设备之间的简单数据传送。<br>(2)大批量数据采集系统<br>(3)动态存储器（DRAM）的自动刷新</p><h4 id="DMA的数据传送操作方式"><a href="#DMA的数据传送操作方式" class="headerlink" title="DMA的数据传送操作方式"></a>DMA的数据传送操作方式</h4><p><strong>①单字传送：</strong>DMA请求获得批准后，CPU让出一个总线周期用于字或字节的传送，再回收并重新判断下一个周期的总线控制权，也称为周期挪用或窃取。</p><p><strong>②成组连续传送方式：</strong>DMA被批准后，连续占用若干个总线周期，成组连续批量地传送，结束后将总线的控制权交回给CPU。</p><h4 id="CPU初始化DMA步骤"><a href="#CPU初始化DMA步骤" class="headerlink" title="CPU初始化DMA步骤"></a>CPU初始化DMA步骤</h4><p>向接口送出I&#x2F;O设备的寻址信息；<br>向DMA控制器送出控制字，如传送方向；<br>向DMA控制器送出主存缓冲区首址；<br>向DMA控制器送出传送的数据量；</p><h4 id="DMA硬件功能"><a href="#DMA硬件功能" class="headerlink" title="DMA硬件功能"></a>DMA硬件功能</h4><p><strong>DMA控制器功能：</strong><br>接收初始化信息（传送方向、主存首址、交换量）<br>接收外设DMA请求，判优，向CPU申请总线。<br>接管总线权，发地址、读&#x2F;写命令。<br>接口功能<br>接收初始化信息(外设寻址信息）)<br>向DMA控制器发请求。<br>传送数据。</p><blockquote><p><strong>1、主设备发送数据，从设备接收数据（ ）</strong><br>X</p><p><strong>2、串行接口与系统总线串行传送，接口与外设串行传送（ ）</strong><br>X</p><p><strong>3、有关I&#x2F;O接口的叙述中，错误的是（ ）</strong><br><strong>A、状态端口和控制端口可以合并为同一寄存器</strong><br><strong>B、I&#x2F;O接口中CPU可访问的寄存器称为I&#x2F;O端口</strong><br><strong>C、采用独立编址方式时，I&#x2F;O端口地址和主存地址可能相同</strong><br><strong>D、采用同一编址方式，CPU不能用访存指令访问I&#x2F;O端口</strong><br>D</p><p><strong>4、下列关于中断I&#x2F;O方式和DMA方式的叙述中，错误的是（ ）</strong><br><strong>A、中断I&#x2F;O方式请求的是CPU处理时间，DMA方式请求的是总线使用权</strong><br><strong>B、中断响应发生在一条指令执行结束后，DMA响应发生在一个总线周期完成后</strong><br><strong>C、中断I&#x2F;O方式下数据传送通过软件完成，DMA方式下数据传送通过硬件完成</strong><br><strong>中断I&#x2F;O方式下适用于所有外部设备，DMA方式仅适用于快速外部设备</strong><br>D</p><p><strong>5、程序控制类指令的功能是（ ）</strong><br><strong>A、进行算术和逻辑运算</strong><br><strong>B、进行主存与CPU之间的数据传送</strong><br><strong>C、进行CPU和I&#x2F;O设备之间的数据传送</strong><br><strong>D、改变程序的执行顺序</strong><br>D</p><p><strong>6、采用向量中断方式，是通过（ ）来识别中断来源（中断源）</strong><br><strong>A、中断号或者中断类型号 C、中断优先排队的方式</strong><br><strong>B、中断源端口地址译码 D、提出中断请求的先后顺序</strong><br>A</p><p><strong>7、中断屏蔽和允许中断的描述，以下说法不正确的是（ ）</strong><br><strong>A、中断屏蔽是指向CPU向接口写入控制字，以控制是否让中断源提出中断请求</strong><br><strong>B、允许中断是指CPU向接口写入控制字，以允许或不允许中断源提出中断请求</strong><br><strong>C、允许中断是CPU内部状态位，用于决定是否响应中断请求</strong><br><strong>D、中断屏蔽功能的实施一般在中断接口中。</strong><br>B</p><p><strong>8、中断响应周期结束后，CPU应该转入（ ）</strong><br><strong>A、执行周期 B、取指周期 C、取源数据周期 D、取目的数据周期</strong><br>B</p><p><strong>9、为了保证返回主程序后的正常执行，在中断服务程序中，应进行（ ）操作</strong><br><strong>A、保存断点地址 B、关中断 C、保存现场 D、开中断</strong><br>C</p><p><strong>10、在有多个中断源的系统中，采用向量中断方式，中断屏蔽字来自于（ ）</strong><br><strong>A、中断接口 B、提出中断请求设备 C、CPU D、向量地址</strong><br>C</p><p><strong>11、在单级中断中，中断服务程序执行顺序是（ ）</strong><br><strong>a. 保护现场；b. 开中断；c. 关中断 d. 保存断点； e. 中断事件处理；</strong><br><strong>f. 恢复现场； g. 中断返回</strong><br><strong>A、a→e→f→b→g B. c→a→e→g</strong><br><strong>C. c→d→e→f→g D. d→a→e→f→g</strong><br>A</p><p>12、某机有4级中断，优先级从高到低是1→2→3→4。若将优先级顺序修改，修改候1级中断的屏蔽字为<strong>1011，2级中断的屏蔽字为1111，3级中断的屏蔽字为0011，4级中断的屏蔽字为0001，则修改后的优先顺序为 。</strong><br>2→1→3→4</p><p><strong>13、有 8个 中断源，优先级为I0&gt;I1&gt;I2&gt;I3&gt;I4&gt;I5&gt;I6&gt;I7，采用多重中断方式，屏蔽字中Di用于屏蔽Ii（为0则屏蔽）。CPU在执行I2所对应的中断服务程序时，应写入接口的屏蔽字是 。</strong><br>11000000</p><p><strong>14、CPU响应中断必须满足的条件是(）</strong><br><strong>A. CPU接收到中断请求信号 B. CPU允许中断</strong><br><strong>一条指令执行完毕 D. 以上都是</strong><br>D</p><p><strong>15、某计算机有五级中断L4-L0，中断屏蔽字为M4M3M2M1M0，Mi&#x3D;1(0≤i≤4)表示Li级中断屏蔽，若中断响应优先级顺序是L4 L0 L2L1L3，则L1的中断处理程序中设置的中断屏蔽字是 。</strong><br>01010</p><p><strong>16、关于DMA方式的说法，正确的是（ ）</strong><br><strong>A、DMA方式利用软件是新数据传送</strong><br><strong>B、DMA方式能完全取代中断方式</strong><br><strong>C、DMA方式在传送过程中需要CPU程序的干预</strong><br><strong>D、DMA方式一般用于高速外设数据的简单传送</strong><br>D</p><p><strong>17、由于DMA传输发生在外设与内存之间，因此当CPU响应DMA请求以后，CPU应将（ ）。</strong><br><strong>A、数据总线交给外设； B、总线控制权交给DMA控制器.；</strong><br><strong>C、存储器交给外设； D、内存交给外设。</strong><br>B</p><p><strong>18、下列关于中断方式和DMA方式的描述，错误的是（ ）</strong><br><strong>A、中断方式请求的是CPU处理时间，DMA方式请求的是总线使用权</strong><br><strong>B、中断响应发生在一条指令执行结束，DMA响应发生在总线书屋完成</strong><br><strong>C、中断方式下数据传送通过软件完成，DMA方式下数据传送由硬件完成</strong><br><strong>D、中断方式适用于外部设备，DMA方式仅适用于快速设备。</strong><br>D</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs</tag>
      
      <tag>review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AD学习——STM32F103C8T6实战</title>
    <link href="/2020/09/ad-stm32/"/>
    <url>/2020/09/ad-stm32/</url>
    
    <content type="html"><![CDATA[<h4 id="资料下载：STM32F103C8T6硬件资料"><a href="#资料下载：STM32F103C8T6硬件资料" class="headerlink" title="资料下载：STM32F103C8T6硬件资料"></a>资料下载：<a href="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/files/%E5%AD%A6%E4%B9%A0%E6%A8%A1%E6%9D%BF%28%E5%AE%9E%E4%BE%8B%29.zip">STM32F103C8T6硬件资料</a></h4><h2 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h2><p><strong>新建工程</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image.png" alt="image.png"></p><p><strong>保存（快捷键Ctrl+S）</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image21155e0ac67076a1.png" alt="image21155e0ac67076a1.png"></p><p><strong>添加原理图和pcb</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagec6a3ab1a9d299772.png" alt="imagec6a3ab1a9d299772.png"></p><p><strong>工具面板介绍</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image200bac138d1066cd.png" alt="image200bac138d1066cd.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imageecabb77c4dfae990.png" alt="imageecabb77c4dfae990.png"></p><p><strong>原理图结构</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image5ef1ebe1db23f607.png" alt="image5ef1ebe1db23f607.png"></p><p><strong>原理图属性设置</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image4b055e4fdd2802ce.png" alt="image4b055e4fdd2802ce.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagef6d983d5022bb24c.png" alt="imagef6d983d5022bb24c.png"></p><p><strong>快捷键：Ctrl+Q 转换单位(mil&lt;-&gt;mm)</strong></p><p><strong>P3</strong></p><p><strong>再打开一份工程《stm32最小系统》</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image965457c19ece26ad.png" alt="image965457c19ece26ad.png"></p><p><strong>窗口设置</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image1f735e8f356356b3.png" alt="image1f735e8f356356b3.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image267cdd80b87dd846.png" alt="image267cdd80b87dd846.png"></p><p><strong>原理图库的导入(版本不同名称不同，20版叫components,也有叫libraries的</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image6dbcbec929e44317.png" alt="image6dbcbec929e44317.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image2c6878d73c2e1775.png" alt="image2c6878d73c2e1775.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image403efaa75f05aa68.png" alt="image403efaa75f05aa68.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image98f7d2459081aa89.png" alt="image98f7d2459081aa89.png"></p><p><strong>选择导入的原理图库</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image0c3b0f1c979648d3.png" alt="image0c3b0f1c979648d3.png"></p><p><strong>放置主芯片(双击选择也行)</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imaged38693b1eee18734.png" alt="imaged38693b1eee18734.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagee8c1141911c55323.png" alt="imagee8c1141911c55323.png"></p><p><strong>按Esc或鼠标右键取消放置</strong></p><p><strong>按Ctrl + 鼠标滚轮 缩放图纸</strong></p><p><strong>按鼠标右键移动图纸</strong></p><p><strong>原件标号</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image0e7f68ea28e5b999.png" alt="image0e7f68ea28e5b999.png"></p><p><strong>给原件自动标号步骤</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagea3426ff57d3d88db.png" alt="imagea3426ff57d3d88db.png"></p><p><strong>网络编号(作用在于将引脚连起来)</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image7bcf81ab98a3f540.png" alt="image7bcf81ab98a3f540.png"></p><p><strong>放置排针</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image922493b764bfe498.png" alt="image922493b764bfe498.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagee27b4eb6ebb569e2.png" alt="imagee27b4eb6ebb569e2.png"></p><p><strong>放置线</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image8419f53fb7b7f08e.png" alt="image8419f53fb7b7f08e.png"></p><p><strong>放置5根线后选择并批量复制(Ctrl+C复制，Ctrl+V黏贴)</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagea2852ebfaee5eafa.png" alt="imagea2852ebfaee5eafa.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imageffffdd407d828c5c.png" alt="imageffffdd407d828c5c.png"></p><p><strong>快捷键 delete删除元件</strong></p><p><strong>过滤器介绍</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imaged7b7801f4f8fc1e1.png" alt="imaged7b7801f4f8fc1e1.png"></p><p><strong>网络编号放置</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagee644dc63e73a060f.png" alt="imagee644dc63e73a060f.png"></p><p><strong>按Tab弹出网络编号设置面板</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imageb4254423c7374810.png" alt="imageb4254423c7374810.png"></p><p><strong>放置元件时</strong><br><strong>空格进行90度旋转,X键进行水平翻转，Y键进行垂直翻转，也可以按tab在面板中设置角度</strong></p><p><strong>放置线</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image650867884e4ce479.png" alt="image650867884e4ce479.png"></p><p><strong>放线的时候空格设置线条的放置模式</strong></p><p><strong>放置文本(按tab设置属性)</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagef08bae886a23142d.png" alt="imagef08bae886a23142d.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image8abd73ecb5c27afc.png" alt="image8abd73ecb5c27afc.png"></p><p><strong>P5</strong></p><p><strong>设置元件标号</strong></p><p><strong>添加PCB并保存</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image86ab6156c5a71abc.png" alt="image86ab6156c5a71abc.png"></p><p><strong>将原理图导出为PCB</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagedc51bc563edf524b.png" alt="imagedc51bc563edf524b.png"></p><p><strong>从原理图导入PCB</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagee10e2a1b43f765ad.png" alt="imagee10e2a1b43f765ad.png"></p><p><strong>添加封装</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image12c8a5269db9836f.png" alt="image12c8a5269db9836f.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image00a4c6c0fa98f3db.png" alt="image00a4c6c0fa98f3db.png"></p><p><strong>批量添加封装</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagebd4c34076ce9e01c.png" alt="imagebd4c34076ce9e01c.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image2ae5e9f04433bfbe.png" alt="image2ae5e9f04433bfbe.png"></p><p><strong>快捷键Shift+C取消选择</strong></p><p><strong>编译工程</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image9f255401c932063f.png" alt="image9f255401c932063f.png"></p><p><strong>绿色表明编译成功。</strong></p><p><strong>出现Error说明有问题。通过编译信息可以快速找到那些地方有错误，比如没封装之类的。</strong></p><p><strong>编译完成后导入PCB</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image4c01746349529967.png" alt="image4c01746349529967.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image6b71fa9c48947068.png" alt="image6b71fa9c48947068.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imageba2e29ccac2f4b31.png" alt="imageba2e29ccac2f4b31.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagedc739aa164cace91.png" alt="imagedc739aa164cace91.png"></p><p><strong>封装管理器查看</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image0ff2fff350662e3a.png" alt="image0ff2fff350662e3a.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image1ddeff9633826d2d.png" alt="image1ddeff9633826d2d.png"></p><p><strong>PCB元件布局</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image08de76e64545ac3d.png" alt="image08de76e64545ac3d.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagec0c7066b5d50799d.png" alt="imagec0c7066b5d50799d.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image4ef52257f1d1adab.png" alt="image4ef52257f1d1adab.png"></p><p><strong>快捷键：按住Shift进行多选</strong></p><p><strong>选择元件后点击就能集中元件</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image9b9ead63495e4557.png" alt="image9b9ead63495e4557.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image3e4c35e734749687.png" alt="image3e4c35e734749687.png"></p><p><strong>按N键后点击”隐藏链接”在点击隐藏链”全部”来隐藏线条</strong></p><p><strong>先挑出两个排针来确定板子形状</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image063e5a9e25548313.png" alt="image063e5a9e25548313.png"></p><p><strong>设置原点</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imageed633c75e988f77b.png" alt="imageed633c75e988f77b.png"></p><p><strong>设置板子宽度</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image353743f3f321f93a.png" alt="image353743f3f321f93a.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image6f7ee5484b1f8f20.png" alt="image6f7ee5484b1f8f20.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image1c85452a0080a8d3.png" alt="image1c85452a0080a8d3.png"></p><p><strong>画好线条后精确设置宽度</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image4490bfd88f993da5.png" alt="image4490bfd88f993da5.png"></p><p><strong>将排针进行放到线上并进行底对齐</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image155aa7ee75c18fcd.png" alt="image155aa7ee75c18fcd.png"></p><p><strong>然后将线围绕边框</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagee825b80ffcb8132c.png" alt="imagee825b80ffcb8132c.png"></p><p><strong>按照画好的框图确定板子最终形状(要先选择紫色的线条才行)</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image8954e9aa0258c27e.png" alt="image8954e9aa0258c27e.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image0bd799a28e17a870.png" alt="image0bd799a28e17a870.png"></p><p><strong>微调快捷键：选择元件按住鼠标左键并按方向键</strong></p><p><strong>点击锁定后防止误移元件</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image877536c3db491ab5.png" alt="image877536c3db491ab5.png"></p><p><strong>设置辅助线</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image095557e2dae3b1af.png" alt="image095557e2dae3b1af.png"></p><p><strong>集中元件</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image173153192855d8ae.png" alt="image173153192855d8ae.png"></p><p><strong>点击快捷键L让元件放在底层(蓝色)</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imageee5e151b9e1d9414.png" alt="imageee5e151b9e1d9414.png"></p><p><strong>有连线关系的元件应该放尽量紧密</strong></p><p><strong>快捷键L切除可见面板隐藏元件名称</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image25c8f0af97bfe11f.png" alt="image25c8f0af97bfe11f.png"></p><p><strong>元件摆放规则设置</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagee10b0444e19b3be3.png" alt="imagee10b0444e19b3be3.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image7e687ed1f5e9bd63.png" alt="image7e687ed1f5e9bd63.png"></p><p><strong>参数设置：</strong></p><p><strong>1.  6mil</strong></p><p><strong>2.  0mil</strong></p><p><strong>3.  0mil</strong></p><p><strong>4.  0mil</strong></p><p><strong>5.  0mil</strong></p><p><strong>切换三维模式</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image8f10a5015854d0b0.png" alt="image8f10a5015854d0b0.png"></p><p><img src="C:\Users\Jason\AppData\Roaming\Typora\typora-user-images\image-20200929132904788.png" alt="image-20200929132904788"></p><p><strong>所有元件摆放完成后效果</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagec091857084b97063.png" alt="imagec091857084b97063.png"></p><p><strong>手动布线</strong></p><p><strong>将不必要的层隐藏(顶层和底层)</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagee0dac2a29d6a36c3.png" alt="imagee0dac2a29d6a36c3.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image5f6bd7b8443bb595.png" alt="image5f6bd7b8443bb595.png"></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imaged3da0ff1b614e5e0.png" alt="imaged3da0ff1b614e5e0.png"></p><p><strong>布线</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagebc1d6faa488d784c.png" alt="imagebc1d6faa488d784c.png"></p><p><strong>规则设置</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image0f4664309bc56998.png" alt="image0f4664309bc56998.png"></p><p><strong>放置过孔(用于连接两层不同的元件)，快捷键*键</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image04d0d30b043d5329.png" alt="image04d0d30b043d5329.png"></p><p><strong>设置线宽上下限</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/imagef294f18140ef604a.png" alt="imagef294f18140ef604a.png"><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/29/image9b191add0a8d65c5.png" alt="image9b191add0a8d65c5.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Embedded</category>
      
      <category>Hardware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AD学习——基本简介</title>
    <link href="/2020/09/ad20-learn/"/>
    <url>/2020/09/ad20-learn/</url>
    
    <content type="html"><![CDATA[<p><strong>教程链接：</strong><a href="https://www.bilibili.com/video/BV16t411N7RD">地址</a></p><h2 id="1-软件安装"><a href="#1-软件安装" class="headerlink" title="1.软件安装"></a>1.软件安装</h2><p>设置中文：右上角设置-&gt;全局设置-&gt;系统-&gt;本地化资源</p><h2 id="2-工程创建及基本结构"><a href="#2-工程创建及基本结构" class="headerlink" title="2.工程创建及基本结构"></a>2.工程创建及基本结构</h2><p><strong>结构：</strong></p><ol><li>原理图文件<ol><li>原理图库</li><li>PCB文件</li><li>PCB库</li><li>电路板生产文件</li></ol></li></ol><h2 id="3-电阻电容原理图模型创建"><a href="#3-电阻电容原理图模型创建" class="headerlink" title="3.电阻电容原理图模型创建"></a>3.电阻电容原理图模型创建</h2><ol><li>针管方向</li><li>引脚长度</li><li>栅格大小</li><li>颜色选择</li><li>旋转快捷键：空格</li></ol><h2 id="4-IC类元件原理图模型创建"><a href="#4-IC类元件原理图模型创建" class="headerlink" title="4.IC类元件原理图模型创建"></a>4.IC类元件原理图模型创建</h2><ol><li>矩形边框</li><li>引脚编号</li><li>引脚名称</li><li>元件封装（后面再加）</li></ol><h2 id="5-排针类元件原理图模型创建"><a href="#5-排针类元件原理图模型创建" class="headerlink" title="5.排针类元件原理图模型创建"></a>5.排针类元件原理图模型创建</h2><ol><li>阵列粘贴</li><li>长度的正负可代表引脚方向</li></ol><h2 id="6-光耦及二极管元件原理图模型创建"><a href="#6-光耦及二极管元件原理图模型创建" class="headerlink" title="6.光耦及二极管元件原理图模型创建"></a>6.光耦及二极管元件原理图模型创建</h2><ol><li>多边形工具</li><li>针管模型选择</li></ol><h2 id="7-现有元件模型的调用"><a href="#7-现有元件模型的调用" class="headerlink" title="7.现有元件模型的调用"></a>7.现有元件模型的调用</h2><ol><li>生成原理图库（切换到原理图卡片）</li></ol><h2 id="8-元件的放置"><a href="#8-元件的放置" class="headerlink" title="8.元件的放置"></a>8.元件的放置</h2><ol><li>切换到原理图库-&gt;选择元件-&gt;左下角放置</li><li>原理图界面-&gt;右下角panels-&gt;component-&gt;右侧选择原理图库-&gt;选择元件-&gt;拖拽放置</li></ol><h2 id="9-器件的复制与对其"><a href="#9-器件的复制与对其" class="headerlink" title="9.器件的复制与对其"></a>9.器件的复制与对其</h2><ol><li><p>镜像快捷键</p></li><li><p>快捷键A，对齐菜单</p></li><li><p>镜像对称：</p><p>X对称：拖动+X</p><p>Y对称：拖动+Y</p></li></ol><h2 id="10-导线和标签的添加"><a href="#10-导线和标签的添加" class="headerlink" title="10.导线和标签的添加"></a>10.导线和标签的添加</h2><ol><li>添加导线 ctrl+w</li></ol><h2 id="11-value值的校对"><a href="#11-value值的校对" class="headerlink" title="11.value值的校对"></a>11.value值的校对</h2><ol><li>修改标注：T+A+A</li><li>检查连接性</li></ol><h2 id="12-封装管理"><a href="#12-封装管理" class="headerlink" title="12.封装管理"></a>12.封装管理</h2><ol><li>封装管理器统一管理。工具-&gt;封装管理器</li></ol><h2 id="13-原理图的编译以及检查"><a href="#13-原理图的编译以及检查" class="headerlink" title="13.原理图的编译以及检查"></a>13.原理图的编译以及检查</h2><ol><li>工具-&gt;工程选项</li><li>alt+左键：查看标签连接对象</li><li>检查单管引脚</li></ol><h2 id="14-常见CHIP封装的创建"><a href="#14-常见CHIP封装的创建" class="headerlink" title="14.常见CHIP封装的创建"></a>14.常见CHIP封装的创建</h2><ol><li>焊盘</li><li>管脚序号</li><li>阻焊</li><li>1脚标识</li><li>丝印</li><li>元件本体</li><li>精准移动快捷键：M</li></ol><h2 id="15-常见IC类封装的创建"><a href="#15-常见IC类封装的创建" class="headerlink" title="15.常见IC类封装的创建"></a>15.常见IC类封装的创建</h2><ol><li>焊盘尺寸计算</li><li>阻焊稍微大一点</li><li>特殊粘贴</li></ol><h2 id="16-利用IPC封装创建向导快速创建封装"><a href="#16-利用IPC封装创建向导快速创建封装" class="headerlink" title="16.利用IPC封装创建向导快速创建封装"></a>16.利用IPC封装创建向导快速创建封装</h2><ol><li>扩展和更新-&gt;IPC Footprint Generator</li></ol><h2 id="17-常用PCB封装调用"><a href="#17-常用PCB封装调用" class="headerlink" title="17.常用PCB封装调用"></a>17.常用PCB封装调用</h2><ol><li>生成已有文件PCB库</li></ol><h2 id="18-3D模型的创建与导入"><a href="#18-3D模型的创建与导入" class="headerlink" title="18.3D模型的创建与导入"></a>18.3D模型的创建与导入</h2><ol><li>绘制范围及丝印范围</li><li>整体高度与悬浮高度</li><li>放置3D Body可以直接导入</li><li>3D元件体可以自定义也可以导入库</li></ol><h2 id="19-导入常见报错解决办法"><a href="#19-导入常见报错解决办法" class="headerlink" title="19.导入常见报错解决办法"></a>19.导入常见报错解决办法</h2><ol><li>元件名</li><li>元件管脚缺失</li><li>管脚号不匹配</li></ol><h2 id="20-常见绿色报错的消除"><a href="#20-常见绿色报错的消除" class="headerlink" title="20.常见绿色报错的消除"></a>20.常见绿色报错的消除</h2><ol><li>工具-&gt;设计规则查看器：删除不需要的规则</li></ol><h2 id="21-PCB板框评估以及叠层设计"><a href="#21-PCB板框评估以及叠层设计" class="headerlink" title="21.PCB板框评估以及叠层设计"></a>21.PCB板框评估以及叠层设计</h2><ol><li>工具-&gt;器件摆放-&gt;器件阵列排布</li><li>确定板框尺寸（稍微大一点）</li><li>放置-&gt;线性尺寸</li><li>快捷键 D+S+D重新定义板框（裁剪）</li><li>正片层：见到的线就是铜</li><li>负片层：与正片层相反</li></ol><h2 id="22-PCB常用快捷键设置"><a href="#22-PCB常用快捷键设置" class="headerlink" title="22.PCB常用快捷键设置"></a>22.PCB常用快捷键设置</h2><ol><li>找到要设置快捷键的命令</li><li>ctrl+左键点击，进入快捷键设置窗口</li><li>设置快捷键</li><li>常用设置：<img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/20/QQ20200920115227.jpg" alt="QQ20200920115227.jpg"></li></ol><h2 id="23-模块化布局规划"><a href="#23-模块化布局规划" class="headerlink" title="23.模块化布局规划"></a>23.模块化布局规划</h2><ol><li>工具-&gt;交叉选择模式</li><li>信号电源分离，先隐藏电源网络调整信号网络。</li></ol><h2 id="23-实战操作"><a href="#23-实战操作" class="headerlink" title="23.实战操作"></a>23.实战操作</h2><ol><li>布局原则：先大后小</li><li>以功能模块为单位，按信号流向摆件</li><li>丝印格式改变</li><li>元件位号位置设置（中心）</li><li>元件高亮，方便筛选</li></ol><h2 id="24-PCB设计规则以及PCB手工布线"><a href="#24-PCB设计规则以及PCB手工布线" class="headerlink" title="24.PCB设计规则以及PCB手工布线"></a>24.PCB设计规则以及PCB手工布线</h2><ol><li><p>Class：类。（电源、信号）</p></li><li><p>电源线加粗。</p></li><li><p>规则编辑器：</p><p>间距规则：最小线宽、线距。4&lt;x&lt;6最好。（注意规则优先级和使能）</p><p>过孔规则：最好12mil。（2*H（孔径）+-2mil）。推荐过孔盖油。</p><p>铺铜规则： 平面间隙8mil最好。焊盘采用十字连接、过孔采用全连接。</p></li></ol><h2 id="25-扇孔的处理"><a href="#25-扇孔的处理" class="headerlink" title="25.扇孔的处理"></a>25.扇孔的处理</h2><ol><li>打孔占位，减少回流路径。</li></ol><h2 id="26-信号线布线"><a href="#26-信号线布线" class="headerlink" title="26.信号线布线"></a>26.信号线布线</h2><ol><li>先连线，再优化</li><li>能少打孔少打孔</li></ol><h2 id="27-电源线走线"><a href="#27-电源线走线" class="headerlink" title="27.电源线走线"></a>27.电源线走线</h2><h2 id="28-信号线优化、GND处理"><a href="#28-信号线优化、GND处理" class="headerlink" title="28.信号线优化、GND处理"></a>28.信号线优化、GND处理</h2><ol><li>多边形挖空消除尖角铜皮。</li></ol><h1 id="AD常用快捷键"><a href="#AD常用快捷键" class="headerlink" title="AD常用快捷键"></a>AD常用快捷键</h1><p>AD常用快捷键<br>旋转：Space；</p><p>X轴镜像：X；<br>Y轴镜像：Y；<br>板层管理：L；<br>栅格设置：G；<br>单位进制切换：Q；</p><p>对齐-水平：A，D；<br>对齐-垂直：A，I，I，Enter；<br>对齐-顶部：A，T；<br>对齐-底部：A，B；<br>对齐-左侧：A，L；<br>对齐-右侧：A，R；</p><p>设计-类设置：D，C;<br>设计-板层管理：D，K；<br>设计-规则：D，R；<br>设计-规则向导：D，W；<br>设计-拷贝ROOM格式：D，M，C；<br>设计-放置ROOM：D，M，R；<br>设计-根据选择对象定义板子形状：D，S，D；<br>设计-编辑网络：D，N，N；</p><p>编辑-删除：E，D；<br>编辑-切断轨迹：E，K；<br>编辑-设定原点：E，O，S；<br>编辑-复位原点：E，O，R；</p><p>移动-移动：M，M；<br>移动-拖拽：M，D；<br>移动-器件：M，C；<br>移动-打断走线：M，B；<br>移动-器件翻转板层：M，I；</p><p>网络-显示网络：N，S，N；<br>网络-显示器件：N，S，O；<br>网络-显示全部：N，S，A；<br>网络-隐藏网络：N，H，N；<br>网络-隐藏器件：N，H，O；<br>网络-隐藏全部：N，H，A；</p><p>放置-坐标：P，O；<br>放置-焊盘：P，P；<br>放置-字符：P，S；<br>放置-过孔：P，V； 走线快速添加过孔：ctrl+shift+滚轮；<br>放置-多边形：P，R；<br>放置-填充：P，F；<br>放置-敷铜：P，G；<br>放置-线性尺寸：P，D，L；<br>放置-走线：P，T；<br>放置-差分对布线：P，I；<br>放置-多根布线：P，M，Enter；</p><p>选择-全选：S，A；<br>选择-线选：S，L；<br>选择-区域（内部）：S，I；</p><p>选择-区域（外部）：S，O；</p><p>选择网络：S,P;</p><p>工具-交叉探测对象：T，C；(+Ctrl:跳转到目标文件)<br>工具-泪滴选项：T，E；<br>工具-设计规则检查：T，D；<br>工具-复位错误标志：T，M；<br>工具-从选择元素创建板剪切：T，V，B<br>工具-网络等长调节：T，R；</p><p>取消布线-全部：U，A；<br>取消布线-网络：U，N；<br>取消布线-连接：U，C；<br>取消布线-器件：U，O；<br>取消布线-ROOM：U，R；</p><p>查看-合适区域：V，A；<br>查看-翻转板子：V，B；<br>查看-适合文件：V，D；<br>查看-合适板子：V，F；<br>查看-合适图纸：V，H；</p><p>测距：Ctrl + M；</p><p>清除蒙板： Shift + Ｃ；<br>查找相似对象： Shift +</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Embedded</category>
      
      <category>Hardware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>EDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>keil上手</title>
    <link href="/2020/09/keil-1/"/>
    <url>/2020/09/keil-1/</url>
    
    <content type="html"><![CDATA[<h2 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h2><ol><li>如何建工程。</li><li>如何配置与设置工程。</li><li>如何编译自己开发的程序。</li><li>如何调试。</li><li>如何用KEIL开发stm32开发底层程序。</li><li>如何下载编译过后的代码。</li><li>如何查看寄存器。</li><li>如何知道生成代码的地址。</li></ol><p>……</p><h2 id="keil的安装"><a href="#keil的安装" class="headerlink" title="keil的安装"></a>keil的安装</h2><p>默认已经安装完成。</p><h2 id="keil的使用"><a href="#keil的使用" class="headerlink" title="keil的使用"></a>keil的使用</h2><h3 id="1-如何新建工程（以STM32F1xx为例）"><a href="#1-如何新建工程（以STM32F1xx为例）" class="headerlink" title="1.如何新建工程（以STM32F1xx为例）"></a>1.如何新建工程（以STM32F1xx为例）</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>新建工程文件夹</li></ol><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910131230.jpg" alt="20200910131230.jpg"></p><ol start="2"><li><p>下载并解压官方的标准外设库</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910131420.jpg" alt="20200910131420.jpg" style="zoom:67%;" /></li><li><p>在***1.**<em>中新建的文件夹下新建</em>Libraries*文件夹，用于存放标准外设库。</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910132209.jpg" alt="20200910132209.jpg" style="zoom:67%;" /></li><li><p>在<em><strong>Libraries</strong></em>下新建<em><strong>CMSIS</strong></em>并将<em><strong>STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport</strong></em>中的文件复制到<em><strong>CMSIS</strong></em>中；</p><p>再将<em><strong>STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x</strong></em>中的文件全部复制到<em><strong>CMSIS</strong></em>中。最终<em><strong>CMSIS</strong></em>中的文件如图。</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910132703.jpg" alt="20200910132703.jpg" style="zoom:67%;" /></li><li><p>将<em><strong>STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver</strong></em>复制进<em><strong>Libraries</strong></em>文件夹，并将<em><strong>STM32F10x_StdPeriph_Driver</strong></em>改为<em><strong>FWLIB</strong></em>。</p></li><li><p>在工程文件夹目录下新建<em><strong>User</strong></em>文件夹，随便写一个main.c放进去也行。</p></li></ol><p><strong>准备基本完成</strong></p><h4 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h4><p>在keil中新建一个工程文件，如图：</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910134356.png" alt="20200910134356.png" style="zoom:67%;" /><p>保存到刚刚新建的文件夹中，如图：</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910134725.jpg" alt="20200910134725.jpg" style="zoom: 50%;" /><p>随即选择所开发的芯片型号，如图（STM32F103C8为例）：</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910134909.jpg" alt="20200910134909.jpg" style="zoom:67%;" /><p>  确定之后跳出一个窗口，直接关掉（这是让选择启动引导等的，我们已经下载的库里有，所以跳过这一步）。点箭头指出的图表，然后删除掉SourceGroup1。</p><h3 id="配置与设置工程"><a href="#配置与设置工程" class="headerlink" title="配置与设置工程"></a>配置与设置工程</h3><p>依次添加CMSIS、USER、FWLIB、STARTUP，并把刚刚复制在对应文件夹下的文件添加。注意的是STARTUP要选择NewProject\CMSIS\startup\arm中startup_stm32f10x_hd.s、startup_stm32f10x_ld.s、startup_stm32f10x_md.s<strong>三个中的一个</strong>，根据需要选取。文件类型选择所有。 FWLIB中只需要添加src中的.c文件即可。 CMSIS中不需要添加STARTUP中的文件。 添加完毕点击OK。</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910140251.jpg" alt="20200910140251.jpg" style="zoom:67%;" /><p>然后点击魔法棒，进入C&#x2F;C++设置界面，在define一栏输入 USE_STDPERIPH_DRIVER ，并在includepath栏加入头文件路径。</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910142503.jpg" alt="20200910142503.jpg" style="zoom:67%;" /><p> 至此，工程创建完毕。</p><h3 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h3><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910144354.jpg" alt="20200910144354.jpg" style="zoom:67%;" /><p>根据需求选择编译的方式，在下方输出窗口可以看到<strong>报错</strong>和<strong>警告</strong>。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><h4 id="硬件仿真调试"><a href="#硬件仿真调试" class="headerlink" title="硬件仿真调试"></a>硬件仿真调试</h4><p>进入调试模式：</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910220914.jpg" alt="20200910220914.jpg" style="zoom:50%;" /><p>调试面板详解：</p><ol><li><p>调试选项</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910221608.jpg" alt="20200910221608.jpg" style="zoom: 33%;" /></li><li><p>面板内容</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910222017.jpg" alt="20200910222017.jpg" style="zoom:33%;" /></li></ol><h4 id="软件仿真调试"><a href="#软件仿真调试" class="headerlink" title="软件仿真调试"></a>软件仿真调试</h4><p>修改魔法棒中Debug选项卡，如图：</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/12/20200912163606.jpg" alt="20200912163606.jpg" style="zoom: 33%;" /><p>Dialog DLL改为  DARMSTM.DLL</p><p>Parameter改为  -pSTM32F103C8（此项根据具体型号而定）</p><p><strong>以引脚的逻辑分析为例</strong></p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/12/20200912164024.jpg" alt="20200912164024.jpg" style="zoom:33%;" /><p>设置想要检测的引脚：</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/12/20200912164436.jpg" alt="20200912164436.jpg" style="zoom:50%;" /><p>点击<strong>run</strong>即可查看引脚电平图像：</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/12/20200912164609.jpg" alt="20200912164609.jpg" style="zoom:33%;" /><h3 id="用KEIL开发stm32开发底层程序"><a href="#用KEIL开发stm32开发底层程序" class="headerlink" title="用KEIL开发stm32开发底层程序"></a>用KEIL开发stm32开发底层程序</h3><p>在User文件夹下编写程序。</p><p>以点灯为例（使用库函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>GPIO_InitTypeDef GPIO_InitStructure; <span class="hljs-comment">//定义GPIO初始化结构体</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);<span class="hljs-comment">//开启对应时钟</span><br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;<span class="hljs-comment">//选择控制引脚</span><br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="hljs-comment">//设置引脚模式为通用推挽输出</span><br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="hljs-comment">//设置引脚速率为50MHz</span><br>GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<span class="hljs-comment">//初始化GPIO</span><br><br>GPIO_ResetBits(GPIOC, GPIO_Pin_13);<span class="hljs-comment">//点灯</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="下载编译过后的代码"><a href="#下载编译过后的代码" class="headerlink" title="下载编译过后的代码"></a>下载编译过后的代码</h3><p>以ST-Link仿真器为例。</p><ol><li><p>安装并更新仿真器驱动。</p></li><li><p>用仿真器连接开发板。</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/P00910-144702.jpg" alt="P00910-144702.jpg" style="zoom:10%;" /></li><li><p>设置魔法棒</p><p>选择ST-Link进行调试</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910150123.jpg" alt="20200910150123.jpg" style="zoom: 50%;" /><p>Flash下载设置</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910150151.jpg" alt="20200910150151.jpg" style="zoom:67%;" /></li><li><p>点击下载</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910150450.jpg" alt="20200910150450.jpg" style="zoom: 50%;" /></li><li><p>查看运行情况</p><p>灯泡点亮，程序正在运行。</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/P00910-1507401.jpg" alt="P00910-1507401.jpg" style="zoom: 10%;" /></li></ol><h3 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h3><p>在左侧寄存器面板查看：</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/10/20200910222017.jpg" alt="20200910222017.jpg" style="zoom:33%;" /><p>具体的寄存器含义：</p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/11/20200911080847.jpg" alt="20200911080847.jpg" style="zoom:67%;" /><h3 id="查看生成代码的地址"><a href="#查看生成代码的地址" class="headerlink" title="查看生成代码的地址"></a>查看生成代码的地址</h3><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/09/11/TZ8P67FZ29H9UIXV2YL.png" alt="TZ8P67FZ29H9UIXV2YL.png" style="zoom: 33%;" /><p>也可以在右下方<strong>Memory1</strong>选项卡中<strong>查看</strong>和<strong>修改</strong>内存中存储的数据。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Embedded</category>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
      <tag>keil</tag>
      
      <tag>embedded</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为Matebook14解除CPU、GPU温度墙与功耗墙</title>
    <link href="/2020/08/matebook14-gpu-cpu/"/>
    <url>/2020/08/matebook14-gpu-cpu/</url>
    
    <content type="html"><![CDATA[<p>最近（2020年8月）开学又拿出了我封存半年的Matebook，开机第一件事还是像往常一样更新驱动、更新系统。但是用着用着就发现问题来了。之前全高特效LOL都能无压力运行，但是这下最低画质也卡成PPT，再看一看系统功耗和CPU温度，稳定在了15W&#x2F;70°。大事不妙！这个版本的驱动加强了功耗和温度限制，性能大幅缩水了！为了确认这一现象我赶快跑了跑AIDA64，果不其然，出大问题！</p><p>开始还指望售后帮我搞定，最后emmm，吐槽一波华为售后客服，啥都不懂。真要解决这个墙还是得靠自己。</p><p><strong>BIOS版本：1.16</strong></p><p><strong>DPTF版本：8.5.10103.7263</strong></p><h3 id="CPU性能限制解除"><a href="#CPU性能限制解除" class="headerlink" title="CPU性能限制解除"></a>CPU性能限制解除</h3><p>查询了多方资料和实验最终确定华为是利用<strong>DPTF</strong>来控制<strong>CPU的功耗</strong>，进而控制<strong>CPU的温度</strong>。</p><p>要解决掉DPTF，最简单的方法就是解决掉DPTF驱动</p><p><strong>打开任务管理器</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/08/27/dptf.jpg" alt="dptf.jpg"></p><p>卸载前，分别打开设备的属性，查看其硬件Id，并将硬件Id的值都复制下来。</p><p>三个ID都复制下来。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/08/27/id.jpg" alt="id.jpg"></p><p>然后Win+R输入gpedit.msc打开组策略编辑器，在计算机配置-管理模板-系统-设备安装-设备安装限制-阻止安装与下列任何设备ID相匹配的设备，选择启用，并将刚才复制出来的硬件Id都填到表格中。</p><p><em>这一步主要是防止电脑自动安装DPTF导致每次都得重新设置</em></p><p><strong>卸载这个DPTF驱动</strong></p><p><strong>重启电脑</strong></p><p><strong>安装Intel® Extreme Tuning Utility (Intel® XTU)：</strong></p><p>下载地址：<a href="https://downloadcenter.intel.com/download/29183/Intel-Extreme-Tuning-Utility-Intel-XTU-">XTU</a></p><p>手动调试CPU</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2020/08/27/XTU.jpg" alt="XTU.jpg"></p><p>主要调整Core参数：</p><p>1.核心电压降低-0.15V，来减少发热（看自己CPU的体制）。</p><p>2.瞬时睿频功率拉到30W就够了，问题不是很大。</p><p>3.最高功耗限制拉到25W，这本子太高了散热压不住，25W比官方的15W已经提升了很多性能了。</p><p>调整好了之后运行<strong>压力测试</strong>，验证一下是否调整成功。</p><p><strong>特别注释</strong>：如果确实不行的话建议卸载华为电脑管家重试。或者还是不行，可以安装纯净版的win10再来操作。我就是直接重新安装的官方版的win10来进行调整的。</p><h3 id="GPU性能限制解除"><a href="#GPU性能限制解除" class="headerlink" title="GPU性能限制解除"></a>GPU性能限制解除</h3><p>根据我这几天的研究基本可以确定GPU的限制也是软墙，温度墙设置在了69°</p><p>原本MX250标准25W的TDP当撞到温度墙的时候频率降得惨不忍睹，这也是玩游戏出现严重掉帧的主要问题。</p><p>修改GPU温度墙就只需要ASUS GPUTweak II就够了。下载地址：[GPUTweak II](<a href="https://www.asus.com.cn/supportonly/GPUTweak">https://www.asus.com.cn/supportonly/GPUTweak</a> II&#x2F;HelpDesk_Download&#x2F;)</p><p><strong>如果出现安装失败或者BIOS加载失败建议先卸载华为电脑管家，或者安装纯净版win10</strong></p><p>安装好并重启后系统就默认将温度墙设置为了94°，也可以根据自己的需要来自定义设置。</p><p>之后就来一把LOL测下帧率哇，我的又飞到快100帧了，出奇流畅。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>这样的操作可以最大限度地自定义芯片性能，但是伴随的发热和功耗问题就自己权衡，需要性能的时候牺牲一点散热，需要续航的时候就牺牲一点性能。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>IT小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>matebook</tag>
      
      <tag>cpu</tag>
      
      <tag>gpu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派安装raspi-config扩展SD卡空间</title>
    <link href="/2020/08/raspi-config-sd/"/>
    <url>/2020/08/raspi-config-sd/</url>
    
    <content type="html"><![CDATA[<p>在进行树莓派img文件备份还原的时候往往会由于备份设备的SD卡的分区大小，限制输入新的设备后的SD卡空间大小。一般来说扩展空间到整张SD卡可以自行手动采用fdisk工具进行修改，不过过程相对繁琐。这里不妨借助raspi-config工具进行一键修改。</p><h2 id="原生Raspbian系统"><a href="#原生Raspbian系统" class="headerlink" title="原生Raspbian系统"></a>原生Raspbian系统</h2><p>输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo raspi-config --expand-rootfs<br></code></pre></td></tr></table></figure><p>然后重启即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">reboot<br></code></pre></td></tr></table></figure><h2 id="非原生系统"><a href="#非原生系统" class="headerlink" title="非原生系统"></a>非原生系统</h2><h3 id="安装raspi-config"><a href="#安装raspi-config" class="headerlink" title="安装raspi-config"></a>安装raspi-config</h3><ol><li><p>手动下载deb包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://mirrors.ustc.edu.cn/archive.raspberrypi.org/pool/main/r/raspi-config/raspi-config_20171201_all.deb<br></code></pre></td></tr></table></figure></li><li><p>解决依赖问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install whiptail parted lua5.1 alsa-utils psmisc<br></code></pre></td></tr></table></figure></li><li><p>安装软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -i raspi-config_20171201_all.deb<br></code></pre></td></tr></table></figure></li></ol><h3 id="扩展空间"><a href="#扩展空间" class="headerlink" title="扩展空间"></a>扩展空间</h3><p>运行raspi-config，需要sudo或以上权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo raspi-config --expand-rootfs<br></code></pre></td></tr></table></figure><p>然后重启即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">reboot<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry-pi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trojan+web 443端口复用配置</title>
    <link href="/2020/08/trojanweb-443/"/>
    <url>/2020/08/trojanweb-443/</url>
    
    <content type="html"><![CDATA[<h2 id="一键脚本"><a href="#一键脚本" class="headerlink" title="一键脚本"></a>一键脚本</h2><p>安装</p><p><code>source &lt;(curl -sL https://git.io/trojan-install)</code></p><p>shanchu</p><p><code>source &lt;(curl -sL https://git.io/trojan-install) --remove</code></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>1、VPS一台内存最好1GB左右，重置任意可安装宝塔面板的系统（建站推荐CentOS7X以上，或者是CentOS8X）</p><p>2、一级域名一个做好相应的解析（今天作者解析的域名为：jason-xy.online | <a href="http://www.jason-xy.online)/">www.jason-xy.online）</a></p><p>（分别解析主域名和www的二级域名到VPS主机。）</p><h2 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h2><p>我们访问 jason-xy.online 及 <a href="http://www.jason-xy.online/">www.jason-xy.online</a> 均能使用 https 的方式，也就是正常访问我们的博客。</p><p>使用Trojan客户端连接 <a href="http://www.jason-xy.online/">www.jason-xy.online</a> 可以正常科学上网。</p><h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><h3 id="1、连接VPS并安装宝塔面板"><a href="#1、连接VPS并安装宝塔面板" class="headerlink" title="1、连接VPS并安装宝塔面板"></a>1、连接VPS并安装宝塔面板</h3><p>以下一键安装宝塔面板的代码仅仅局限CentOS系统的用户，其他用户请访问 <a href="https://www.v2rayssr.com/go?url=https://bt.cn/bbs/thread-19376-1-1.html">这里</a> 查看安装命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.shCOPY<br></code></pre></td></tr></table></figure><p>安装完毕以后，请自行记录宝塔面板的登录地址，并登录宝塔面板。</p><h3 id="2、安装建站需要的必要插件"><a href="#2、安装建站需要的必要插件" class="headerlink" title="2、安装建站需要的必要插件"></a>2、安装建站需要的必要插件</h3><p>登录以后，在弹出的窗口环境中选择自己需要安装的环境。</p><p>（若是使用 WordPress 的博客，请依次安装 Nginx1.18、MySQL5.6、PHP7.4，其他非必要环境作者不想安装就略过了）</p><h3 id="3、创建网站"><a href="#3、创建网站" class="headerlink" title="3、创建网站"></a>3、创建网站</h3><p>因为作者使用 WordPress 博客的 CMS，所以选择宝塔的一键部署。</p><p>分别点击 “软件商店” – “一键部署” ，找到 WordPress 并选择一键部署，填写我们刚才解析好的两个域名。</p><h3 id="4、设置网站数据库并配置网站"><a href="#4、设置网站数据库并配置网站" class="headerlink" title="4、设置网站数据库并配置网站"></a>4、设置网站数据库并配置网站</h3><p>部署完毕以后，输入我们绑定的域名进行数据库配置及网站设置。</p><h3 id="5、修改默认的-Nginx-配置"><a href="#5、修改默认的-Nginx-配置" class="headerlink" title="5、修改默认的 Nginx 配置"></a>5、修改默认的 Nginx 配置</h3><p>找到 “软件商店” – “已安装” – “Nginx1.18”，设置 Nginx 的配置信息</p><p>在 http 模块前面增加如下代码，按照自己的需求进行更改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">stream <span class="hljs-punctuation">&#123;</span><br>    # 这里就是 SNI 识别，将域名映射成一个配置名<br>    map $ssl_preread_server_name $backend_name <span class="hljs-punctuation">&#123;</span><br>        jason-xy.online web;<br>        www.jason-xy.online trojan;<br>    # 域名都不匹配情况下的默认值<br>        default web;<br>    <span class="hljs-punctuation">&#125;</span><br><br>    # web，配置转发详情<br>    upstream web <span class="hljs-punctuation">&#123;</span><br>        server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-punctuation">:</span><span class="hljs-number">4433</span>;<br>    <span class="hljs-punctuation">&#125;</span><br><br>    # trojan，配置转发详情<br>    upstream trojan <span class="hljs-punctuation">&#123;</span><br>        server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-punctuation">:</span><span class="hljs-number">10110</span>;<br>    <span class="hljs-punctuation">&#125;</span><br><br>    # 监听 <span class="hljs-number">443</span> 并开启 ssl_preread<br>    server <span class="hljs-punctuation">&#123;</span><br>        listen <span class="hljs-number">443</span> reuseport;<br>        listen <span class="hljs-punctuation">[</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">:</span><span class="hljs-number">443</span> reuseport;<br>        proxy_pass  $backend_name;<br>        ssl_preread on;<br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span>COPY<br></code></pre></td></tr></table></figure><h3 id="6、在线申请-SSL-证书"><a href="#6、在线申请-SSL-证书" class="headerlink" title="6、在线申请 SSL 证书"></a>6、在线申请 SSL 证书</h3><p>在网站设置里面，勾选两个绑定的域名，并为其申请 SSL 证书和开启强制 Https 的访问。</p><h3 id="7、修改网站的Nginx配置文件"><a href="#7、修改网站的Nginx配置文件" class="headerlink" title="7、修改网站的Nginx配置文件"></a>7、修改网站的Nginx配置文件</h3><p>在网站设置里面开启 “伪静态” 为 WordPress ，然后转到配置文件设置。</p><p>删除在 server 模块下面的 server_name 里面的 二级域名，只保留主域名。</p><p>在原有的 server 模块下面增加如下代码（请自行替换域名）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json">server<br><span class="hljs-punctuation">&#123;</span><br>    listen <span class="hljs-number">10111</span>;<br>    server_name www.jason-xy.online;<br>    location / <span class="hljs-punctuation">&#123;</span><br><br>        if ($http_host !~ <span class="hljs-string">&quot;^jason-xy.online$&quot;</span>) <span class="hljs-punctuation">&#123;</span><br>          rewrite  ^(.*)    https<span class="hljs-punctuation">:</span><span class="hljs-comment">//jason-xy.cn$1 permanent;</span><br>        <span class="hljs-punctuation">&#125;</span><br><br>       if ($server_port !~ <span class="hljs-number">4433</span>)<span class="hljs-punctuation">&#123;</span><br>        rewrite ^(.*)   https<span class="hljs-punctuation">:</span><span class="hljs-comment">//jason-xy.cn$1 permanent;</span><br>    <span class="hljs-punctuation">&#125;</span><br><br>        proxy_redirect off;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br><br>    <span class="hljs-punctuation">&#125;</span><br>    access_log logs/aaa.com_access.log;<br><span class="hljs-punctuation">&#125;</span>COPY<br></code></pre></td></tr></table></figure><p><strong>更改完毕以后，请回到 Nginx 设置界面，重启 Nginx 服务。</strong></p><h3 id="8、安装官方Trojan服务"><a href="#8、安装官方Trojan服务" class="headerlink" title="8、安装官方Trojan服务"></a>8、安装官方Trojan服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo bash -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/trojan-gfw/trojan-quickstart/master/trojan-quickstart.sh)</span>&quot;</span>COPY<br></code></pre></td></tr></table></figure><p>设置Trojan开启自动启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> trojan   <span class="hljs-comment">#设置Trojan开启自动启动COPY</span><br></code></pre></td></tr></table></figure><h3 id="9、修改Trojan配置文件"><a href="#9、修改Trojan配置文件" class="headerlink" title="9、修改Trojan配置文件"></a>9、修改Trojan配置文件</h3><p>找到VPS以下文件 &#x2F;usr&#x2F;local&#x2F;etc&#x2F;trojan&#x2F;config.json 修改为如下代码：（自行更改密码和域名证书路径）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;run_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;server&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;local_addr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;local_port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10110</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;remote_addr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;remote_port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10111</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;321321321&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;log_level&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;ssl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;cert&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/www/server/panel/vhost/cert/jason-xy.online/fullchain.pem&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/www/server/panel/vhost/cert/jason-xy.online/privkey.pem&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;key_password&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;cipher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;cipher_tls13&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;prefer_server_cipher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;alpn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;http/1.1&quot;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;alpn_port_override&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;h2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">81</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;reuse_session&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;session_ticket&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;session_timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">600</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;plain_http_response&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;curves&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dhparam&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tcp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;prefer_ipv4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;no_delay&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keep_alive&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;reuse_port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;fast_open&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;fast_open_qlen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;mysql&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;server_addr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;server_port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3306</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;database&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;trojan&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;trojan&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;cert&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ca&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span>COPY<br></code></pre></td></tr></table></figure><p>更改完毕以后，上传并保存，然后重启Trojan服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart trojanCOPY<br></code></pre></td></tr></table></figure><h3 id="10、搭建和设置完毕"><a href="#10、搭建和设置完毕" class="headerlink" title="10、搭建和设置完毕"></a>10、搭建和设置完毕</h3><p>现在，你就可以连接你的Trojan节点了，网站也可以正常的访问了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>IT小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>proxy</tag>
      
      <tag>trojan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>void*是怎样的存在？</title>
    <link href="/2020/08/detail-of-void/"/>
    <url>/2020/08/detail-of-void/</url>
    
    <content type="html"><![CDATA[<p>——转载自知乎<a href="https://zhuanlan.zhihu.com/p/98061960">void*是怎样的存在</a></p><p>说到C就不得不提指针，而一提到指针，有一个是比较特殊的，那就是<code>void*</code>。<code>void*</code>到底是怎样的存在？</p><h2 id="指针类型的含义"><a href="#指针类型的含义" class="headerlink" title="指针类型的含义"></a><strong>指针类型的含义</strong></h2><p>在说明<code>void*</code>之前，先了解一下普通指针类型的含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//来源：公众号【编程珠玑】</span><br><span class="hljs-comment">//main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">0x01020304</span>,<span class="hljs-number">2019</span>&#125;;<br>    <span class="hljs-type">int</span> *b = a;<br>    <span class="hljs-type">char</span> *c = (<span class="hljs-type">char</span>*)&amp;a[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b+1:%d\n&quot;</span>,*(b+<span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c+1:%d\n&quot;</span>,*(c+<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">b+1:2019<br>c+1:3<br></code></pre></td></tr></table></figure><p>对于上面的结果，也许你并不感到意外。如果你的疑问是为什么不是2而是3，那么建议你想想同样是指针类型，b和c有什么区别？</p><p>一个是指向整型的指针，一个是指向char型的指针，当它们执行算术运算时，它们的步长就是对应类型占用空间大小。</p><p>即</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">b + 1 //移动sizeof(int)字节<br></code></pre></td></tr></table></figure><p>040302012019字节0字节1字节2字节3字节4~7</p><p>指针移动4个字节后，指向的就是2019了，解引用自然得到2019。而对于c</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">c + 1 //移动sizeof(char)字节<br></code></pre></td></tr></table></figure><p>它的指向如下：040302012019字节0字节1字节2字节3字节4~7</p><p>解引用之后，自然得到3。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>各种类型之间没有本质区别，只是解释内存中的数据方式不同。例如，对于int型指针b，解引用时，会解析4字节，算术运算时，也是以该类型占用空间大小为单位，所以b+1，移动4字节，解引用，处理4字节内容，得到2019。对于char型指针c，解引用时，会解析1个字节，算术运算时，也是以sizeof(char)为单位，所以c+1，移动一字节，解引用，处理1字节，得到03。所以像下面这样的操作：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">char a[] = &#123;01,02,03,04&#125;;<br>int *b = (int*)(a+2);<br></code></pre></td></tr></table></figure><p>如果你试图解引用b，即*b，就可能遇到无法预料的问题，因为将会访问非法内存位置。a+2，移动sizeof(char)字节，指向03，此时按照int类型指针解引用，由于int类型解引用会处理4字节内存，但是后面已经没有属于数组a的合法内容了，因此可能出错。</p><h2 id="指针占用空间大小"><a href="#指针占用空间大小" class="headerlink" title="指针占用空间大小"></a><strong>指针占用空间大小</strong></h2><p>正由于它们没有本质区别，它们占用空间大小在同一个程序中都是固定的，对于32位程序，占用4字节空间，64位占用8字节，而正因如此，64位程序理论能使用的内存是足够大的，而32位程序理论上能使用的不过4G（2^（4*8bit)），再加上内核空间的使用，真正能用到的可能就3G左右。如果你的系统是64位的，那么默认情况下，编译出来的程序也是64位的。如果你想编译为32位，可以使用-m32参数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ gcc -m32 -o main main.c<br></code></pre></td></tr></table></figure><p>如何确定是多少位的程序：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">$ readelf -h main<br>Class:                             ELF32<br></code></pre></td></tr></table></figure><p>上面的ELF32，表明了它是32位程序。或者可以看Machine字段：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Machine:                           Intel 80386<br></code></pre></td></tr></table></figure><h2 id="void"><a href="#void" class="headerlink" title="void*"></a><strong>void*</strong></h2><p>说回void*，前面说了，指针的类型不过是解释数据的方式不同罢了，这样的道理也可用于很多场合的强制类型转换，例如将int类型指针转换为char型指针，并不会改变内存的实际内容，只是修改了解释方式而已。而void *是一种无类型指针，任何类型指针都可以转为<code>void\*</code>，它无条件接受各种类型。而既然是无类型指针，那么就不要尝试做下面的事情：</p><ul><li>解引用</li><li>算术运算</li></ul><p>由于不知道其解引用操作的内存大小，以及算术运算操作的大小，因此它的结果是未知的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> *b = &amp;a;<br>    <span class="hljs-type">void</span> *c = b;<br>    *c;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译警告如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">warning: dereferencing ‘void *’ pointer<br></code></pre></td></tr></table></figure><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a><strong>如何使用</strong></h2><p>既然如此，那么void<em>有什么用呢？实际上我们在很多接口中都会发现它们的参数类型都是void</em>,例如:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">ssize_t read(int fd, void *buf, size_t count);<br>void *memcpy(void *dest, const void *src, size_t n);<br></code></pre></td></tr></table></figure><p>为何要如此设计？因为对于这种通用型接口，你不知道用户的数据类型是什么，但是你必须能够处理用户的各种类型数据，因而会使用void<em>。void</em>能包容地接受各种类型的指针。也就是说，如果你期望接口能够接受任何类型的参数，你可以使用void<em>类型。但是在具体使用的时候，你必须转换为具体的指针类型。例如，你传入接口的是int</em>，那么你在使用的时候就应该按照int*使用。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h2><p>使用void*需要特别注意的是，你必须清楚原始传入的是什么类型，然后转换成对应类型。例如，你准备使用库函数qsort进行排序：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">void qsort(void *base,size_t nmemb,size_t size , int(*compar)(const void *,const void *));<br></code></pre></td></tr></table></figure><p>它的第三个参数就是比较函数，它接受的参数都是const void*，如果你的比较对象是一个结构体类型，那么你自己在实现compar函数的时候，也必须是转换为该结构体类型使用。举个例子，你要实现学生信息按照成绩比较：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student_tag</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> name[STU_NAME_LEN];  <span class="hljs-comment">//学生姓名</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id;          <span class="hljs-comment">//学生学号</span><br>    <span class="hljs-type">int</span> score;                <span class="hljs-comment">//学生成绩</span><br>&#125;<span class="hljs-type">student_t</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">studentCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *stu1,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *stu2)</span><br>&#123;<br>　　<span class="hljs-comment">/*强转成需要比较的数据结构*/</span><br>    <span class="hljs-type">student_t</span> *value1 = (<span class="hljs-type">student_t</span>*)stu1;<br>    <span class="hljs-type">student_t</span> *value2 = (<span class="hljs-type">student_t</span>*)stu2;<br>    <span class="hljs-keyword">return</span> value1-&gt;score-value2-&gt;score;<br>&#125;<br></code></pre></td></tr></table></figure><p>在将其传入<code>studentCompare</code>函数后，必须转换为其对应的类型进行处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>void<em>很强大，但是一定要在合适的时候使用；同时强转很逆天，但是一定要注意前后的类型是否真的能正确转换。通俗地说void</em>：</p><ul><li>这里有一片内存数据，我也不知道什么类型，给你了，你自己想怎么用怎么用吧，不过要用对奥！</li><li>我这里什么类型都能处理，你给我一片内存数据就可以了</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>c/c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manjaro 切换国内源及中文输入法安装</title>
    <link href="/2020/07/manjaro-ifly/"/>
    <url>/2020/07/manjaro-ifly/</url>
    
    <content type="html"><![CDATA[<h1 id="配置国内源"><a href="#配置国内源" class="headerlink" title="配置国内源"></a>配置国内源</h1><p>1.配置镜像源:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman-mirrors -i -c China -m rank<br></code></pre></td></tr></table></figure><p>2.设置 archlinuxcn 源,antergos源,arch4edu源:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/pacman.conf<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs conf">[archlinuxcn]#选一个就行了<br>SigLevel = Optional TrustedOnly<br>#中科大源<br>Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch<br>#清华源<br>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch<br><br>[antergos]<br>SigLevel = TrustAll<br>Server = https://mirrors.tuna.tsinghua.edu.cn/antergos/$repo/$arch<br><br>[arch4edu]<br>SigLevel = TrustAll<br>Server = https://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch<br></code></pre></td></tr></table></figure><p>3.更新源列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman-mirrors -g<br></code></pre></td></tr></table></figure><p>4.更新pacman数据库并全面更新系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Syyu<br></code></pre></td></tr></table></figure><p>5.防止PGP签名错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S archlinuxcn-keyring<br>sudo pacman -S antergos-keyring<br></code></pre></td></tr></table></figure><p>6.为了安装使用aur方便，也可以额外安装一下yaourt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S yaourt<br></code></pre></td></tr></table></figure><p>7.yaourt 用户<br>添加之前首先备份原文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /etc/yaourtrc /etc/yaourtrc.backup<br></code></pre></td></tr></table></figure><p>修改 &#x2F;etc&#x2F;yaourtrc配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano /etc/yaourtrc<br></code></pre></td></tr></table></figure><p>去掉 # AURURL 的注释,并修改</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">AURURL=“https:<span class="hljs-regexp">//</span>aur.tuna.tsinghua.edu.cn”<br></code></pre></td></tr></table></figure><p>8.yay 用户</p><p>执行以下命令修改 aururl :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yay --aururl “https://aur.tuna.tsinghua.edu.cn” --save<br></code></pre></td></tr></table></figure><h1 id="讯飞输入法"><a href="#讯飞输入法" class="headerlink" title="讯飞输入法"></a>讯飞输入法</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yay -S iflyime<br></code></pre></td></tr></table></figure><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">//回到home目录</span><br>cd ~<br>vim .xprofile<br><span class="hljs-comment">//写入</span><br><span class="hljs-keyword">export</span> GTK_IM_MODULE=fcitx  <br><span class="hljs-keyword">export</span> QT_IM_MODULE=fcitx <br><span class="hljs-keyword">export</span> XMODIFIERS=<span class="hljs-keyword">@im</span>=fcitx<br></code></pre></td></tr></table></figure><p>注销后登录，就可以愉快打字啦。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>ENV</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用树莓派搭建私有云盘</title>
    <link href="/2020/07/raspi-nextcloud/"/>
    <url>/2020/07/raspi-nextcloud/</url>
    
    <content type="html"><![CDATA[<ol><li><p>通过内网穿透实现外网访问。</p><p><a href="https://jason-xy.cn/2020/07/frp/">frp内网穿透方案</a></p></li><li><p>部署NextCloud-Docker</p></li></ol><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>请参考文章：frp内网穿透方案。</p><h2 id="NextCloud-Docker"><a href="#NextCloud-Docker" class="headerlink" title="NextCloud-Docker"></a>NextCloud-Docker</h2><p>选择docker部署的主要原因还是相对来说方便部署，一行代码即可完成傻瓜式部署。</p><h3 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h3><p>前提条件：</p><ol><li><p>你已经安装好了<code>docker</code>和<code>docker-compose</code></p><p><a href="https://jason-xy.cn/2020/07/docker_portainer/">Docker部署及Portainer可视化面板搭建</a></p><p><a href="https://jason-xy.cn/2020/07/docker-compose/">Docker Compose部署</a></p></li><li><p>创建<code>nextcloud</code>文件夹，然后在文件夹中创建<code>docker-compose.yml</code>（相当于Docker镜像部署脚本）</p><p><code>docker-compose.yml</code>文件内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">ibex/debian-mysql-server-5.7</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./cloud/db:/var/lib/mysql</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=ROOT密码</span> <span class="hljs-comment"># 根据需要替换</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_PASSWORD=数据库密码</span> <span class="hljs-comment"># 根据需要替换</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_DATABASE=nextcloud</span> <span class="hljs-comment"># 根据需要替换</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_USER=nextcloud</span> <span class="hljs-comment"># 根据需要替换</span><br><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nextcloud</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8888</span><span class="hljs-string">:80</span>  <span class="hljs-comment"># 端口映射，将Docker的80端口，映射成主机的8888端口。根据需要可以自行修改。</span><br>    <span class="hljs-attr">links:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./cloud/config:/var/www/html/config</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/pi/disk/nextCloud:/var/www/html/data</span> <span class="hljs-comment"># 因为树莓派本身存储太小，这里是映射到一个外置2T硬盘</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./cloud/apps:/var/www/html/apps</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure></li></ol><p>执行脚本：</p><p>在当前目录下（<code>nextcloud</code>文件夹）执行下面命令，Docker会根据我们的配置，自动下载镜像并启动程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><p>如果一切正常，这时候，访问<code>IP:8888</code> 就会出现 NextCloud界面。<br>第一次启动，需要配置<code>数据库</code>和<code>账户</code>才可以正常使用。<br>配置完毕，网盘就可以正常使用了。</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/docker_nextcloud/1.jpg" style="zoom:80%;" /><h3 id="扩展资料："><a href="#扩展资料：" class="headerlink" title="扩展资料："></a>扩展资料：</h3><blockquote><h4 id="关于外置硬盘问题："><a href="#关于外置硬盘问题：" class="headerlink" title="关于外置硬盘问题："></a>关于外置硬盘问题：</h4></blockquote><blockquote><p>树莓派空间实在太小，不适合做存储。<br>这里我使用了一个2T 的移动硬盘作为存储设备。<br>关于挂载硬盘，并且开机自动挂载，可以参考Linux移动硬盘挂载</p></blockquote><blockquote><h4 id="添加不受信任的域名"><a href="#添加不受信任的域名" class="headerlink" title="添加不受信任的域名"></a>添加不受信任的域名</h4><p>Nextcloud初始化完毕后，会生成  <code>/var/www/nextcloud/config/config.php</code>  配置文件，里面的 <code>trusted_domains</code>  配置项为信任域名，初始化完毕后只有一项，为主机的IP地址。可以修改该配置项，添加绑定的域名。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-string">&#x27;trusted_domains&#x27;</span> =&gt; <br><span class="hljs-keyword">array</span> (<br><span class="hljs-number">0</span> =&gt; <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br><span class="hljs-number">1</span> =&gt; <span class="hljs-string">&#x27;xxx.yyyyy.com&#x27;</span>,  <span class="hljs-comment"># 将这个自定义域名添加到配置中</span><br>),<br></code></pre></td></tr></table></figure></blockquote><blockquote><h4 id="使用SqLite数据库"><a href="#使用SqLite数据库" class="headerlink" title="使用SqLite数据库"></a>使用SqLite数据库</h4><p>不想使用MySQL，或者个人使用时，可以使用Sqlite数据库，配置更简单。<br>docker-compose.yml 文件内容修改如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><br><br><span class="hljs-attr">app:</span><br> <span class="hljs-attr">image:</span> <span class="hljs-string">nextcloud</span><br> <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8888</span><span class="hljs-string">:80</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./cloud/config:/var/www/html/config</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/pi/disk/nextCloud:/var/www/html/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./cloud/apps:/var/www/html/apps</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry-pi</tag>
      
      <tag>docker</tag>
      
      <tag>cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>frp内网穿透方案</title>
    <link href="/2020/07/frp/"/>
    <url>/2020/07/frp/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。</p><p>GitHub项目地址：<a href="https://github.com/fatedier/frp">frp</a></p><h3 id="frp-的作用"><a href="#frp-的作用" class="headerlink" title="frp 的作用"></a>frp 的作用</h3><ul><li>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</li><li>对于 http 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</li><li>利用处于内网或防火墙后的机器，对外网环境提供 tcp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</li><li>可查看通过代理的所有 http 请求和响应的详细信息。（待开发）</li></ul><h3 id="开发状态"><a href="#开发状态" class="headerlink" title="开发状态"></a>开发状态</h3><p>frp 目前正在前期开发阶段，master 分支用于发布稳定版本，dev 分支用于开发，您可以尝试下载最新的 release 版本进行测试。</p><p>目前的交互协议可能随时改变，不能保证向后兼容，升级新版本时需要注意公告说明。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>根据对应的操作系统及架构，从 <a href="https://github.com/fatedier/frp/releases">Release</a> 页面下载最新版本的程序。</p><p>将 frps 及 frps.ini 放到有公网 IP 的机器上。</p><p>将 frpc 及 frpc.ini 放到处于内网环境的机器上。</p><h3 id="通过-ssh-访问内网机器"><a href="#通过-ssh-访问内网机器" class="headerlink" title="通过 ssh 访问内网机器"></a>通过 ssh 访问内网机器</h3><ol><li><p>修改 frps.ini 文件，配置一个名为 ssh 的反向代理：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># frps.ini</span><br><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span> <span class="hljs-comment">#frp服务端口</span><br><br><span class="hljs-section">[ssh]</span><br><span class="hljs-attr">listen_port</span> = <span class="hljs-number">6000</span> <span class="hljs-comment">#你转发的服务在外网访问的端口</span><br><span class="hljs-attr">auth_token</span> = <span class="hljs-number">123</span> <span class="hljs-comment">#连接密码</span><br></code></pre></td></tr></table></figure></li><li><p>启动frps：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./frps -c ./frps.ini //debug时候用，直接在终端启动<br><span class="hljs-built_in">nohup</span> ./frps -c ./frps.ini &amp; //后台启动<br></code></pre></td></tr></table></figure></li><li><p>修改 frpc.ini 文件，设置 frps 所在服务器的 IP 为 x.x.x.x：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># frpc.ini</span><br><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = x.x.x.x<br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-attr">auth_token</span> = <span class="hljs-number">123</span><br><br><span class="hljs-section">[ssh]</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">22</span> <br></code></pre></td></tr></table></figure></li><li><p>启动 frpc：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./frpc -c ./frpc.ini //debug时候用，直接在终端启动<br><span class="hljs-built_in">nohup</span> ./frpc -c ./frpc.ini &amp; //后台启动<br></code></pre></td></tr></table></figure></li><li><p>通过 ssh 访问内网机器，假设用户名为 test：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -oPort=6000 <span class="hljs-built_in">test</span>@x.x.x.x<br></code></pre></td></tr></table></figure></li></ol><h3 id="通过指定域名访问部署于内网的-web-服务"><a href="#通过指定域名访问部署于内网的-web-服务" class="headerlink" title="通过指定域名访问部署于内网的 web 服务"></a>通过指定域名访问部署于内网的 web 服务</h3><p>有时想要让其他人通过域名访问或者测试我们在本地搭建的 web 服务，但是由于本地机器没有公网 IP，无法将域名解析到本地的机器，通过 frp 就可以实现这一功能，以下示例为 http 服务，https 服务配置方法相同， vhost_http_port 替换为 vhost_https_port， type 设置为 https 即可。</p><ol><li><p>修改 frps.ini 文件，配置一个名为 web 的 http 反向代理，设置 http 访问端口为 8080，绑定自定义域名 <a href="http://www.yourdomain.com/">www.yourdomain.com</a>:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># frps.ini</span><br><span class="hljs-section">[common]</span> <span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-attr">vhost_http_port</span> = <span class="hljs-number">8080</span> <span class="hljs-comment">#用于http服务的端口</span><br></code></pre></td></tr></table></figure></li><li><p>启动frps：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./frps -c ./frps.ini //debug时候用，直接在终端启动<br><span class="hljs-built_in">nohup</span> ./frps -c ./frps.ini &amp; //后台启动<br></code></pre></td></tr></table></figure></li><li><p>修改 frpc.ini 文件，设置 frps 所在的服务器的 IP 为 x.x.x.x，local_port 为本地机器上 web 服务对应的端口：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># frpc.ini</span><br><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = x.x.x.x<br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-attr">auth_token</span> = <span class="hljs-number">123</span><br><br><span class="hljs-section">[web1]</span><br><span class="hljs-attr">type</span> = http<br><span class="hljs-attr">local_port</span> = <span class="hljs-number">80</span><br><span class="hljs-attr">custom_domains</span> = www.yourdomain1.com <span class="hljs-comment">#自定义域名，需要备案且解析到服务器。</span><br><br><span class="hljs-section">[web2]</span> <span class="hljs-comment">#当有多个web服务时</span><br><span class="hljs-attr">type</span> = http<br><span class="hljs-attr">local_port</span> = <span class="hljs-number">81</span><br><span class="hljs-attr">custom_domains</span> = www.yourdomain2.com <span class="hljs-comment">#自定义域名，需要备案且解析到服务器。</span><br></code></pre></td></tr></table></figure></li><li><p>启动 frpc：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./frpc -c ./frpc.ini //debug时候用，直接在终端启动<br><span class="hljs-built_in">nohup</span> ./frpc -c ./frpc.ini &amp; //后台启动<br></code></pre></td></tr></table></figure></li><li><p>将 <a href="http://www.yourdomain.com/">www.yourdomain.com</a> 的域名 A 记录解析到 x.x.x.x，如果服务器已经有对应的域名，也可以将 CNAME 记录解析到服务器原先的域名。</p></li><li><p>通过浏览器访问 <a href="http://www.yourdomain1.com:8080/">http://www.yourdomain1.com:8080</a> 即可访问到处于内网机器上的 web1 服务。</p><p>通过浏览器访问 <a href="http://www.yourdomain2.com:8080/">http://www.yourdomain2.com:8080</a> 即可访问到处于内网机器上的 web2 服务。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>Usage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frp</tag>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>挂载COS为本地磁盘——COSFS工具配置</title>
    <link href="/2020/07/cosfs/"/>
    <url>/2020/07/cosfs/</url>
    
    <content type="html"><![CDATA[<h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><p>COSFS 工具支持将 COS 存储桶挂载到本地，像使用本地文件系统一样直接操作腾讯云对象存储中的对象， COSFS 提供的主要功能包括：</p><ul><li>支持 POSIX 文件系统的大部分功能，如：文件读写、目录操作、链接操作、权限管理、uid&#x2F;gid 管理等功能。</li><li>大文件分块传输功能。</li><li>MD5 数据校验功能。</li><li>将本机数据上传至 COS，建议使用 <a href="https://cloud.tencent.com/document/product/436/15392">COS Migration 工具</a> 或 <a href="https://cloud.tencent.com/document/product/436/10976">COSCMD 工具</a>。</li></ul><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p><strong>COSFS 基于 S3FS 构建， 读取和写入操作都经过磁盘中转，仅适合挂载后对文件进行简单的管理，不支持本地文件系统的一些功能用法，性能方面也无法代替云硬盘 CBS 或文件存储 CFS。</strong> 需注意以下不适用的场景，例如：</p><ul><li>随机或者追加写文件会导致整个文件的下载以及重新上传，您可以使用与 Bucket 在同一个地域的 CVM 加速文件的上传下载。</li><li>多个客户端挂载同一个 COS 存储桶时，依赖用户自行协调各个客户端的行为。例如避免多个客户端写同一个文件等。</li><li>文件&#x2F;文件夹的 rename 操作不是原子的。</li><li>元数据操作，例如 list directory，性能较差，因为需要远程访问 COS 服务器。</li><li>不支持 hard link，不适合高并发读&#x2F;写的场景。</li><li>不可以同时在一个挂载点上挂载、和卸载文件。您可以先使用 cd 命令切换到其他目录，再对挂载点进行挂载、卸载操作。</li></ul><h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><h3 id="适用操作系统版本"><a href="#适用操作系统版本" class="headerlink" title="适用操作系统版本"></a>适用操作系统版本</h3><p>主流的 Ubuntu、CentOS、SUSE、macOS 系统。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="1-安装依赖软件"><a href="#1-安装依赖软件" class="headerlink" title="1. 安装依赖软件"></a>1. 安装依赖软件</h4><p>COSFS 的编译安装依赖于 automake、git、libcurl-devel、libxml2-devel、fuse-devel、make、openssl-devel 等软件包，Ubuntu 、CentOS、SUSE 和 macOS 的依赖软件安装过程如下：</p><ul><li>Ubuntu 系统下安装依赖软件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install automake autotools-dev g++ git libcurl4-gnutls-dev libfuse-dev libssl-dev libxml2-dev make pkg-config fuse<br></code></pre></td></tr></table></figure><ul><li>CentOS 系统下安装依赖软件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install automake gcc-c++ git libcurl-devel libxml2-devel fuse-devel make openssl-devel fuse<br></code></pre></td></tr></table></figure><ul><li>SUSE 系统下安装依赖软件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo zypper install gcc-c++ automake make libcurl-devel libxml2-devel openssl-devel pkg-config<br></code></pre></td></tr></table></figure><ul><li>macOS 系统下安装依赖软件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install automake git curl libxml2 make pkg-config openssl <br>brew cask install osxfuse<br></code></pre></td></tr></table></figure><h4 id="2-获取源码"><a href="#2-获取源码" class="headerlink" title="2. 获取源码"></a>2. 获取源码</h4><p>您需要从 GitHub 上将 <a href="https://github.com/tencentyun/cosfs">COSFS 源码</a> 下载到指定目录，下面以目录<code>/usr/cosfs</code>为例（实际操作下，建议您根据具体操作环境选择目录）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/tencentyun/cosfs /usr/cosfs<br></code></pre></td></tr></table></figure><h4 id="3-编译和安装-COSFS"><a href="#3-编译和安装-COSFS" class="headerlink" title="3. 编译和安装 COSFS"></a>3. 编译和安装 COSFS</h4><p>进入安装目录，执行如下命令进行编译和安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/cosfs<br>./autogen.sh<br>./configure<br>make<br>sudo make install<br>cosfs --version  <span class="hljs-comment">#查看 cosfs 版本号</span><br></code></pre></td></tr></table></figure><p>根据操作系统的不同，进行 configure 操作时会出现不同的提示，主要分为以下方面：</p><ul><li>在 fuse 版本低于 2.8.4 的操作系统上，进行 configure 操作时会出现如下的报错提示：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">checking <span class="hljs-keyword">for</span> common_lib_checking... configure: error: Package requirements (fuse &gt;= 2.8.4 libcurl &gt;= 7.0 libxml-2.0 &gt;= 2.6) were not met:<br>  Requested <span class="hljs-string">&#x27;fuse &gt;= 2.8.4&#x27;</span> but version of fuse is 2.8.3 <br></code></pre></td></tr></table></figure><p>此时，您需要手动安装 fuse 2.8.4及以上版本，安装命令示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y remove fuse-devel<br>wget https://github.com/libfuse/libfuse/releases/download/fuse_2_9_4/fuse-2.9.4.tar.gz<br>tar -zxvf fuse-2.9.4.tar.gz<br><span class="hljs-built_in">cd</span> fuse-2.9.4<br>./configure<br>make<br>make install<br><span class="hljs-built_in">export</span> PKG_CONFIG_PATH=/usr/lib/pkgconfig:/usr/lib64/pkgconfig/:/usr/local/lib/pkgconfig<br>modprobe fuse   <span class="hljs-comment">#挂载 fuse 内核模块</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/usr/local/lib&quot;</span> &gt;&gt; /etc/ld.so.conf<br>ldconfig   <span class="hljs-comment">#更新动态链接库</span><br>pkg-config --modversion fuse  <span class="hljs-comment">#查看 fuse 版本号，当看到 “2.9.4” 时，表示 fuse 2.9.4 安装成功 </span><br></code></pre></td></tr></table></figure><p>SUSE 系统下手动安装 fuse 2.8.4及以上版本，安装命令示例如下：</p><blockquote><p>!安装时，需要注释掉<code>example/fusexmp.c</code>文件下第222行内容，否则 make 将报错。注释方法为<code>/*content*/</code> 。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">```shell<br>zypper remove fuse libfuse2<br>wget https://github.com/libfuse/libfuse/releases/download/fuse_2_9_4/fuse-2.9.4.tar.gz<br>tar -zxvf fuse-2.9.4.tar.gz<br><span class="hljs-built_in">cd</span> fuse-2.9.4<br>./configure<br>make <br>make install<br><span class="hljs-built_in">export</span> PKG_CONFIG_PATH=/usr/lib/pkgconfig:/usr/lib64/pkgconfig/:/usr/local/lib/pkgconfig<br>modprobe fuse   <span class="hljs-comment">#挂载 fuse 内核模块</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/usr/local/lib&quot;</span> &gt;&gt; /etc/ld.so.conf<br>ldconfig   <span class="hljs-comment">#更新动态链接库</span><br>pkg-config --modversion fuse   <span class="hljs-comment">#查看 fuse 版本号，当看到 “2.9.4” 时，表示 fuse2.9.4 安装成功 </span><br>```<br></code></pre></td></tr></table></figure><ul><li>在 macOS 进行 configure 操作时，可能会出现如下提示：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">configure: error: Package requirements (fuse &gt;= 2.7.3 libcurl &gt;= 7.0 libxml-2.0 &gt;2.6 libcrypto &gt;= 0.9) were not met<br>No package <span class="hljs-string">&#x27;libcrypto&#x27;</span> found<br></code></pre></td></tr></table></figure><p>此时，您需要设置 PKG_CONFIG_PATH 变量，以使得 pkg-config 工具能找到 openssl，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew info openssl <br><span class="hljs-built_in">export</span> PKG_CONFIG_PATH=/usr/local/opt/openssl/lib/pkgconfig <span class="hljs-comment">#您可能需要根据上一条命令的提示信息修改这条命令</span><br></code></pre></td></tr></table></figure><h3 id="COSFS-使用方法"><a href="#COSFS-使用方法" class="headerlink" title="COSFS 使用方法"></a>COSFS 使用方法</h3><h4 id="1-配置密钥文件"><a href="#1-配置密钥文件" class="headerlink" title="1. 配置密钥文件"></a>1. 配置密钥文件</h4><p>在文件<code>/etc/passwd-cosfs</code>中，写入您的存储桶名称（格式为 <BucketName-APPID>），以及该存储桶对应的 <SecretId> 和 <SecretKey>，三项之间使用半角冒号隔开。并且为了防止密钥泄露，COSFS 要求您将密钥文件的权限设置成640，配置<code>/etc/passwd-cosfs</code>密钥文件的命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo su  <span class="hljs-comment"># 切换到 root 身份，以修改 /etc/passwd-cosfs 文件；如果已经为 root 用户，无需执行该条命令。</span><br><span class="hljs-built_in">echo</span> &lt;BucketName-APPID&gt;:&lt;SecretId&gt;:&lt;SecretKey&gt; &gt; /etc/passwd-cosfs<br><span class="hljs-built_in">chmod</span> 640 /etc/passwd-cosfs<br></code></pre></td></tr></table></figure><blockquote><p>!您需要将 <BucketName-APPID>、<SecretId> 和 <SecretKey> 替换为您的信息。</p><ul><li>Bucket 命名规范，请参见 <a href="https://cloud.tencent.com/document/product/436/13312#.E5.91.BD.E5.90.8D.E8.A7.84.E8.8C.83">存储桶命名规范</a>。</li><li><SecretId> 和 <SecretKey> 请前往访问管理控制台的 <a href="https://console.cloud.tencent.com/cam/capi">云 API 密钥管理</a> 中获取。 此外，您也可以将密钥放置在文件 $HOME&#x2F;.passwd-cosfs 中，或通过 -opasswd_file&#x3D;[path] 指定密钥文件路径，此时，您需要将密钥文件权限设置成600。</li></ul></blockquote><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> examplebucket-1250000000:AKIDHTVVaVR6e3:PdkhT9e2rZCfy6 &gt; /etc/passwd-cosfs<br><span class="hljs-built_in">chmod</span> 640 /etc/passwd-cosfs<br></code></pre></td></tr></table></figure><h4 id="2-运行工具"><a href="#2-运行工具" class="headerlink" title="2. 运行工具"></a>2. 运行工具</h4><p>将已经在密钥文件中配置好信息的存储桶挂载到指定目录，可以使用如下命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cosfs &lt;BucketName-APPID&gt; &lt;MountPoint&gt; -ourl=&lt;CosDomainName&gt; -odbglevel=info -oallow_other<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><MountPoint> 为本地挂载目录（例如<code>/mnt</code>）。</li><li><CosDomainName> 为存储桶对应的访问域名，形式为<code>http://cos.&lt;Region&gt;.myqcloud.com</code> （适用于 XML API，请勿在该参数中携带存储桶名称），其中 <Region> 为地域简称， 例如 ap-guangzhou 、 eu-frankfurt 等。更多地域信息，请参见 <a href="https://cloud.tencent.com/document/product/436/6224">可用地域</a>。</li><li>-odbglevel 指定日志级别。</li><li>-oallow_other 允许非挂载用户访问挂载文件夹。</li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /mnt/cosfs<br>cosfs examplebucket-1250000000 /mnt/cosfs -ourl=http://cos.ap-guangzhou.myqcloud.com -odbglevel=info -onoxattr -oallow_other<br></code></pre></td></tr></table></figure><blockquote><p>!v1.0.5 之前版本 COSFS 的挂载命令如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cosfs &lt;APPID&gt;:&lt;BucketName&gt; &lt;MountPoint&gt; -ourl=&lt;CosDomainName&gt; -oallow_other<br></code></pre></td></tr></table></figure><p>v1.0.5 之前版本 COSFS 的配置文件格式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;BucketName&gt;:&lt;SecretId&gt;:&lt;SecretKey&gt;<br></code></pre></td></tr></table></figure><h4 id="3-卸载存储桶"><a href="#3-卸载存储桶" class="headerlink" title="3. 卸载存储桶"></a>3. 卸载存储桶</h4><p>卸载存储桶示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">方式1：fusermount -u /mnt, fusermount 命令专用于卸载 FUSE 文件系统 <br>方式2：umount -l /mnt, 当有程序引用文件系统中文件时，进行卸载不会报错，并在没程序引用时完成卸载<br>方式3：umount /mnt， 当有程序引用文件系统中的文件时，进行卸载会报错<br></code></pre></td></tr></table></figure><h2 id="常用挂载选项"><a href="#常用挂载选项" class="headerlink" title="常用挂载选项"></a>常用挂载选项</h2><h4 id="omultipart-size-x3D-size"><a href="#omultipart-size-x3D-size" class="headerlink" title="-omultipart_size&#x3D;[size]"></a>-omultipart_size&#x3D;[size]</h4><p>用来指定分块上传时单个分块的大小（单位： MB），默认是10MB。 由于分块上传对单个文件块的数目有最大限制（10000块），所以对于超出100GB（10MB * 10000）大小的文件，需要根据具体情况调整该参数。</p><h4 id="oallow-other"><a href="#oallow-other" class="headerlink" title="-oallow_other"></a>-oallow_other</h4><p>如果要允许其他用户访问挂载文件夹，可以在运行 COSFS 的时候指定该参数。</p><h4 id="odel-cache"><a href="#odel-cache" class="headerlink" title="-odel_cache"></a>-odel_cache</h4><p>默认情况下， COSFS 为了优化性能，在 umount 后，不会清除本地的缓存数据。 如果需要在 COSFS 退出时，自动清除缓存，可以在挂载时加入该选项。</p><h4 id="onoxattr"><a href="#onoxattr" class="headerlink" title="-onoxattr"></a>-onoxattr</h4><p>禁用 getattr&#x2F;setxattr 功能，在1.0.9之前版本的 COSFS 不支持设置和获取扩展属性，如果在挂载时使用了 use_xattr 选项，可能会导致 mv 文件到 Bucket 失败。</p><h4 id="ouse-cache-x3D-path"><a href="#ouse-cache-x3D-path" class="headerlink" title="-ouse_cache&#x3D;[path]"></a>-ouse_cache&#x3D;[path]</h4><p>使用缓存目录缓存文件，path 为本地缓存目录路径，该选项可以在文件缓存下来后，加速文件的读写（非第一次读写），如果不需要本地缓存或本地磁盘容量有限，可不指定该选项。</p><h4 id="opasswd-file-x3D-path"><a href="#opasswd-file-x3D-path" class="headerlink" title="-opasswd_file&#x3D;[path]"></a>-opasswd_file&#x3D;[path]</h4><p>该选项可以指定 COSFS 密钥文件的所在路径，该选项设定的密钥文件需要设置权限为600。</p><h4 id="odbglevel-x3D-dbg-info-warn-err-crit"><a href="#odbglevel-x3D-dbg-info-warn-err-crit" class="headerlink" title="-odbglevel&#x3D;[dbg|info|warn|err|crit]"></a>-odbglevel&#x3D;[dbg|info|warn|err|crit]</h4><p>设置 COSFS 日志记录级别，可选 info、dbg、warn、err 和 crit。生产环境中建议设置为 info，调试时可以设置为 dbg。如果您的系统日志，未定期清理且由于访问量很大，生成大量日志，您可以设置为 err 或者 crit。</p><h4 id="oumask-x3D-perm"><a href="#oumask-x3D-perm" class="headerlink" title="-oumask&#x3D;[perm]"></a>-oumask&#x3D;[perm]</h4><p>该选项可以去除给定类型用户，对挂载目录内文件的操作权限。例如，-oumask&#x3D;755，对应挂载目录的权限变为022。</p><h4 id="ouid-x3D-uid"><a href="#ouid-x3D-uid" class="headerlink" title="-ouid&#x3D;[uid]"></a>-ouid&#x3D;[uid]</h4><p>该选项允许用户 id 为 [uid] 的用户不受挂载目录中文件权限位的限制，可以访问挂载目录中的所有文件。 获取用户 uid 可以使用 id 命令，格式<code> id -u username</code>。例如执行<code>id -u user_00</code>，可获取到用户 user_00 的 uid。</p><h4 id="oensure-diskfree-x3D-size"><a href="#oensure-diskfree-x3D-size" class="headerlink" title="-oensure_diskfree&#x3D;[size]"></a>-oensure_diskfree&#x3D;[size]</h4><p>用来指定当缓存文件所在磁盘，剩余空间不足 [size] MB 大小时，COSFS 运行将尽量减少使用磁盘空间（单位： MB）。 COSFS 的上传下载都会使用磁盘文件缓存，当上传大文件时，若不指定该参数，会写满缓存文件所在的磁盘。如果指定 -ouse_cache&#x3D;[path] 参数，缓存文件位于 path 目录下，否则，在 &#x2F;tmp 目录下。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>如果您在使用 COSFS 工具过程中，有相关的疑问，请参见 <a href="https://cloud.tencent.com/document/product/436/30743">COSFS 工具类常见问题</a>。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wordpress</tag>
      
      <tag>cos</tag>
      
      <tag>fs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯云COS-FTP部署</title>
    <link href="/2020/07/cos-ftp/"/>
    <url>/2020/07/cos-ftp/</url>
    
    <content type="html"><![CDATA[<p>最近在用Chevereto做图床平台，但是惊奇的发现外部存储中有Aliyun OSS但是没有腾讯云的COS，这就意味着无法直接用COS与图床对接啦&#x2F;(ㄒoㄒ)&#x2F;~~</p><p>腾讯云太没有排面了↓</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/cos_ftp/1.png" style="zoom:80%;" /><p>但是我一下看到了FTP也有接口呀！但是查了一圈资料发现…COS原生不支持FTP┭┮﹏┭┮。抱着试一试的态度继续翻了翻COS的文档，突然发现了COS居然有FTP流式传输的Python官方脚本！那不妨试试用腾讯云服务器当跳板，将FTP根目录对接到COS中。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h4 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h4><p>FTP Server 工具下载地址为：<a href="https://github.com/tencentyun/cos-ftp-server-V5">cos-ftp-server</a>。安装步骤如下：</p><ol><li><p>进入 FTP Server 目录，运行 setup.py 安装 FTP Server 及其相关的依赖库（需要联网）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python setup.py install   <span class="hljs-comment"># 这里可能需要您的账号 sudo 或者拥有 root 权限。</span><br></code></pre></td></tr></table></figure></li><li><p>将配置示例文件<code>conf/vsftpd.conf.example</code>复制命名为<code>conf/vsftpd.conf</code>，参考本文下方章节 ，正确配置 bucket 和用户信息。</p></li><li><p>运行 ftp_server.py 启动 FTP Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python ftp_server.py<br></code></pre></td></tr></table></figure><p>此外还有两种方式启动 FTP Server，如下：</p><ul><li><p>使用 nohup 命令，以后台进程方式启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> python ftp_server.py &gt;&gt; /dev/null 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure></li><li><p>使用 screen 命令放入后台运行（需要安装 screen 工具)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -dmS ftp<br>screen -r ftp<br>python ftp_server.py<br><span class="hljs-comment">#使用快捷键 Ctrl+A+D ，切回主 screen 即可。</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="停止运行"><a href="#停止运行" class="headerlink" title="停止运行"></a>停止运行</h4><ul><li><p>若您是直接运行，或 screen 方式放在后台运行的 FTP Server，您可以使用快捷键<code>Ctrl+C</code>停止 FTP Server 运行。</p></li><li><p>若您是通过 nohup 命令启动，可以使用下面方式停止：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep python | grep ftp_server.py | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs -I&#123;&#125; <span class="hljs-built_in">kill</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>FTP Server 工具的配置示例文件为<code>conf/vsftpd.conf.example</code>，请复制命名为 vsftpd.conf，并按照以下的配置项进行配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs conf">[COS_ACCOUNT_0]<br>cos_secretid = COS_SECRETID    # 替换为您的 SECRETID<br>cos_secretkey = COS_SECRETKEY  # 替换为您的 SECRETKEY<br>cos_bucket = examplebucket-1250000000<br>cos_region = region   # 替换为您的存储桶地域<br>cos_protocol = https<br>#cos_endpoint = region.myqcloud.com<br>home_dir = /home/user0<br>ftp_login_user_name=user0   #替换为用户自定义的账号<br>ftp_login_user_password=pass0   #替换为用户自定义的密码<br>authority=RW                # 设置该用户的读写权限，R 表示读权限，W 表示写权限，RW 表示同时具备读写权限<br>delete_enable=true         # true 为允许该 ftp 用户进行删除操作（默认），false 为禁止该用户进行删除操作<br><br>[COS_ACCOUNT_1]<br>cos_secretid = COS_SECRETID    # 替换为您的 SECRETID<br>cos_secretkey = COS_SECRETKEY  # 替换为您的 SECRETKEY<br>cos_bucket = examplebucket-1250000000<br>cos_region = region   # 替换为您的存储桶地域<br>cos_protocol = https<br>#cos_endpoint = region.myqcloud.com<br>home_dir = /home/user1<br>ftp_login_user_name=user1   #替换为用户自定义的账号<br>ftp_login_user_password=pass1   #替换为用户自定义的密码<br>authority=RW               # 设置该用户的读写权限，R 表示读权限，W 表示写权限，RW 表示同时具备读写权限<br>delete_enable=false        # true 为允许该 ftp 用户进行删除操作（默认），false 为禁止该用户进行删除操作<br><br>[NETWORK]<br># 如果 FTP Server 处于某个网关或 NAT 后，可以通过该配置项将网关的 IP 地址或域名指定给 FTP<br>masquerade_address = XXX.XXX.XXX.XXX<br># FTP Server 的监听端口，默认为2121，注意防火墙需要放行该端口（例如您是将 FTP Server 工具部署在腾讯云 CVM，则需要在 CVM 安全组放行该端口）<br>listen_port = 2121            <br># passive_port 可以设置 passive 模式下，端口的选择范围，默认在 [60000, 65535] 区间上选择，注意防火墙（例如 CVM 安全组）需要放行此区间端口<br>passive_port = 60000,65535      <br><br><br>[FILE_OPTION]<br># 默认单文件大小最大支持到200G，不建议设置太大<br>single_file_max_size = 21474836480<br><br>[OPTIONAL]<br># 以下设置，如无特殊需要，建议保留 default 设置。如需设置，请合理填写一个整数<br>min_part_size       = default<br>upload_thread_num   = default<br>max_connection_num  = 512<br>max_list_file       = 10000                # ls 命令最大可列出的文件数目，建议不要设置太大，否则 ls 命令延时会很高<br>log_level           = INFO                 # 设置日志输出的级别<br>log_dir             = log                  # 设置日志的存放目录，默认是在 FTP Server 目录下<br></code></pre></td></tr></table></figure><p><strong>在服务器上执行程序如果出现以下提示就说明成功了：</strong></p><p>直接启动调试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@VM-0-12-debian:/ftp/cos-ftp-server-V5<span class="hljs-comment"># python ftp_server.py</span><br>starting  ftp server...<br></code></pre></td></tr></table></figure><p>后台启动运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">^Croot@VM-0-12-debian:/ftp/cos-ftp-server-V5<span class="hljs-comment"># nohup python ftp_server.py &gt;&gt; /dev/null 2&gt;&amp;1 &amp;</span><br>[1] 29981<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wordpress</tag>
      
      <tag>cos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WordPress全站优化策略——COS配置策略</title>
    <link href="/2020/07/wp-cos/"/>
    <url>/2020/07/wp-cos/</url>
    
    <content type="html"><![CDATA[<p>COS的部署可以极佳地解决WordPress图像文件、.css、.js等文件加载慢的问题，其原理就跟CDN相似，只不过是在服务器直接将内容的链接指向COS对象存储服务器，就相当于将COS做为内容分发服务器。那么按照这个思路，我们还可以把主题加载的相关图片、字体等全部托管在COS对象存储服务器。那么看看是怎么部署的吧。</p><h2 id="腾讯云COS配置"><a href="#腾讯云COS配置" class="headerlink" title="腾讯云COS配置"></a>腾讯云COS配置</h2><h3 id="创建储存桶"><a href="#创建储存桶" class="headerlink" title="创建储存桶"></a>创建储存桶</h3><p>进步腾讯云控制台，按照指引添加新的储存桶：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/wp_cos/1.png" style="zoom:80%;" /><p>选择储存桶权限为：<strong>公有读私有写</strong></p><h3 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h3><p>记录下以下内容：</p><ul><li>存储桶名称</li><li>存储桶地域</li><li>APP ID</li><li>SecretID</li><li>SecretKey</li></ul><p>前两个在储存桶详细信息中获取，后三个在密钥管理中获取。</p><h3 id="COS管理"><a href="#COS管理" class="headerlink" title="COS管理"></a>COS管理</h3><p>可以选择腾讯官方的COSBrowser</p><table><thead><tr><th>Windows</th><th>Mac</th><th>Linux</th><th>Android</th><th>IOS</th></tr></thead><tbody><tr><td><a href="https://cosbrowser-1253960454.cos.ap-shanghai.myqcloud.com/releases/cosbrowser-setup-2.2.3.exe">下载</a></td><td><a href="https://cosbrowser-1253960454.cos.ap-shanghai.myqcloud.com/releases/cosbrowser-2.2.3.dmg">下载</a></td><td><a href="https://cosbrowser-1253960454.cos.ap-shanghai.myqcloud.com/releases/cosbrowser-1.5.3-linux.zip">下载</a></td><td><a href="https://cosbrowser-1253960454.cos.ap-shanghai.myqcloud.com/mobile/Android/release/latest/cosbrowser-latest.apk">下载</a></td><td><a href="https://apps.apple.com/cn/app/id1469323992">App Store</a></td></tr></tbody></table><h2 id="WordPress插件配置"><a href="#WordPress插件配置" class="headerlink" title="WordPress插件配置"></a>WordPress插件配置</h2><p>下载插件：**<a href="https://qq52o.me/2518.html">腾讯云COS</a>**（<a href="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/wp_cos/wordpress-qcloud-cos-1.8.4.zip">下载</a>）</p><p>按照插件提示进行设置：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/wp_cos/2.png" style="zoom:80%;" /><p>参数说明：</p><ol><li>前五项就是刚刚创建记录的信息，填上去就好。</li><li>本地文件夹一般选<strong>wp-content&#x2F;uploads</strong>，其中包含了：媒体库、主题css、字体等页面美化有关的资源。</li><li>URL前缀就是<strong>wp-content&#x2F;uploads</strong>在你COS中的直链。</li></ol><p>图像处理方式请参考<a href="https://cloud.tencent.com/document/product/460/6936"><strong>数据万象文档</strong></a></p><p>之后点击<strong>保存更改</strong>。</p><h2 id="文件迁移"><a href="#文件迁移" class="headerlink" title="文件迁移"></a>文件迁移</h2><p>不建议用自带的同步历史附件，有点玄学，我试了几次都失败了，然后网站就挂了。</p><p>这里只需进入服务器网站文件夹，将<strong>wp-content&#x2F;uploads</strong>文件夹全部下载下来，然后整包上传至COS对应文件夹就可以实现同步。</p><p>在宝塔面板中可以看到服务器文件夹下的情况。</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/wp_cos/3.png" style="zoom:80%;" /><h2 id="查看验证"><a href="#查看验证" class="headerlink" title="查看验证"></a>查看验证</h2><p>先访问一下网站看能否正常显示。然后进入媒体库随便查看一个媒体的链接，看一下是否替换成了相应的COS链接：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/wp_cos/4.png" style="zoom:80%;" /><p>如果成功替换，并且网页能够正常显示，那么COS部署就基本成功了！</p><p>如果有用的话记得三连噢~</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wordpress</tag>
      
      <tag>cos</tag>
      
      <tag>ftp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派部署宝塔面板+LAMP</title>
    <link href="/2020/07/raspi-bt/"/>
    <url>/2020/07/raspi-bt/</url>
    
    <content type="html"><![CDATA[<p>树莓派4的64位操作系统现在慢慢发展起来了，终于可以安装现在只支持64位的宝塔面板了，同时也解决了部分Web组件无法安装的问题，对于我这种不想总是动手敲命令行的人来说有个可视化的Web管理界面还是非常舒服的！</p><p>先上图：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/raspi_BT/5.png" style="zoom:80%;" /><h2 id="基础软硬件"><a href="#基础软硬件" class="headerlink" title="基础软硬件"></a>基础软硬件</h2><p>Raspberry Pi 4b 2G RAM</p><p>32GB Class10 TF Card（32GB大小比较合适，后面有用）</p><p>OS:<a href="https://github.com/openfans-community-offical/Debian-Pi-Aarch64">Debian-Pi-Aarch64</a> ，Ubuntu官方也出树莓派4的64位操作系统了，有兴趣可以试试。</p><h2 id="面板安装"><a href="#面板安装" class="headerlink" title="面板安装"></a>面板安装</h2><p><strong>Debian</strong>安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh<br></code></pre></td></tr></table></figure><p>更多的操作系统支持请参考官方信息：<a href="https://www.bt.cn/bbs/thread-19376-1-1.html">宝塔面板安装</a></p><p>经过漫长的等待，如果看到以下内容就说明安装好了：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/raspi_BT/1.png" style="zoom:100%;" /><p>如果是在内网安装的话<strong>IP地址是错的</strong>根据自己的真实IP地址进入登录端口。</p><p><strong>成功登陆后</strong>进入面板的设置界面修改以下信息（为安全考虑）：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/raspi_BT/2.png" style="zoom:100%;" /><p>服务器部分端口<strong>默认关闭</strong>根据需要可以去安全里面<strong>放行端口</strong>。</p><p>到这里面板的安装和设置基本上就完成了。</p><h2 id="LAMP安装"><a href="#LAMP安装" class="headerlink" title="LAMP安装"></a>LAMP安装</h2><h3 id="SWAP分区扩展-划重点！！！"><a href="#SWAP分区扩展-划重点！！！" class="headerlink" title="SWAP分区扩展(划重点！！！)"></a>SWAP分区扩展(划重点！！！)</h3><p>由于树莓派4的arm64构架，导致没有现成的二进制文件可以运行，所以组件安装都需要自己在本机编译！</p><p>如果不修改SWAP分区编译过程中<strong>100%爆内存</strong>！！！</p><p>详细步骤参考：<a href="https://jason-xy.cn/2020/06/raspi_swap/">SWAP分区扩展教程</a></p><p>我给的SWAP空间超级多，上次编译内存直接飙到6G吓到我了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@raspbian:/home/pi<span class="hljs-comment"># free -h</span><br>              total        used        free      shared  buff/cache   available<br>Mem:          1.9Gi       354Mi       536Mi        34Mi       1.0Gi       1.4Gi<br>Swap:         7.0Gi        27Mi       7.0Gi<br></code></pre></td></tr></table></figure><h3 id="LAMP安装-1"><a href="#LAMP安装-1" class="headerlink" title="LAMP安装"></a>LAMP安装</h3><p>直接在宝塔面板可视化安装没什么可以讲的，但是一定记得点<strong>编译安装</strong>。</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/raspi_BT/4.png" style="zoom:80%;" /><p>另外安装SQL时，如果选择mysql-mariadb_10.4时会要求内存2048MB以上，2G版本的树莓派刚好卡在了门槛，装个mysql-mariadb_10.3也没啥问题。</p><p>剩下的就是漫长的等待了，不骗你，真的超级漫长！</p><p>祝大家中途别遇到奇奇怪怪的问题🤭</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry-pi</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用VS Code远程开发树莓派</title>
    <link href="/2020/07/vs-code-pi/"/>
    <url>/2020/07/vs-code-pi/</url>
    
    <content type="html"><![CDATA[<p>VS Code是微软推出的一款非常好用的文本编辑器，更是微软为数不多的良心开源产品！！！得益于丰富的开源生态，合理利用VScode甚至可以在一定程度上替代IDE。这里主要介绍一款前几天发现的宝藏插件，对于我这种用不惯vim的菜鸟，简直让我知乎VScode，yyds！</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/vsc_ssh/1.png" style="zoom:80%;" /><p>点击extensions，如上图方框所示，搜索remote ssh并安装。安装完成后，使用组合键<code>ctrl+shift+p</code>打开输入框，输入remote ssh，你将看到类似于下图的结果：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/vsc_ssh/2.png" style="zoom:80%;" /><p>选中上图中高亮的选项，即添加新主机的选项。你将看到如下图所示的选项：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/vsc_ssh/7.png" style="zoom:100%;" /><p>这个地方和Linux中的SSH命令用法一样，按照如下格式即可连接你的主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh user@IP/domain_name -p Port<br></code></pre></td></tr></table></figure><p>此处的Port如果没有改过的话默认是22，完成后会让你选择密钥存储位置，这个就各自随意了，但是最好每次加入新主机的时候都选同一个位置，方便以后查找。</p><p>完成后，VS Code的侧边栏会出现一个新的图标，如下图所示：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/vsc_ssh/8.png" style="zoom:80%;" /><p>点击图标，就能看到刚才加入的主机，在主机名上右键便能看到连接的选项，选择在新窗口打开，此时会要求输入远程主机的密码，输入后回车即可。</p><p>完成后点击左侧边栏的文件图标，选择打开文件夹，如下图所示：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/vsc_ssh/5.png" style="zoom:80%;" /><p>在弹出的下拉菜单中选择你要打开的文件夹，然后就可以像在本机使用那样新建文件等。</p><p>同时，你也可以在VS Code自带的终端中输入命令，如下图所示：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/vsc_ssh/6.png" style="zoom:80%;" /><p>Done!!!</p><p>开始愉快的远程开发之旅吧~</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry-pi</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尾递归</title>
    <link href="/2020/07/recursion-tail/"/>
    <url>/2020/07/recursion-tail/</url>
    
    <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用。<br></code></pre></td></tr></table></figure><p>当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。</p><p>例如，对于递归调用序列<code> f(x1) -&gt; f(x2) -&gt; f(x3)</code>，如果函数 <code>f(x)</code> 以尾递归的形式实现。那么其执行步骤的顺序和栈空间的分配如下所示：</p><img align="center" src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/Tail_recursion/card_recursion_tail.png" alt="img" style="zoom:80%;" /><p>请注意，在尾递归的情况下，一旦从递归调用返回，我们也会立即返回，因此我们可以跳过整个递归调用返回链，直接返回到原始调用方。这意味着我们根本不需要所有递归调用的调用栈，这为我们节省了空间。</p><p>例如，在步骤（1）中，栈中的一个空间将被分配给 <code>f(x1)</code>，以便调用 <code>f(x2)</code>。然后，在步骤（2）中，函数 <code>f(x2)</code> 能够递归地调用 <code>f(x3)</code>，但是，系统不需要在栈上分配新的空间，而是可以简单地重用先前分配给第二次递归调用的空间。最后，在函数 <code>f(x3)</code> 中，我们达到了基本情况，该函数可以简单地将结果返回给原始调用方，而不会返回到之前的函数调用中。</p><p>尾递归函数可以作为非尾递归函数来执行，也就是说，带有调用栈并不会对结果造成影响。通常，编译器会识别尾递归模式，并优化其执行。然而，并不是所有的编程语言都支持这种优化，比如 C，C++ 支持尾递归函数的优化。另一方面，Java 和 Python 不支持尾递归优化。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>为了理解尾递归是如何工作的，让我们再次以递归的形式计算阶乘。首先，这可以很容易让我们理解为什么之前所定义的递归不是尾递归。回忆之前对计算n!的定义：在每个活跃期计算n倍的(n－1)!的值，让n&#x3D;n－1并持续这个过程直到n&#x3D;1为止。这种定义不是尾递归的，因为每个活跃期的返回值都依赖于用n乘以下一个活跃期的返回值，因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。现在让我们考虑以尾递归的形式来定义计算n!的过程。</p><p>这种定义还需要接受第二个参数a，除此之外并没有太大区别。a（初始化为1）维护递归层次的深度。这就让我们避免了每次还需要将返回值再乘以n。然而，在每次递归调用中，令a&#x3D;na并且n&#x3D;n－1。继续递归调用，直到n&#x3D;1，这满足结束条件，此时直接返回a即可。</p><p>代码实例3-2给出了一个C函数facttail，它接受一个整数n并以尾递归的形式计算n的阶乘。这个函数还接受一个参数a，a的初始值为1。facttail使用a来维护递归层次的深度，除此之外它和fact很相似。读者可以注意一下函数的具体实现和尾递归定义的相似之处。</p><p>示例3-2：以尾递归的形式计算阶乘的一个函数实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*facttail.c*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;facttail.h&quot;</span></span><br><span class="hljs-comment">/*facttail*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">facttail</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a)</span>&#123;<br>    <span class="hljs-comment">/*Compute a factorialina tail - recursive manner.*/</span><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> facttail(n - <span class="hljs-number">1</span>, n * a);<br>&#125;<br></code></pre></td></tr></table></figure><p>示例3-2中的函数是尾递归的，因为对facttail的单次递归调用是函数返回前最后执行的一条语句。在facttail中碰巧最后一条语句也是对facttail的调用，但这并不是必需的。换句话说，在递归调用之后还可以有其他的语句执行，只是它们只能在递归调用没有执行时才可以执行 。</p><p>尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如f(n, sum) &#x3D; f(n-1) + value(n) + sum; 会保存n个函数调用堆栈，而使用尾递归f(n, sum) &#x3D; f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。</p><p>也许在C语言中有很多的特例，但编程语言不只有C语言，在函数式语言Erlang中（亦是栈语言），如果想要保持语言的高并发特性，就必须用尾递归来替代传统的递归。</p><p>原文的说法是错误的：原文如下：</p><p>一种算法, 用于计算机编程技术.</p><p>尾递归是针对传统的递归算法而言的, 传统的递归算法在很多时候被视为洪水猛兽. 它的名声狼籍, 好像永远和低效联系在一起.</p><p>尾递归就是从最后开始计算, 每递归一次就算出相应的结果, 也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部, 所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者, 返回到调用者的调用者去.</p><p>以下是具体实例:</p><p>线性递归:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">Rescuvie</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> (n == <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : n * Rescuvie(n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>尾递归:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">TailRescuvie</span><span class="hljs-params">(<span class="hljs-type">long</span> n, <span class="hljs-type">long</span> a)</span> &#123;<br>    <span class="hljs-keyword">return</span> (n == <span class="hljs-number">1</span>) ? a : TailRescuvie(n - <span class="hljs-number">1</span>, a * n);<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-title function_">TailRescuvie</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> &#123;<span class="hljs-comment">//封装用的  </span><br>    <span class="hljs-keyword">return</span> (n == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : TailRescuvie(n, <span class="hljs-number">1</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>当n &#x3D; 5时</p><p>对于线性递归, 他的递归过程如下:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">Rescuvie</span>(<span class="hljs-number">5</span>)<br>&#123;<span class="hljs-number">5</span> * <span class="hljs-built_in">Rescuvie</span>(<span class="hljs-number">4</span>)&#125;<br>&#123;<span class="hljs-number">5</span> * &#123;<span class="hljs-number">4</span> * <span class="hljs-built_in">Rescuvie</span>(<span class="hljs-number">3</span>)&#125;&#125;<br>&#123;<span class="hljs-number">5</span> * &#123;<span class="hljs-number">4</span> * &#123;<span class="hljs-number">3</span> * <span class="hljs-built_in">Rescuvie</span>(<span class="hljs-number">2</span>)&#125;&#125;&#125;<br>&#123;<span class="hljs-number">5</span> * &#123;<span class="hljs-number">4</span> * &#123;<span class="hljs-number">3</span> * &#123;<span class="hljs-number">2</span> * <span class="hljs-built_in">Rescuvie</span>(<span class="hljs-number">1</span>)&#125;&#125;&#125;&#125;<br>&#123;<span class="hljs-number">5</span> * &#123;<span class="hljs-number">4</span> * &#123;<span class="hljs-number">3</span> * &#123;<span class="hljs-number">2</span> * <span class="hljs-number">1</span>&#125;&#125;&#125;&#125;<br>&#123;<span class="hljs-number">5</span> * &#123;<span class="hljs-number">4</span> * &#123;<span class="hljs-number">3</span> * <span class="hljs-number">2</span>&#125;&#125;&#125;<br>&#123;<span class="hljs-number">5</span> * &#123;<span class="hljs-number">4</span> * <span class="hljs-number">6</span>&#125;&#125;<br>&#123;<span class="hljs-number">5</span> * <span class="hljs-number">24</span>&#125;<br><span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>对于尾递归, 他的递归过程如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">TailRescuvie</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">TailRescuvie</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">TailRescuvie</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">TailRescuvie</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">20</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">TailRescuvie</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">60</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">TailRescuvie</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">120</span>)</span></span><br><span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>很容易看出, 普通的线性递归比尾递归更加消耗资源, 在实现上说, 每次重复的过程<br>调用都使得调用链条不断加长. 系统不得不使用栈进行数据保存和恢复.而尾递归就<br>不存在这样的问题, 因为他的状态完全由n和a保存。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>basic algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vultr VPS-服务器地址（机房）选择方法</title>
    <link href="/2020/07/vultr-vps/"/>
    <url>/2020/07/vultr-vps/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如何购买vps以及后续服务的搭建不在本文讨论范围，如需帮助可私信联系。<br>若有帮助请按个赞。</p></blockquote><hr><blockquote><p>更新：有的网络不管怎么操作怎么选择节点，还是会经常timeout，或者连上也卡，比如教育网。 自己搭的还是还简陋了，唯一优点是便宜，追求良好体验的看评论，我现在已经放弃vultr了。</p></blockquote><ol><li>不同地区的服务器在价格上可能有一定差异，以vultr为例，小部分服务器可以选择2.5$&#x2F;month 的价格，大部分最低为5$&#x2F;moth，如果要选择最便宜的2.5$&#x2F;month，那选择范围就非常小了，基本没有选择的余地，看哪个服务器支持就选哪个好了。</li><li>选择正常价格的服务器。唯一需要考虑的就是本地与服务器的连通性，通常推荐最多的是日本，不过到底适不适合自己的网络，需要实际测试才知道。下表给出了各个地区服务器的地址，通过Ping就可以检测本地与服务器的连通性了。</li></ol><table><thead><tr><th align="center">服务器地区</th><th align="center">服务器地址</th></tr></thead><tbody><tr><td align="center">Frankfurt, DE</td><td align="center">fra-de-ping.vultr.com</td></tr><tr><td align="center">Paris, France</td><td align="center">par-fr-ping.vultr.com</td></tr><tr><td align="center">Amsterdam, NL</td><td align="center">ams-nl-ping.vultr.com</td></tr><tr><td align="center">London, UK</td><td align="center">lon-gb-ping.vultr.com</td></tr><tr><td align="center">Singapore</td><td align="center">sgp-ping.vultr.com</td></tr><tr><td align="center">New York (NJ)</td><td align="center">nj-us-ping.vultr.com</td></tr><tr><td align="center">Tokyo, Japan</td><td align="center">hnd-jp-ping.vultr.com</td></tr><tr><td align="center">Chicago, Illinois</td><td align="center">il-us-ping.vultr.com</td></tr><tr><td align="center">Atlanta, Georgia</td><td align="center">ga-us-ping.vultr.com</td></tr><tr><td align="center">Miami, Florida</td><td align="center">fl-us-ping.vultr.com</td></tr><tr><td align="center">Seattle, Washington</td><td align="center">wa-us-ping.vultr.com</td></tr><tr><td align="center">Dallas, Texas</td><td align="center">tx-us-ping.vultr.com</td></tr><tr><td align="center">Silicon Valley, California</td><td align="center">sjo-ca-us-ping.vultr.com</td></tr><tr><td align="center">Los Angeles, California</td><td align="center">lax-ca-us-ping.vultr.com</td></tr><tr><td align="center">Sydney, Australia</td><td align="center">syd-au-ping.vultr.com</td></tr></tbody></table><ol><li>打开命令行窗口：按<img src="https://math.jianshu.com/math?formula=win" alt="win">键+<img src="https://math.jianshu.com/math?formula=R" alt="R">，输入<img src="https://math.jianshu.com/math?formula=cmd" alt="cmd">按回车，然后将下面代码复制进去按回车，就会依次ping上表中的每个节点，记录下结果后，选择无丢失且延迟最小的节点。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping fra-de-ping.vultr.com    <br>ping par-fr-ping.vultr.com    <br>ping ams-nl-ping.vultr.com    <br>ping lon-gb-ping.vultr.com    <br>ping sgp-ping.vultr.com    <br>ping nj-us-ping.vultr.com    <br>ping hnd-jp-ping.vultr.com    <br>ping il-us-ping.vultr.com    <br>ping ga-us-ping.vultr.com    <br>ping fl-us-ping.vultr.com    <br>ping wa-us-ping.vultr.com    <br>ping tx-us-ping.vultr.com    <br>ping sjo-ca-us-ping.vultr.com    <br>ping lax-ca-us-ping.vultr.com    <br>ping syd-au-ping.vultr.com<br>^<br></code></pre></td></tr></table></figure><ol><li>实际运行时，单次结果可能不太可靠，最好多次选择不同时间节点测试，出现丢失的节点就不用看了。下表是我多次测试的结果，本地网络为西安电信教育网。1、2、3次分别是上午、下午、晚上测试的数据，可以看出最好的是<strong>Los Angeles</strong>的节点，其次是<strong>Paris</strong>和<strong>Atlanta</strong>。而<strong>Tokyo</strong>确实是延迟最低的服务器，但是下午和晚上延迟就变高了，而且丢包严重，所以并不适合我。</li></ol><table><thead><tr><th align="center">服务器地区</th><th align="center">1st ping(ms)</th><th align="center">2nd ping</th><th align="center">3rd ping</th></tr></thead><tbody><tr><td align="center"><del>Frankfurt, DE</del></td><td align="center">230</td><td align="center">238</td><td align="center">50% lost 240</td></tr><tr><td align="center">Paris, France</td><td align="center">198</td><td align="center">240</td><td align="center">244</td></tr><tr><td align="center"><del>Amsterdam, NL</del></td><td align="center">199</td><td align="center">25% lost 388</td><td align="center">289</td></tr><tr><td align="center"><del>London, UK</del></td><td align="center">289</td><td align="center">25% lost 351</td><td align="center">25% lost 253</td></tr><tr><td align="center"><del>Singapore</del></td><td align="center">100% lost</td><td align="center">50% lost 191</td><td align="center">50% lost 194</td></tr><tr><td align="center"><del>New York (NJ)</del></td><td align="center">25% lost，312</td><td align="center">332</td><td align="center">262</td></tr><tr><td align="center"><del>Tokyo, Japan</del></td><td align="center">50% lost 124</td><td align="center">25% lost 210</td><td align="center">25% 219</td></tr><tr><td align="center"><del>Chicago, Illinois</del></td><td align="center">100% lost</td><td align="center">340</td><td align="center">241</td></tr><tr><td align="center">Atlanta, Georgia</td><td align="center">251</td><td align="center">256</td><td align="center">259</td></tr><tr><td align="center"><del>Miami, Florida</del></td><td align="center">100% lost</td><td align="center">381</td><td align="center">334</td></tr><tr><td align="center">Seattle, Washington</td><td align="center">307</td><td align="center">361</td><td align="center">289</td></tr><tr><td align="center">Dallas, Texas</td><td align="center">312</td><td align="center">309</td><td align="center">208</td></tr><tr><td align="center"><del>Silicon Valley, California</del></td><td align="center">241</td><td align="center">363</td><td align="center">25% lost 297</td></tr><tr><td align="center">Los Angeles, California</td><td align="center">175</td><td align="center">189</td><td align="center">190</td></tr><tr><td align="center"><del>Sydney, Australia</del></td><td align="center">100% lost</td><td align="center">263</td><td align="center">366</td></tr></tbody></table><p>V2ray一键脚本<br><code>bash &lt;(curl -s -L https://git.io/v2ray.sh)</code></p><p>Trojan一键脚本<br><code>wget -N --no-check-certificate -q -O trojan_install.sh &quot;https://raw.githubusercontent.com/V2RaySSR/Trojan/master/trojan_install.sh&quot; &amp;&amp; chmod +x trojan_install.sh &amp;&amp; bash trojan_install.sh</code></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cloud</tag>
      
      <tag>vps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu20.04下安装Cuda11.0+Nvidia-440+Cudnn7.1.4+Tensorflow1.9</title>
    <link href="/2020/07/ubuntu-nvidia/"/>
    <url>/2020/07/ubuntu-nvidia/</url>
    
    <content type="html"><![CDATA[<h2 id="硬件平台"><a href="#硬件平台" class="headerlink" title="硬件平台"></a>硬件平台</h2><p>HUAWEI Matebook 14</p><p>CPU：Intel® Core™ i5-8265U CPU @ 1.60GHz × 8 </p><p>GPU：GeForce MX250&#x2F;PCIe&#x2F;SSE2 &#x2F; GeForce MX250&#x2F;PCIe&#x2F;SSE2</p><img align=center src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/Ubuntu_nvidia/1.png" style="zoom:80%;" /><h2 id="Nvidia显卡驱动安装"><a href="#Nvidia显卡驱动安装" class="headerlink" title="Nvidia显卡驱动安装"></a>Nvidia显卡驱动安装</h2><ol><li><p>更换国内的系统源，推荐Aliyun源</p></li><li><p>update, upgrade</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt upgrade<br></code></pre></td></tr></table></figure></li><li><p>加入N卡驱动源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo add-apt-repository ppa:graphics-drivers/ppa<br>sudo apt-get update<br></code></pre></td></tr></table></figure></li><li><p>查看显卡驱动，会列出当前的显卡和可安装的驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ubuntu-drivers devices<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">jason@Jason-Matebook:~$ ubuntu-drivers devices<br>== /sys/devices/pci0000:00/0000:00:1c.0/0000:01:00.0 ==<br>modalias : pci:v000010DEd00001D13sv000019E5sd00003E0Abc03sc02i00<br>vendor   : NVIDIA Corporation<br>model    : GP108M [GeForce MX250]<br>driver   : nvidia-driver-440 - distro non-free recommended<br>driver   : nvidia-driver-435 - distro non-free<br>driver   : xserver-xorg-video-nouveau - distro free <span class="hljs-built_in">builtin</span><br></code></pre></td></tr></table></figure></li><li><p>直接安装推荐的驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ubuntu-drivers autoinstall<br></code></pre></td></tr></table></figure></li><li><p>安装完重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo reboot<br></code></pre></td></tr></table></figure></li><li><p>查看一下显卡信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvidia-smi<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">Sat Jul 11 11:39:23 2020       <br>+-----------------------------------------------------------------------------+<br>| NVIDIA-SMI 440.100      Driver Version: 440.100      CUDA Version: 10.2     |<br>|-------------------------------+----------------------+----------------------+<br>| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |<br>| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |<br>|===============================+======================+======================|<br>|   0  GeForce MX250       Off  | 00000000:01:00.0 Off |                  N/A |<br>| N/A   46C    P0    N/A /  N/A |    228MiB /  2002MiB |      0%      Default |<br>+-------------------------------+----------------------+----------------------+<br>                                                                               <br>+-----------------------------------------------------------------------------+<br>| Processes:                                                       GPU Memory |<br>|  GPU       PID   Type   Process name                             Usage      |<br>|=============================================================================|<br>|    0       976      G   /usr/lib/xorg/Xorg                            61MiB |<br>|    0      1540      G   /usr/lib/xorg/Xorg                            70MiB |<br>|    0      1784      G   /usr/bin/gnome-shell                          88MiB |<br>+-----------------------------------------------------------------------------+<br><br></code></pre></td></tr></table></figure></li></ol><p>如果有信息显示出来，就说明安装成功</p><h2 id="环境检查"><a href="#环境检查" class="headerlink" title="环境检查"></a>环境检查</h2><p>1.验证自己的电脑是否有一个可以支持CUDA的GPU：</p><p>你可以在电脑的配置信息中找到显卡的具体型号，如果你是双系统，在windows下的设备管理器中也可以查到显卡的详细信息;在ubuntu下面的话，你可以通过下面这行命令来简单查看一下NVIDIA GPU版本信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lspci | grep -i nvidia<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">jason@Jason-Matebook:~$ lspci | grep -i nvidia<br>01:00.0 3D controller: NVIDIA Corporation GP108M [GeForce MX250] (rev a1)<br></code></pre></td></tr></table></figure><p>2.验证自己的linux版本是否支持CUDA：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -m &amp;&amp; <span class="hljs-built_in">cat</span> /etc/*release<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">jason@Jason-Matebook:~$ <span class="hljs-built_in">uname</span> -m &amp;&amp; <span class="hljs-built_in">cat</span> /etc/*release<br>x86_64<br>DISTRIB_ID=Ubuntu<br>DISTRIB_RELEASE=20.04<br>DISTRIB_CODENAME=focal<br>DISTRIB_DESCRIPTION=<span class="hljs-string">&quot;Ubuntu 20.04 LTS&quot;</span><br>NAME=<span class="hljs-string">&quot;Ubuntu&quot;</span><br>VERSION=<span class="hljs-string">&quot;20.04 LTS (Focal Fossa)&quot;</span><br>ID=ubuntu<br>ID_LIKE=debian<br>PRETTY_NAME=<span class="hljs-string">&quot;Ubuntu 20.04 LTS&quot;</span><br>VERSION_ID=<span class="hljs-string">&quot;20.04&quot;</span><br>HOME_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/&quot;</span><br>SUPPORT_URL=<span class="hljs-string">&quot;https://help.ubuntu.com/&quot;</span><br>BUG_REPORT_URL=<span class="hljs-string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br>PRIVACY_POLICY_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br>VERSION_CODENAME=focal<br>UBUNTU_CODENAME=focal<br></code></pre></td></tr></table></figure><p>3.验证系统是否安装了gcc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc --version<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">jason@Jason-Matebook:~$ gcc --version<br>gcc (Ubuntu 9.3.0-10ubuntu2) 9.3.0<br>Copyright (C) 2019 Free Software Foundation, Inc.<br>This is free software; see the <span class="hljs-built_in">source</span> <span class="hljs-keyword">for</span> copying conditions.  There is NO<br>warranty; not even <span class="hljs-keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<br></code></pre></td></tr></table></figure><p>其实这个刚装完系统的话应该都装好了，但是为了保险起见，你还是可以查看一下，如果你没有安装的话，你可以采取下面的命令对其进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install build-essential<br></code></pre></td></tr></table></figure><p>4.验证系统是否安装了kernel header和package development:</p><p>a.查看正在运行的系统内核版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">jason@Jason-Matebook:~$ <span class="hljs-built_in">uname</span> -r<br>5.4.0-40-generic<br></code></pre></td></tr></table></figure><p>b.安装对应kernel版本的kernel header和package development：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install linux-headers-$(<span class="hljs-built_in">uname</span> -r)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">jason@Jason-Matebook:~$ sudo apt-get install linux-headers-$(<span class="hljs-built_in">uname</span> -r)<br>正在读取软件包列表... 完成<br>正在分析软件包的依赖关系树       <br>正在读取状态信息... 完成       <br>linux-headers-5.4.0-40-generic 已经是最新版 (5.4.0-40.44)。<br>linux-headers-5.4.0-40-generic 已设置为手动安装。<br>升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。<br></code></pre></td></tr></table></figure><p>这个的话表示系统中已经有了，不用重复安装。</p><p>如果以上各项检查均满足要求的话，接下来就可以正式地进入安装界面了，如果有些地方没有满足要求的话，你需要参考cuda的官方文档，里面有详细的针对每个问题的解决方案。在以下链接中可以找到：<a href="https://docs.nvidia.com/cuda/">https://docs.nvidia.com/cuda/</a></p><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p>我们首先进入nvidia的<a href="https://developer.nvidia.com/cuda-90-download-archive">官方cuda9.0下载网页</a>。<a href="https://developer.nvidia.com/cuda-90-download-archive">https://developer.nvidia.com/cuda-90-download-archive</a></p><img align=center src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/Ubuntu_nvidia/2.png" style="zoom:80%;" /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-ubuntu2004.pin<br>sudo <span class="hljs-built_in">mv</span> cuda-ubuntu2004.pin /etc/apt/preferences.d/cuda-repository-pin-600<br>wget http://developer.download.nvidia.com/compute/cuda/11.0.2/local_installers/cuda-repo-ubuntu2004-11-0-local_11.0.2-450.51.05-1_amd64.deb<br>sudo dpkg -i cuda-repo-ubuntu2004-11-0-local_11.0.2-450.51.05-1_amd64.deb<br>sudo apt-key add /var/cuda-repo-ubuntu2004-11-0-<span class="hljs-built_in">local</span>/7fa2af80.pub<br>sudo apt-get update<br>sudo apt-get -y install cuda<br></code></pre></td></tr></table></figure><p>按照指引安装CUDA。</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>输入gedit ~&#x2F;.bashrc命令打开文件，在文件结尾输入以下语句，保存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/usr/local/cuda-11.0/bin<span class="hljs-variable">$&#123;PATH:+:<span class="hljs-variable">$&#123;PATH&#125;</span>&#125;</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/usr/local/cuda-11.0/lib64<span class="hljs-variable">$&#123;LD_LIBRARY_PATH:+:<span class="hljs-variable">$&#123;LD_LIBRARY_PATH&#125;</span>&#125;</span><br></code></pre></td></tr></table></figure><p>至此cuda安装完成，输入nvcc -V命令查看cuda信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">jason@Jason-Matebook:~$ nvcc -V<br>nvcc: NVIDIA (R) Cuda compiler driver<br>Copyright (c) 2005-2020 NVIDIA Corporation<br>Built on Thu_Jun_11_22:26:38_PDT_2020<br>Cuda compilation tools, release 11.0, V11.0.194<br>Build cuda_11.0_bu.TC445_37.28540450_0<br></code></pre></td></tr></table></figure><h2 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a><strong>安装cuDNN</strong></h2><p>从<a href="https://developer.nvidia.com/cudnn%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84cudnn%EF%BC%8C%E9%9C%80%E8%A6%81%E7%99%BB%E9%99%86%E3%80%82">https://developer.nvidia.com/cudnn下载相应版本的cudnn，需要登陆。</a></p><img align=center src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/Ubuntu_nvidia/3.png" style="zoom:80%;" /><p>下载解压之后，将cuda&#x2F;include&#x2F;cudnn.h文件复制到usr&#x2F;local&#x2F;cuda&#x2F;include文件夹，将cuda&#x2F;lib64&#x2F;下所有文件复制到&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64文件夹中，并添加读取权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*<br></code></pre></td></tr></table></figure><p>至此cuDNN安装完成</p><h2 id="安装Tensorflow"><a href="#安装Tensorflow" class="headerlink" title="安装Tensorflow"></a>安装Tensorflow</h2><ol><li><p>安装python（如果没有的话）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install python python3<br></code></pre></td></tr></table></figure></li><li><p>之后安装一下pip：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install python3-pip<br></code></pre></td></tr></table></figure><p>Python 2的 pip 没有被包含在 Ubuntu 20.04源仓库中。我们将会使用<code>get-pip.py</code>脚本来为 Python 2 安装 pip。</p><p>启用 universe 源仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo add-apt-repository universe<br></code></pre></td></tr></table></figure><p>更新软件包索引，并且安装 Python 2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update <br>sudo apt install python2<br></code></pre></td></tr></table></figure><p>使用<code>curl</code>命令来下载<code>get-pip.py</code>脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl https://bootstrap.pypa.io/get-pip.py --output get-pip.py<br></code></pre></td></tr></table></figure><p>一旦源仓库被启用，以 sudo 用户身份使用 <code>python2</code>运行脚本来为 Python 2 安装 pip：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo python2 get-pip.py<br></code></pre></td></tr></table></figure><p>Pip 将会被全局安装。如果你仅仅想为当前用户安装，不要使用<code>sudo</code>运行上面的命令。这个脚本还将会安装<code>setuptools</code> 和 <code>wheel</code>,它们允许你安装源码版本。</p><p>打印 Pip 版本号，验证安装过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip2 --version<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip 20.0.2 from /usr/local/lib/python2.7/dist-packages/pip (python 2.7)<br></code></pre></td></tr></table></figure></li><li><p>安装tensorflow-gpu 1.9.0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pip install tensorflow-gpu==1.9.0<br></code></pre></td></tr></table></figure><p>之后进入python输入以下命令检查安装是否完成：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">import tensorflow <span class="hljs-keyword">as</span> <span class="hljs-keyword">tf</span><br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">tf</span>.__version__)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>ENV</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>ubuntu</tag>
      
      <tag>nvidia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「LeetCode」——278. 第一个错误的版本（二分查找）</title>
    <link href="/2020/07/leetcode-278/"/>
    <url>/2020/07/leetcode-278/</url>
    
    <content type="html"><![CDATA[<h2 id="详述二分查找"><a href="#详述二分查找" class="headerlink" title="详述二分查找"></a>详述二分查找</h2><p>先看看Knuth（KMP算法发明者）怎么说：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Although</span></span> the basic idea of <span class="hljs-keyword">binary</span> search is comparatively straightforward, the details can be surprisingly tricky...<br></code></pre></td></tr></table></figure><p>总之就是二分查找的细节处理往往决定了程序是否能够正确运行。</p><p>比如，比较大小有没有等于号，mid该不该加1，往往这些问题就在查找的边界出现……</p><h3 id="二分查找基本框架"><a href="#二分查找基本框架" class="headerlink" title="二分查找基本框架"></a>二分查找基本框架</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = ...;<br>    <span class="hljs-keyword">while</span>(...) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">//防止溢出</span><br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = ...<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ...;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中…标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p><h3 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h3><p>这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; <br>    <span class="hljs-type">int</span> right = nums.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意（1）</span><br><br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123; <span class="hljs-comment">// 注意（2）</span><br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意（3）</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意（4）</span><br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（1）</strong>数组索引最大是length-1；</p><p><strong>（2）</strong>这里的while循环条件中为&lt;&#x3D;,如果为&lt;相当于查找区间为[left,right)，而无法找到最右边的值；如果为&#x3D;，那么查找区间就是[left,right]，这一点可以用在1，2，3中查找3的例子模拟验证一下。 </p><p><strong>（3）、（4）</strong>如果mid不满足条件，那么边界应该移动到mid的下一个数</p><p>再来探讨一下<strong>停止搜索的条件</strong>：</p><ol><li><p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(nums[mid] == target)<br>        <span class="hljs-keyword">return</span> mid; <br></code></pre></td></tr></table></figure></li><li><p>但如果没找到，就需要 while 循环终止，然后返回 -1。</p><p>在while(left &lt;&#x3D; right)的约束下下，终止条件是 left &#x3D;&#x3D; right + 1。</p><p>在while(left &lt; right)的约束下下，终止条件是 left &#x3D;&#x3D; right。</p><p>那么说明在不加等号的时候right所指的元素是无法参与比较的，那么就刚好漏掉了一个。</p><p>当然，如果你非要用 while(left &lt; right) 也可以，我们已经知道了出错的原因，就打个补丁好了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><p>只需要在最后比较一下漏掉的元素即可。</p></li></ol><h3 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a><strong>寻找左侧边界的二分搜索</strong></h3><p>直接看代码，其中的标记是需要注意的细节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.length; <span class="hljs-comment">// 注意（1）</span><br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">// 注意（2）</span><br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid; <span class="hljs-comment">// 注意（3）</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// target 比所有数都大</span><br><span class="hljs-keyword">if</span> (left == nums.length) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 类似之前算法的处理方式</span><br><span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//返回left或者right都一样，因为right=left为终止条件</span><br>&#125;<br></code></pre></td></tr></table></figure><p>先了解一下返回值的含义：</p><p>例：target&#x3D;2；nums&#x3D;[1,2,2,4,5]。对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 2 的元素有 1 个。</p><p>对于有序数组 nums &#x3D; [2,3,5,7], target &#x3D; 1，算法会返回 0，含义是：nums 中小于 1 的元素有 0 个。如果 target &#x3D; 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个，但是数组中没有这个数应该返回-1。</p><p>综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，所以我们简单添加两行代码就能在正确的时候 return -1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">// target 比所有数都大</span><br><span class="hljs-keyword">if</span> (left == nums.length) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 类似之前算法的处理方式</span><br><span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><p><strong>（1）</strong>这里的初始化条件一定要满足left的取值区间 [0, nums.length]，并且当left&#x3D;nums.length时返回-1，否则很可能会漏掉-1的情况。</p><p><strong>（2）</strong> 这里的终止条件是left &#x3D; right，相当于在搜索区间中，左边是闭区间，右边是开区间。</p><p><strong>（3）</strong>while条件决定了搜索区间，那么这里要满足左闭右开，并且不漏掉元素的话就需要让right&#x3D;mid。</p><p>该算法能找到左边界的主要原因还是对 nums[mid] &#x3D;&#x3D; target 这种情况的处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (nums[mid] == target)<br>right = mid;<br></code></pre></td></tr></table></figure><p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p><h3 id="寻找右侧边界的二分查找"><a href="#寻找右侧边界的二分查找" class="headerlink" title="寻找右侧边界的二分查找"></a>寻找右侧边界的二分查找</h3><p>寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.length;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意（1）</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意（2）</span><br></code></pre></td></tr></table></figure><p><em>1.</em> 为什么这个算法能够找到右侧边界？</p><p>答：类似地，关键点还是这里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>left = mid + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>当 nums[mid] &#x3D;&#x3D; target 时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。</p><p><em>2.</em> 为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。</p><p>答：首先，while 循环的终止条件是 left &#x3D;&#x3D; right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。</p><p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 这样想: mid = left - 1</span><br></code></pre></td></tr></table></figure><p>因为我们对 left 的更新必须是 left &#x3D; mid + 1，就是说 while 循环结束时，nums[left] <strong>一定不等于</strong> target 了，而 nums[left - 1]<strong>可能是</strong>target。</p><p><em>3.</em> 为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？</p><p>答：类似之前的左侧边界搜索，因为 while 的终止条件是 left &#x3D;&#x3D; right，就是说 left 的取值范围是 [0, nums.length]，所以可以添加两行代码，正确地返回 -1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> nums[left<span class="hljs-number">-1</span>] == target ? (left<span class="hljs-number">-1</span>) : <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><h3 id="概括总结"><a href="#概括总结" class="headerlink" title="概括总结"></a>概括总结</h3><p>第一个，最基本的二分查找算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">因为我们初始化 right = nums.length - <span class="hljs-number">1</span><br>所以决定了我们的「搜索区间」是 [left, right]<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt;= right)<br>同时也决定了 left = mid+<span class="hljs-number">1</span> 和 right = mid<span class="hljs-number">-1</span><br><br>因为我们只需找到一个 target 的索引即可<br>所以当 nums[mid] == target 时可以立即返回<br></code></pre></td></tr></table></figure><p>第二个，寻找左侧边界的二分查找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt; right)<br>同时也决定了 left = mid+<span class="hljs-number">1</span> 和 right = mid<br><br>因为我们需找到 target 的最左侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧右侧边界以锁定左侧边界<br></code></pre></td></tr></table></figure><p>第三个，寻找右侧边界的二分查找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt; right)<br>同时也决定了 left = mid+<span class="hljs-number">1</span> 和 right = mid<br><br>因为我们需找到 target 的最右侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧左侧边界以锁定右侧边界<br><br>又因为收紧左侧边界时必须 left = mid + <span class="hljs-number">1</span><br>所以最后无论返回 left 还是 right，必须减一<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>oj</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署及Portainer可视化面板搭建</title>
    <link href="/2020/07/docker-portainer/"/>
    <url>/2020/07/docker-portainer/</url>
    
    <content type="html"><![CDATA[<p><strong>测试平台（理论上Linux下都大同小异）</strong>：VMware Deepin 15.5 based on Debian</p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>推荐<strong>官方安装脚本自动安装</strong></p><p>安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun<br></code></pre></td></tr></table></figure><p>也可以使用国内 daocloud 一键安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sSL https://get.daocloud.io/docker | sh<br></code></pre></td></tr></table></figure><p>安装过程如下：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/docker/1.png" style="zoom:100%;" /></div><h2 id="Portainer搭建可视化界面"><a href="#Portainer搭建可视化界面" class="headerlink" title="Portainer搭建可视化界面"></a>Portainer搭建可视化界面</h2><h2 id="Portainer介绍"><a href="#Portainer介绍" class="headerlink" title="Portainer介绍"></a>Portainer介绍</h2><p>Portainer是Docker的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。</p><p><strong>下载Portainer镜像</strong><br><strong>查询当前有哪些Portainer镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker search portainer<br></code></pre></td></tr></table></figure><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/docker/2.png" style="zoom:100%;" /></div><p>上图就是查询出来的有下载量的portainer镜像，我们下载第一个镜像：docker.io&#x2F;portainer&#x2F;portainer。</p><p><strong>下载镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull docker.io/portainer/portainer<br></code></pre></td></tr></table></figure><h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><p>如果仅有一个docker宿主机，则可使用单机版运行，Portainer单机版运行十分简单，只需要一条语句即可启动容器，来管理该机器上的docker镜像、容器等数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 9000:9000 \<br>--restart=always \<br>-v /var/run/docker.sock:/var/run/docker.sock \<br>--name prtainer-test \<br>docker.io/portainer/portainer<br></code></pre></td></tr></table></figure><p>该语句用宿主机9000端口关联容器中的9000端口，并给容器起名为portainer-test。执行完该命令之后，使用该机器IP:PORT即可访问Portainer。</p><p>访问方式：<a href="http://ip:9000/">http://IP:9000</a></p><p>首次登陆需要注册用户，给admin用户设置密码：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/docker/3.png" style="zoom:100%;" /></div><p>单机版这里选择local即可，选择完毕，点击Connect即可连接到本地docker：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/docker/4.png" style="zoom:100%;" /><div><p>注意：该页面上有提示需要挂载本地 &#x2F;var&#x2F;run&#x2F;docker.socker与容器内的&#x2F;var&#x2F;run&#x2F;docker.socker连接。因此，在启动时必须指定该挂载文件。</p><p>首页：</p><img align=center src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/docker/5.png" style="zoom:100%;" /><p><em><strong>DONE!</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>portainer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker Compose部署</title>
    <link href="/2020/07/docker-compose/"/>
    <url>/2020/07/docker-compose/</url>
    
    <content type="html"><![CDATA[<p><strong>环境条件</strong> Deepin 15.5 based on Debian 已部署完成Docker</p><h3 id="Compose-简介"><a href="#Compose-简介" class="headerlink" title="Compose 简介"></a>Compose 简介</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p><p>如果你还不了解 YML 文件配置，可以先阅读 <a href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 入门教程</a>。</p><p>Compose 使用的三个步骤：</p><ul><li>使用 Dockerfile 定义应用程序的环境。</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li><li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li></ul><p>docker-compose.yml 的配置案例如下（配置参数参考下文）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">yaml 配置实例</span><br>version: &#x27;3&#x27;<br>services:<br>  web:<br>    build: .<br>    ports:<br>   - &quot;5000:5000&quot;<br>    volumes:<br>   - .:/code<br>    - logvolume01:/var/log<br>    links:<br>   - redis<br>  redis:<br>    image: redis<br>volumes:<br>  logvolume01: &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="Compose-安装"><a href="#Compose-安装" class="headerlink" title="Compose 安装"></a>Compose 安装</h2><p>Linux</p><p>Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：<a href="https://github.com/docker/compose/releases%E3%80%82">https://github.com/docker/compose/releases。</a></p><p>运行以下命令以下载 Docker Compose 的当前稳定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>要安装其他版本的 Compose，请替换 1.24.1。</p><p>将可执行权限应用于二进制文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>创建软链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">ln</span> -s /usr/local/bin/docker-compose /usr/bin/docker-compose<br></code></pre></td></tr></table></figure><p>测试是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker-compose --version<br>cker-compose version 1.24.1, build 4667896b<br></code></pre></td></tr></table></figure><p>安装过程如下：</p><img align=center src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/docker_compose/docker-compose.png" style="zoom:100%;" /><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h3><p>创建一个测试目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> composetest<br>$ <span class="hljs-built_in">cd</span> composetest<br></code></pre></td></tr></table></figure><p>在测试目录中创建一个名为 app.py 的文件，并复制粘贴以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">import</span> redis<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br>cache = redis.Redis(host=<span class="hljs-string">&#x27;redis&#x27;</span>, port=<span class="hljs-number">6379</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_hit_count</span>():<br>    retries = <span class="hljs-number">5</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> cache.incr(<span class="hljs-string">&#x27;hits&#x27;</span>)<br>        <span class="hljs-keyword">except</span> redis.exceptions.ConnectionError <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-keyword">if</span> retries == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">raise</span> exc<br>            retries -= <span class="hljs-number">1</span><br>            time.sleep(<span class="hljs-number">0.5</span>)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    count = get_hit_count()<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="hljs-built_in">format</span>(count)<br></code></pre></td></tr></table></figure><p>在此示例中，redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379。</p><p>在 composetest 目录中创建另一个名为 requirements.txt 的文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">flask<br>redis<br></code></pre></td></tr></table></figure><h3 id="2、创建-Dockerfile-文件"><a href="#2、创建-Dockerfile-文件" class="headerlink" title="2、创建 Dockerfile 文件"></a>2、创建 Dockerfile 文件</h3><p>在 composetest 目录中，创建一个名为的文件 Dockerfile，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM python:3.7-alpine<br>WORKDIR /code<br>ENV FLASK_APP app.py<br>ENV FLASK_RUN_HOST 0.0.0.0<br>RUN apk add --no-cache gcc musl-dev linux-headers<br>COPY requirements.txt requirements.txt<br>RUN pip install -r requirements.txt<br>COPY . .<br>CMD [&quot;flask&quot;, &quot;run&quot;]<br></code></pre></td></tr></table></figure><p><strong>Dockerfile 内容解释：</strong></p><ul><li><p><strong>FROM python:3.7-alpine</strong>: 从 Python 3.7 映像开始构建镜像。</p></li><li><p><strong>WORKDIR &#x2F;code</strong>: 将工作目录设置为 &#x2F;code。</p></li><li><pre><code class="shell">ENV FLASK_APP app.pyENV FLASK_RUN_HOST 0.0.0.0<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>  设置 flask 命令使用的环境变量。<br><br>- **<span class="hljs-built_in">RUN</span> apk <span class="hljs-built_in">add</span> --no-cache gcc musl-dev linux-headers**: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。<br><br>- ```bash<br>  COPY requirements.txt requirements.txt<br>  <span class="hljs-built_in">RUN</span> pip install -r requirements.txt<br></code></pre></td></tr></table></figure>复制 requirements.txt 并安装 Python 依赖项。</code></pre></li><li><p><strong>COPY . .</strong>: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。</p></li><li><p><strong>CMD [“flask”, “run”]</strong>: 容器提供默认的执行命令为：flask run。</p></li></ul><h3 id="3、创建-docker-compose-yml"><a href="#3、创建-docker-compose-yml" class="headerlink" title="3、创建 docker-compose.yml"></a>3、创建 docker-compose.yml</h3><p>在测试目录中创建一个名为 docker-compose.yml 的文件，然后粘贴以下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># yaml 配置</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;redis:alpine&quot;</span><br></code></pre></td></tr></table></figure><p>该 Compose 文件定义了两个服务：web 和 redis。</p><ul><li><strong>web</strong>：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。</li><li><strong>redis</strong>：该 redis 服务使用 Docker Hub 的公共 Redis 映像。</li></ul><h3 id="4、使用-Compose-命令构建和运行您的应用"><a href="#4、使用-Compose-命令构建和运行您的应用" class="headerlink" title="4、使用 Compose 命令构建和运行您的应用"></a>4、使用 Compose 命令构建和运行您的应用</h3><p>在测试目录中，执行以下命令来启动应用程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up<br></code></pre></td></tr></table></figure><p>如果你想在后台执行该服务可以加上 <strong>-d</strong> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="yml-配置指令参考"><a href="#yml-配置指令参考" class="headerlink" title="yml 配置指令参考"></a>yml 配置指令参考</h2><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>指定本 yml 依从的 compose 哪个版本制定的。</p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>指定为构建镜像上下文路径：</p><p>例如 webapp 服务，指定为从上下文路径 .&#x2F;dir&#x2F;Dockerfile 所构建的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">version: <span class="hljs-string">&quot;3.7&quot;</span><br>services:<br>  webapp:<br>    build: ./dir<br></code></pre></td></tr></table></figure><p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">version: <span class="hljs-string">&quot;3.7&quot;</span><br>services:<br>  webapp:<br>    build:<br>      context: ./dir<br>      dockerfile: Dockerfile-alternate<br>      args:<br>        buildno: 1<br>      labels:<br>        - <span class="hljs-string">&quot;com.example.description=Accounting webapp&quot;</span><br>        - <span class="hljs-string">&quot;com.example.department=Finance&quot;</span><br>        - <span class="hljs-string">&quot;com.example.label-with-empty-value&quot;</span><br>      target: prod<br></code></pre></td></tr></table></figure><ul><li>context：上下文路径。</li><li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li><li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li><li>labels：设置构建镜像的标签。</li><li>target：多层构建，可以指定构建哪一层。</li></ul><h3 id="cap-add，cap-drop"><a href="#cap-add，cap-drop" class="headerlink" title="cap_add，cap_drop"></a>cap_add，cap_drop</h3><p>添加或删除容器拥有的宿主机的内核功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">cap_add:<br>  - ALL <span class="hljs-comment"># 开启全部权限</span><br><br>cap_drop:<br>  - SYS_PTRACE <span class="hljs-comment"># 关闭 ptrace权限</span><br></code></pre></td></tr></table></figure><h3 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h3><p>为容器指定父 cgroup 组，意味着将继承该组的资源限制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cgroup_parent: m-executor-abcd<br></code></pre></td></tr></table></figure><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>覆盖容器启动的默认命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span>: [<span class="hljs-string">&quot;bundle&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-string">&quot;thin&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;3000&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>指定自定义容器名称，而不是生成的默认名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">container_name: my-web-container<br></code></pre></td></tr></table></figure><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>设置依赖关系。</p><ul><li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li><li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li><li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">version: <span class="hljs-string">&quot;3.7&quot;</span><br>services:<br>  web:<br>    build: .<br>    depends_on:<br>      - db<br>      - redis<br>  redis:<br>    image: redis<br>  db:<br>    image: postgres<br></code></pre></td></tr></table></figure><p>注意：web 服务不会等待 redis db 完全启动 之后才启动。</p><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p>指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">version: <span class="hljs-string">&quot;3.7&quot;</span><br>services:<br>  redis:<br>    image: redis:alpine<br>    deploy:<br>      mode：replicated<br>      replicas: 6<br>      endpoint_mode: dnsrr<br>      labels: <br>        description: <span class="hljs-string">&quot;This redis service label&quot;</span><br>      resources:<br>        limits:<br>          cpus: <span class="hljs-string">&#x27;0.50&#x27;</span><br>          memory: 50M<br>        reservations:<br>          cpus: <span class="hljs-string">&#x27;0.25&#x27;</span><br>          memory: 20M<br>      restart_policy:<br>        condition: on-failure<br>        delay: 5s<br>        max_attempts: 3<br>        window: 120s<br></code></pre></td></tr></table></figure><p>可以选参数：</p><p><strong>endpoint_mode</strong>：访问集群服务的方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">endpoint_mode: vip <br><span class="hljs-comment"># Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</span><br>endpoint_mode: dnsrr<br><span class="hljs-comment"># DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</span><br></code></pre></td></tr></table></figure><p><strong>labels</strong>：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</p><p><strong>mode</strong>：指定服务提供的模式。</p><ul><li><strong>replicated</strong>：复制服务，复制指定服务到集群的机器上。</li><li><strong>global</strong>：全局服务，服务将部署至集群的每个节点。</li><li>图解：下图中黄色的方块是 replicated 模式的运行情况，灰色方块是 global 模式的运行情况。</li></ul><img align=center src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/docker_compose/docker-composex.png" style="zoom:100%;" /><p><strong>replicas：mode</strong> 为 replicated 时，需要使用此参数配置具体运行的节点数量。</p><p><strong>resources</strong>：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。</p><p><strong>restart_policy</strong>：配置如何在退出容器时重新启动容器。</p><ul><li>condition：可选 none，on-failure 或者 any（默认值：any）。</li><li>delay：设置多久之后重启（默认值：0）。</li><li>max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。</li><li>window：设置容器重启超时时间（默认值：0）。</li></ul><p><strong>rollback_config</strong>：配置在更新失败的情况下应如何回滚服务。</p><ul><li>parallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。</li><li>delay：每个容器组回滚之间等待的时间（默认为0s）。</li><li>failure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认pause）。</li><li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li><li>max_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。</li><li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。</li></ul><p><strong>update_config</strong>：配置应如何更新服务，对于配置滚动更新很有用。</p><ul><li>parallelism：一次更新的容器数。</li><li>delay：在更新一组容器之间等待的时间。</li><li>failure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者pause （默认：pause）。</li><li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li><li>max_failure_ratio：在更新过程中可以容忍的故障率。</li><li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。</li></ul><p><strong>注</strong>：仅支持 V3.4 及更高版本。</p><h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h3><p>指定设备映射列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">devices:<br>  - <span class="hljs-string">&quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;</span><br></code></pre></td></tr></table></figure><h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>自定义 DNS 服务器，可以是单个值或列表的多个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">dns: 8.8.8.8<br><br>dns:<br>  - 8.8.8.8<br>  - 9.9.9.9<br></code></pre></td></tr></table></figure><h3 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h3><p>自定义 DNS 搜索域。可以是单个值或列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">dns_search: example.com<br><br>dns_search:<br>  - dc1.example.com<br>  - dc2.example.com<br></code></pre></td></tr></table></figure><h3 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h3><p>覆盖容器默认的 entrypoint。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">entrypoint: /code/entrypoint.sh<br></code></pre></td></tr></table></figure><p>也可以是以下格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">entrypoint:<br>    - php<br>    - -d<br>    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so<br>    - -d<br>    - memory_limit=-1<br>    - vendor/bin/phpunit<br></code></pre></td></tr></table></figure><h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h3><p>从文件添加环境变量。可以是单个值或列表的多个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">env_file: .<span class="hljs-built_in">env</span><br></code></pre></td></tr></table></figure><p>也可以是列表格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">env_file:<br>  - ./common.env<br>  - ./apps/web.env<br>  - /opt/secrets.env<br></code></pre></td></tr></table></figure><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">environment:<br>  RACK_ENV: development<br>  SHOW: <span class="hljs-string">&#x27;true&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">expose:<br> - <span class="hljs-string">&quot;3000&quot;</span><br> - <span class="hljs-string">&quot;8000&quot;</span><br></code></pre></td></tr></table></figure><h3 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h3><p>添加主机名映射。类似 docker client –add-host。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">extra_hosts:<br> - <span class="hljs-string">&quot;somehost:162.242.195.82&quot;</span><br> - <span class="hljs-string">&quot;otherhost:50.31.209.229&quot;</span><br></code></pre></td></tr></table></figure><p>以上会在此服务的内部容器中 &#x2F;etc&#x2F;hosts 创建一个具有 ip 地址和主机名的映射关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">162.242.195.82  somehost<br>50.31.209.229   otherhost<br></code></pre></td></tr></table></figure><h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h3><p>用于检测 docker 服务是否健康运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">healthcheck:<br>  <span class="hljs-built_in">test</span>: [<span class="hljs-string">&quot;CMD&quot;</span>, <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;http://localhost&quot;</span>] <span class="hljs-comment"># 设置检测程序</span><br>  interval: 1m30s <span class="hljs-comment"># 设置检测间隔</span><br>  <span class="hljs-built_in">timeout</span>: 10s <span class="hljs-comment"># 设置检测超时时间</span><br>  retries: 3 <span class="hljs-comment"># 设置重试次数</span><br>  start_period: 40s <span class="hljs-comment"># 启动后，多少秒开始启动检测程序</span><br></code></pre></td></tr></table></figure><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定容器运行的镜像。以下格式都可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">image: redis<br>image: ubuntu:14.04<br>image: tutum/influxdb<br>image: example-registry.com:4000/postgresql<br>image: a4bc65fd <span class="hljs-comment"># 镜像id</span><br></code></pre></td></tr></table></figure><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>服务的日志记录配置。</p><p>driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">driver: <span class="hljs-string">&quot;json-file&quot;</span><br>driver: <span class="hljs-string">&quot;syslog&quot;</span><br>driver: <span class="hljs-string">&quot;none&quot;</span><br></code></pre></td></tr></table></figure><p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">logging:<br>  driver: json-file<br>  options:<br>    max-size: <span class="hljs-string">&quot;200k&quot;</span> <span class="hljs-comment"># 单个文件大小为200k</span><br>    max-file: <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-comment"># 最多10个文件</span><br></code></pre></td></tr></table></figure><p>当达到文件限制上限，会自动删除旧得文件。</p><p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">logging:<br>  driver: syslog<br>  options:<br>    syslog-address: <span class="hljs-string">&quot;tcp://192.168.0.42:123&quot;</span><br></code></pre></td></tr></table></figure><h3 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h3><p>设置网络模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">network_mode: <span class="hljs-string">&quot;bridge&quot;</span><br>network_mode: <span class="hljs-string">&quot;host&quot;</span><br>network_mode: <span class="hljs-string">&quot;none&quot;</span><br>network_mode: <span class="hljs-string">&quot;service:[service name]&quot;</span><br>network_mode: <span class="hljs-string">&quot;container:[container name/id]&quot;</span><br></code></pre></td></tr></table></figure><p>networks</p><p>配置容器连接的网络，引用顶级 networks 下的条目 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">services:<br>  some-service:<br>    networks:<br>      some-network:<br>        aliases:<br>         - alias1<br>      other-network:<br>        aliases:<br>         - alias2<br>networks:<br>  some-network:<br>    <span class="hljs-comment"># Use a custom driver</span><br>    driver: custom-driver-1<br>  other-network:<br>    <span class="hljs-comment"># Use a custom driver which takes special options</span><br>    driver: custom-driver-2<br></code></pre></td></tr></table></figure><p><strong>aliases</strong> ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。</p><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><ul><li>no：是默认的重启策略，在任何情况下都不会重启容器。</li><li>always：容器总是重新启动。</li><li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li><li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">restart: <span class="hljs-string">&quot;no&quot;</span><br>restart: always<br>restart: on-failure<br>restart: unless-stopped<br></code></pre></td></tr></table></figure><p>注：swarm 集群模式，请改用 restart_policy。</p><h3 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h3><p>存储敏感数据，例如密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">version: <span class="hljs-string">&quot;3.1&quot;</span><br>services:<br><br>mysql:<br>  image: mysql<br>  environment:<br>    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my_secret<br>  secrets:<br>    - my_secret<br><br>secrets:<br>  my_secret:<br>    file: ./my_secret.txt<br></code></pre></td></tr></table></figure><h3 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h3><p>修改容器默认的 schema 标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">security-opt：<br>  - label:user:USER   <span class="hljs-comment"># 设置容器的用户标签</span><br>  - label:role:ROLE   <span class="hljs-comment"># 设置容器的角色标签</span><br>  - label:<span class="hljs-built_in">type</span>:TYPE   <span class="hljs-comment"># 设置容器的安全策略标签</span><br>  - label:level:LEVEL  <span class="hljs-comment"># 设置容器的安全等级标签</span><br></code></pre></td></tr></table></figure><h3 id="stop-grace-period"><a href="#stop-grace-period" class="headerlink" title="stop_grace_period"></a>stop_grace_period</h3><p>指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">stop_grace_period: 1s <span class="hljs-comment"># 等待 1 秒</span><br>stop_grace_period: 1m30s <span class="hljs-comment"># 等待 1 分 30 秒 </span><br></code></pre></td></tr></table></figure><p>默认的等待时间是 10 秒。</p><h3 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h3><p>设置停止容器的替代信号。默认情况下使用 SIGTERM 。</p><p>以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">stop_signal: SIGUSR1<br></code></pre></td></tr></table></figure><h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h3><p>设置容器中的内核参数，可以使用数组或字典格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">sysctls:<br>  net.core.somaxconn: 1024<br>  net.ipv4.tcp_syncookies: 0<br><br>sysctls:<br>  - net.core.somaxconn=1024<br>  - net.ipv4.tcp_syncookies=0<br></code></pre></td></tr></table></figure><h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h3><p>在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmpfs: /run<br><br>tmpfs:<br>  - /run<br>  - /tmp<br></code></pre></td></tr></table></figure><h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h3><p>覆盖容器默认的 ulimit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ulimits:<br>  <span class="hljs-built_in">nproc</span>: 65535<br>  nofile:<br>    soft: 20000<br>    hard: 40000<br></code></pre></td></tr></table></figure><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>将主机的数据卷或着文件挂载到容器里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">version: <span class="hljs-string">&quot;3.7&quot;</span><br>services:<br>  db:<br>    image: postgres:latest<br>    volumes:<br>      - <span class="hljs-string">&quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;</span><br>      - <span class="hljs-string">&quot;/localhost/data:/var/lib/postgresql/data&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「LeetCode」—— 28.实现 strStr() —KMP算法</title>
    <link href="/2020/07/leetcode-28/"/>
    <url>/2020/07/leetcode-28/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三位神人共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。</p><h2 id="提取加速匹配信息"><a href="#提取加速匹配信息" class="headerlink" title="提取加速匹配信息"></a>提取加速匹配信息</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><iframe height="600" width="800" src="//player.bilibili.com/player.html?aid=49930100&bvid=BV1jb411V78H&cid=119839716&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>这一个视频讲解的比较简单易懂。</p><p>通过观看讲解，我们可以知道这里的重点就是<strong>生成next数组</strong>。</p><p>可以再参考一下《漫画算法》中小灰灰的讲解：</p><p><strong>next 数组</strong></p><p>next数组到底是个什么鬼呢？这是一个一维整型数组，数组的下标代表了“已匹配前缀的下一个位置”，元素的值则是“最长可匹配前缀子串的下一个位置”。</p><p>或许这样的描述有些晦涩，我们来看一下图：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/1.png"></p><p>当模式串的第一个字符就和主串不匹配时，并不存在已匹配前缀子串，更不存在最长可匹配前缀子串。这种情况对应的next数组下标是0，next[0]的元素值也是0。</p><p>如果已匹配前缀是G、GT、GTGTGC，并不存在最长可匹配前缀子串，所以对应的next数组元素值（next[1]，next[2]，next[6]）同样是0。</p><p>GTG的最长可匹配前缀是G，对应数组中的next[3]，元素值是1。</p><p>以此类推，</p><p>GTGT 对应 next[4]，元素值是2。</p><p>GTGTG 对应 next[5]，元素值是3。</p><p>有了next数组，我们就可以通过已匹配前缀的下一个位置（坏字符位置），快速寻找到最长可匹配前缀的下一个位置，然后把这两个位置对齐。</p><p>比如下面的场景，我们通过坏字符下标5，可以找到next[5]&#x3D;3，即最长可匹配前缀的下一个位置：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/2.png"></p><p>说完了next数组是什么，接下来我们再来思考一下，如何事先生成这个next数组呢？</p><p>由于已匹配前缀数组在主串和模式串当中是相同的，所以我们仅仅依据模式串，就足以生成next数组。</p><p>最简单的方法是从最长的前缀子串开始，把每一种可能情况都做一次比较。</p><p>假设模式串的长度是m，生成next数组所需的最大总比较次数是1+2+3+4+……+m-2 次。</p><p>显然，这种方法的效率非常低，如何进行优化呢？</p><p>我们可以采用类似“动态规划”的方法。首先next[0]和next[1]的值肯定是0，因为这时候不存在前缀子串；从next[2]开始，next数组的每一个元素都可以由上一个元素推导而来。</p><p>已知next[i]的值，如何推导出next[i+1]呢？让我们来演示一下上述next数组的填充过程：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/3.png"></p><p>如图所示，我们设置两个变量i和j，其中i表示“已匹配前缀的下一个位置”，也就是待填充的数组下标，j表示“最长可匹配前缀子串的下一个位置”，也就是待填充的数组元素值。</p><p>当已匹配前缀不存在的时候，最长可匹配前缀子串当然也不存在，所以i&#x3D;0，j&#x3D;0，此时next[0] &#x3D; 0。</p><p>接下来，我们让已匹配前缀子串的长度加1：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/4.png"></p><p>此时的已匹配前缀是G，由于只有一个字符，同样不存在最长可匹配前缀子串，所以i&#x3D;1，j&#x3D;0，next[1] &#x3D; 0。</p><p>接下来，我们让已匹配前缀子串的长度继续加1：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/5.png"></p><p>此时的已匹配前缀是GT，我们需要开始做判断了：由于模式串当中 pattern[j] !&#x3D; pattern[i-1]，即G！&#x3D;T，最长可匹配前缀子串仍然不存在。</p><p>所以当i&#x3D;2时，j仍然是0，next[2] &#x3D; 0。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/6.png"></p><p>接下来，我们让已匹配前缀子串的长度继续加1：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/7.png"></p><p>此时的已匹配前缀是GTG，由于模式串当中 pattern[j] &#x3D; pattern[i-1]，即G&#x3D;G，最长可匹配前缀子串出现了，是G。</p><p>所以当i&#x3D;3时，j&#x3D;1，next[3] &#x3D; next[2]+1 &#x3D; 1。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/8.png"></p><p>接下来，我们让已匹配前缀子串的长度继续加1：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/9.png"></p><p>此时的已匹配前缀是GTGT，由于模式串当中 pattern[j] &#x3D; pattern[i-1]，即T&#x3D;T，最长可匹配前缀子串又增加了一位，是GT。</p><p>所以当i&#x3D;4时，j&#x3D;2，next[4] &#x3D; next[3]+1 &#x3D; 2。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/10.png"></p><p>接下来，我们让已匹配前缀子串的长度继续加1：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/11.png"></p><p>此时的已匹配前缀是GTGTG，由于模式串当中 pattern[j] &#x3D; pattern[i-1]，即G&#x3D;G，最长可匹配前缀子串又增加了一位，是GTG。</p><p>所以当i&#x3D;5时，j&#x3D;3，next[5] &#x3D; next[4]+1 &#x3D; 3。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/12.png"></p><p>接下来，我们让已匹配前缀子串的长度继续加1：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/13.png"></p><p>此时的已匹配前缀是GTGTGC，这时候需要注意了，模式串当中 pattern[j] ！&#x3D; pattern[i-1]，即T !&#x3D; C，这时候该怎么办呢？</p><p>这时候，我们已经无法从next[5]的值来推导出next[6]，而字符C的前面又有两段重复的子串“GTG”。那么，我们能不能把问题转化一下？</p><p>或许听起来有些绕：我们可以把计算“GTGTGC”最长可匹配前缀子串的问题，转化成计算“GTGC”最长可匹配前缀子串的问题。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/14.png"></p><p>这样的问题转化，也就相当于把变量j回溯到了next[j]，也就是j&#x3D;1的局面（i值不变）：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/15.png"></p><p>回溯后，情况仍然是 pattern[j] ！&#x3D; pattern[i-1]，即T！&#x3D;C。那么我们可以把问题继续进行转化：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/16.png"></p><p>问题再次的转化，相当于再一次把变量j回溯到了next[j]，也就是j&#x3D;0的局面：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/19.png"></p><p>回溯后，情况仍然是 pattern[j] ！&#x3D; pattern[i-1]，即G！&#x3D;C。j已经不能再次回溯了，所以我们得出结论：i&#x3D;6时，j&#x3D;0，next[6] &#x3D; 0。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/kmp/20.png"></p><p>以上就是next数组元素的推导过程。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><iframe height="600" width="800" src="//player.bilibili.com/player.html?aid=55360813&bvid=BV1T4411P7AG&cid=96796797&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><strong>get_next代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_next</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-built_in">string</span>, <span class="hljs-type">int</span>* next)</span> &#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>))&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||<span class="hljs-built_in">string</span>[i]==<span class="hljs-built_in">string</span>[j])&#123;<br>            i++,j++;<br>            next[i]=j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        j=next[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里字符数组的第0位是存放了字母的</strong></p><p>这里重点解释一下当<code>string[i]!=string[j]</code>时的情况:</p><p>当匹配到第 i 和 j 失败时，next[j+1] &lt; i，那么求 next[j+1] 就等同于求 string[j-i+1] ~ string[j] 与 string[0] ~ string[i-1] 的最长重合串，那么就相当于求 next[i]，即<code>j=next[j]</code>。</p><h4 id="打印next数组代码"><a href="#打印next数组代码" class="headerlink" title="打印next数组代码"></a>打印next数组代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_next</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-built_in">string</span>, <span class="hljs-type">int</span>* next)</span> &#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>))&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||<span class="hljs-built_in">string</span>[i]==<span class="hljs-built_in">string</span>[j])&#123;<br>            i++,j++;<br>            next[i]=j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        j=next[j];<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>]=&#123;<span class="hljs-string">&quot;ababaaabbaba&quot;</span>&#125;;<br>    <span class="hljs-type">int</span> next[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    get_next(str, next);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">strlen</span>(str); i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,str[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">strlen</span>(str);i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>,i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">strlen</span>(str);i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>,next[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">a       b       a       b       a       a       a       b       b       a       b       a       ;<br>0      <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 3 </span>     <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 5 </span>     <span class="hljs-number"> 6 </span>     <span class="hljs-number"> 7 </span>     <span class="hljs-number"> 8 </span>     <span class="hljs-number"> 9 </span>     <span class="hljs-number"> 10 </span>     11;<br>-1     <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 3 </span>     <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1 </span>      2;<br></code></pre></td></tr></table></figure><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>实现 <a href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 <strong>-1</strong>。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;ll&quot;</span><br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;aaaaa&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;bba&quot;</span><br>输出: -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义相符。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_next</span><span class="hljs-params">(<span class="hljs-type">char</span>* T, <span class="hljs-type">int</span> *next)</span><br>&#123;<br><span class="hljs-type">int</span> j, k;<br>j = <span class="hljs-number">0</span>;<br>k = <span class="hljs-number">-1</span>;<br>next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span> (j &lt; <span class="hljs-built_in">strlen</span>(T))&#123;<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">-1</span> || T[j] == T[k])&#123;<br>j++;<br>k++;<br>next[j] = k;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>k = next[k];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//KMP算法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">KMP</span><span class="hljs-params">(<span class="hljs-type">char</span>* S, <span class="hljs-type">char</span>* T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>,next[<span class="hljs-number">255</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>get_next(T, next);<br><span class="hljs-type">int</span> slen = <span class="hljs-built_in">strlen</span>(S);<br><span class="hljs-type">int</span> tlen = <span class="hljs-built_in">strlen</span>(T);<br><br><span class="hljs-keyword">while</span> (i &lt; slen &amp;&amp; j &lt; tlen)&#123;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || S[i] == T[j])&#123;<br>i++;<br>j++;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>j = next[j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (j == tlen)&#123;<br><span class="hljs-keyword">return</span> i - tlen;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>oj</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「LeetCode」——8.字符串转换整数 (atoi)</title>
    <link href="/2020/07/leetcode-8/"/>
    <url>/2020/07/leetcode-8/</url>
    
    <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><ul><li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li><li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li><li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li></ul><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p><strong>提示：</strong></p><ul><li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li><li>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;42&quot;</span><br><span class="hljs-section">输出: 42</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;   -42&quot;</span><br><span class="hljs-section">输出: -42</span><br><span class="hljs-section">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;4193 with words&quot;</span><br><span class="hljs-section">输出: 4193</span><br><span class="hljs-section">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;words and 987&quot;</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br>     因此无法执行有效的转换。<br></code></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: &quot;-<span class="hljs-number">91283472332</span>&quot;<br>输出: -<span class="hljs-number">2147483648</span><br>解释: 数字 &quot;-<span class="hljs-number">91283472332</span>&quot; 超过 <span class="hljs-number">32</span> 位有符号整数范围。 <br>     因此返回 INT_MIN (−<span class="hljs-number">231</span>) 。<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这里主要涉及两个问题：1、字符串处理；2、转换成整数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">*str <span class="hljs-comment">//原始字符串</span><br>*s   <span class="hljs-comment">//处理后字符串</span><br></code></pre></td></tr></table></figure><h3 id="1-字符串处理"><a href="#1-字符串处理" class="headerlink" title="1. 字符串处理"></a>1. 字符串处理</h3><h4 id="无法进行有效转换："><a href="#无法进行有效转换：" class="headerlink" title="无法进行有效转换："></a>无法进行有效转换：</h4><p>假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><ol><li><p>假如该字符串中的第一个非空格字符不是一个有效整数字符。</p><p>即不允许其他字符出现在第一个’+’，’-‘，’0‘~’9’之前</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>示例<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></li><li><p>字符串为空</p></li><li><p>字符串仅包含空白字符</p></li></ol><p><strong>除此之外还有一些容易忽略的情况</strong></p><ol start="4"><li><p>在’+‘，’-‘后面’0‘——’9‘前面出现非有效整数字符</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;-a1&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="可以进行有效转换，但需要提前截断："><a href="#可以进行有效转换，但需要提前截断：" class="headerlink" title="可以进行有效转换，但需要提前截断："></a>可以进行有效转换，但需要提前截断：</h4><ol><li><p>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</p><p>即在出现数字之后再出现非数字则需要提前截断。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：&quot;<span class="hljs-string">-3</span>.14&quot;<br>输出：<span class="hljs-string">-3</span><br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;3a5&quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-转换成整数"><a href="#2-转换成整数" class="headerlink" title="2. 转换成整数"></a>2. 转换成整数</h2><p>用<code>long</code>型变量保存数据，判断其是否超过<code>int</code>范围只需:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">long a<span class="hljs-comment">;</span><br>if (a<span class="hljs-operator">=</span><span class="hljs-operator">=</span>(int)a)<br>没有超出范围<br>else<br>超出范围<br></code></pre></td></tr></table></figure><h2 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">myAtoi</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span> &#123;<br>    <span class="hljs-type">char</span>* s = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-built_in">strlen</span>(str));<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!str)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//空字符情况</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; str[i] != <span class="hljs-number">0</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;+&#x27;</span> || str[i] == <span class="hljs-string">&#x27;-&#x27;</span> || (str[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>))<br>            s[j++] = str[i]; <span class="hljs-comment">//如果为有效整数字符则拷贝</span><br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> &amp;&amp; str[i] != <span class="hljs-string">&#x27; &#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//如果第一个非空格字符不是有效整数字符</span><br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<span class="hljs-comment">//有符号的情况</span><br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> &amp;&amp; !((str[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)||str[i]==<span class="hljs-string">&#x27;-&#x27;</span>||str[i]==<span class="hljs-string">&#x27;+&#x27;</span>))<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//在符号后面出现非数字的情况</span><br>            <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">2</span> &amp;&amp; !(str[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">2</span> &amp;&amp; (str[i] == <span class="hljs-string">&#x27;-&#x27;</span> || str[i] == <span class="hljs-string">&#x27;+&#x27;</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//连续出现两次符号</span><br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;-&#x27;</span> || str[i] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>                        j--;<span class="hljs-comment">//由于出现符号而截断</span><br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">//数字后出现非整数字符，提前截断 </span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">1</span> &amp;&amp; !(str[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>))&#123;<br>                <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;-&#x27;</span> || str[i] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>                        j--;<span class="hljs-comment">//由于出现符号而截断</span><br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">//数字后出现非整数字符，提前截断 </span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || (j == <span class="hljs-number">1</span> &amp;&amp; (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> || s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>)))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//空字符或者没有出现数字</span><br>    <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> || s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= j - <span class="hljs-number">1</span>; i++) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (ans &gt; (<span class="hljs-type">int</span>)ans) &#123;<br>                <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">2147483647</span>;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-2147483648</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)ans;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> -(<span class="hljs-type">int</span>)ans;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (ans &gt; (<span class="hljs-type">int</span>)ans)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2147483647</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)ans;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//思路清晰 水平辣鸡</span><br></code></pre></td></tr></table></figure><h2 id="简洁思路"><a href="#简洁思路" class="headerlink" title="简洁思路"></a>简洁思路</h2><ol><li>直接用<code>sscanf</code>格式化输入来匹配整数字符</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">myAtoi</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span>&#123;<br>    <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">sscanf</span>(str, <span class="hljs-string">&quot;%ld&quot;</span>, &amp;i); <span class="hljs-comment">// 注意：读取的是%ld，不是%1d</span><br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; (<span class="hljs-type">int</span>)i)<br>            i = <span class="hljs-number">2147483647</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; (<span class="hljs-type">int</span>)i)<br>            i = <span class="hljs-number">-2147483647</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)i;<br>&#125;<br></code></pre></td></tr></table></figure><p>老老实实来自己做sscanf可以做的事真的会把人搞晕，各种情况分类就有一点难搞清思路。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>oj</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「LeetCode」——136.只出现一次的数字</title>
    <link href="/2020/07/leetcode-136/"/>
    <url>/2020/07/leetcode-136/</url>
    
    <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [4,1,2,1,2]</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>注意这里的条件：</p><p><strong>算法应该具有线性时间复杂度：</strong>时间复杂度O(n)</p><p><strong>不使用额外空间：</strong>空间复杂度O(1)</p><p>目前我能想到的就是利用异或运算的运算性质。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">异或运算性质：<br><span class="hljs-number">1</span>、交换律<br><span class="hljs-number">2</span>、结合律<br><span class="hljs-number">3</span>、对于任何数<span class="hljs-keyword">x</span>，都有<span class="hljs-keyword">x</span>^<span class="hljs-keyword">x</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>，<span class="hljs-keyword">x</span>^<span class="hljs-number">0</span><span class="hljs-operator">=</span><span class="hljs-keyword">x</span><br><span class="hljs-number">4</span>、自反性 A XOR B XOR B <span class="hljs-operator">=</span> A <span class="hljs-keyword">xor</span> <span class="hljs-number">0</span> <span class="hljs-operator">=</span> A<br></code></pre></td></tr></table></figure><p>那么这里只需要将所有数挨个异或，相同的数异或为0，0与不重复的数异或就是答案。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span>&#123;<br>    <span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">NULL</span>||numsSize==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numsSize; i++) &#123;<br>        num^=nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>oj</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「LeetCode」——217.存在重复元素</title>
    <link href="/2020/07/leetcode-217/"/>
    <url>/2020/07/leetcode-217/</url>
    
    <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任意一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3,1]</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3,4]</span><br><span class="hljs-section">输出: false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">1,1,1,3</span>,<span class="hljs-number">3,4,3,2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>输出: true<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt;numsSize;j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] == nums[i])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这暴力一波，时间复杂度O(n^2)不出所料超时了。</p><h3 id="哈希映射"><a href="#哈希映射" class="headerlink" title="哈希映射"></a>哈希映射</h3><p>其实就是一个比较常规的哈希映射，只是看用什么方法来优化这个哈希映射。</p><p><strong>不考虑冲突（无法通过全部测试）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span>&#123;<br>    <span class="hljs-keyword">if</span> (numsSize &lt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>])<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> hashtable[<span class="hljs-number">50000</span>]=&#123;<span class="hljs-number">0</span>&#125;,hash=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++)&#123;<br>        hash=(nums[i]+<span class="hljs-number">120000006</span>)%<span class="hljs-number">49999</span>;<br>        <span class="hljs-keyword">if</span>(hashtable[hash]&gt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        hashtable[hash]+=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出来部分数据是存在冲突的，所以考虑一下处理冲突的方法。</p><p><strong>哈希链表处理冲突 224ms 10.5mb</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">HashNode</span> <span class="hljs-title">HashNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">HashNode</span> &#123;</span><br>    <span class="hljs-type">int</span> num;<br>    HashNode* next;<br>&#125;;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">hashadd</span><span class="hljs-params">(HashNode** Table, <span class="hljs-type">int</span> num)</span> &#123;<br>    HashNode* temp = (HashNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashNode));<br>    <span class="hljs-type">int</span> hash = (num + <span class="hljs-number">120000006</span>) % <span class="hljs-number">97</span>;<br>    HashNode* p = Table[hash];<br>    temp-&gt;num = num;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (; p; p = p-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (num == p-&gt;num)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Table[hash]-&gt;next)<br>        temp-&gt;next = Table[hash]-&gt;next;<br>    Table[hash]-&gt;next = temp;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (numsSize &lt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>])<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    HashNode** table = (HashNode**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashNode*) * <span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        table[i] = (HashNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashNode));<br>        table[i]-&gt;num = <span class="hljs-number">-1</span>;<br>        table[i]-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++) &#123;<br>        <span class="hljs-keyword">if</span> (hashadd(table, nums[i]))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>哈希链表操作比较繁琐，导致时间上依然显得有点慢，不妨把链表变成二维数组来试试。</p><p><strong>二维数组哈希表处理冲突</strong></p><p>先贴一下测试结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>暴力调参<br><span class="hljs-regexp">//</span>hashtable[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>] <span class="hljs-number">52</span>ms <span class="hljs-number">8.1</span>mb<br><span class="hljs-regexp">//</span>hashtable[<span class="hljs-number">1000</span>][<span class="hljs-number">50</span>] <span class="hljs-number">28</span>ms <span class="hljs-number">8.1</span>mb<br><span class="hljs-regexp">//</span>hashtable[<span class="hljs-number">10000</span>][<span class="hljs-number">3</span>] <span class="hljs-number">20</span>ms <span class="hljs-number">7.7</span>mb<br><span class="hljs-regexp">//</span>hashtable[<span class="hljs-number">5000</span>][<span class="hljs-number">3</span>]  <span class="hljs-number">16</span>ms <span class="hljs-number">8.0</span>mb<br></code></pre></td></tr></table></figure><p>可见数组的参数选择对时间的影响还是很大的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span>&#123;<br>    <span class="hljs-keyword">if</span> (numsSize &lt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>])<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> hashtable[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> hash=<span class="hljs-number">0</span>,flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; numsSize; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>)&#123;<br>            hash=(nums[i]+<span class="hljs-number">120000006</span>)%<span class="hljs-number">97</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j &lt; <span class="hljs-number">110</span>; j++)&#123;<br>                <span class="hljs-keyword">if</span>(hashtable[hash][j]==nums[i])&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hashtable[hash][j]==<span class="hljs-number">0</span>)&#123;<br>                    hashtable[hash][j]=nums[i];<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            flag=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>oj</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WordPress全站优化策略——CDN加速配置</title>
    <link href="/2020/07/wp-cdn/"/>
    <url>/2020/07/wp-cdn/</url>
    
    <content type="html"><![CDATA[<p>其实尝试过在WordPress使用CDN内容分发网络之后，会发现这并不是一件舒服的事，一会账户无法登陆了，一会文章修改了不刷新了……</p><p>造成这一系列问腿的主要还是WordPress是一个动态网站，主要靠数据库和php协调生成网页，而CDN分发网络仅仅适用于静态加速，所以WordPress在上CDN时缓存配置策略一定要好好研究。</p><h3 id="我的CDN缓存策略"><a href="#我的CDN缓存策略" class="headerlink" title="我的CDN缓存策略"></a>我的CDN缓存策略</h3><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/wp_cdn/cdn.png" style="zoom:80%;" /></div><p>看图片我们知道了如何做，下面讲下为什么这么做。</p><h4 id="需要进行缓存的静态文件："><a href="#需要进行缓存的静态文件：" class="headerlink" title="需要进行缓存的静态文件："></a>需要进行缓存的静态文件：</h4><ol><li><p>.woff2;.otf;.ot;.svg;.ttf;.woff是各类字体文件，我们将其缓存下来可以提高很多速度。</p></li><li><p>.jpg;.gif;.png;.bmp;.ico是各类图片文件。</p></li><li><p>.css;.js是网页中各种样式的文件类型，这个占比最大。</p></li><li><p>所有文件就是其他我们下面没有包括在里面的文件类型，根据自己需求设置，一般30天就行。当然也可以像我一样每天刷新。</p></li></ol><h4 id="不需要进行缓存的文件"><a href="#不需要进行缓存的文件" class="headerlink" title="不需要进行缓存的文件"></a>不需要进行缓存的文件</h4><ol><li><p>&#x2F;wp-admin是wordpress网站后台的地址，我们让其缓存设置为0天是为了防止打不开后台这种情况发生。</p></li><li><p>.gz;.xml;.php这个里面.php是我们网页的文件类型，防止更新文章后打开网站看不到新发表的文章。.xml是站点地图的文件，设置0是为了防止站点地图更新后搜索引擎抓取不到新更新的URL文件。.gz也是站点地图的文件，不同插件后缀不同，有的是xml有的是gz。</p></li></ol><h3 id="下面看下配置完CDN加速后的效果"><a href="#下面看下配置完CDN加速后的效果" class="headerlink" title="下面看下配置完CDN加速后的效果"></a>下面看下配置完CDN加速后的效果</h3><p>第一次测试，文件还没完全分发到各个CDN服务器：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/wp_cdn/test1.png" style="zoom:80%;" /></div><p>第二次测试，文件基本分发完成，速度有明显提升：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/wp_cdn/test2.png" style="zoom:80%;" /></div><p>第三次测试，可以看到加载速度基本稳定在了零点几秒，也基本能达到我们的预期效果了：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202007/wp_cdn/test3.png" style="zoom:80%;" /></div><p>为什么三次测速速度越来越快，是因为CDN的作用主要就是缓存网站的文件，这样访客访问时候就直接从CDN就给访客返回文件，不需要再走你的服务器。而且因为CDN节点多，避免了很多从你服务器到访客之间的网络线路问题。</p><p>以上仅提供一个缓存思路，如果有更好的方法欢迎一起交流。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wordpress</tag>
      
      <tag>cdn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派安装OpenCV-4.3.0+Python</title>
    <link href="/2020/06/raspi-opencv/"/>
    <url>/2020/06/raspi-opencv/</url>
    
    <content type="html"><![CDATA[<p>如果您曾经在Raspberry Pi（或之前的任何其他平台）上安装过OpenCV，那么您知道该进程可能非常耗时且需要安装许多依赖项和先决条件。本教程的目标是引导您逐步完成编译和安装过程。</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p><strong>注：Raspbian-lite所需要的额外操作将单独标注。</strong></p><ol><li><p>一台装好系统的Raspbarry Pi（建议不低于16GB micro-SD卡）</p><p>我手上的是Raspberry Pi 4b，安装的操作系统是<a href="https://github.com/openfans-community-offical/Debian-Pi-Aarch64">Debian-Pi-Aarch64</a> - 为全新Raspberry Pi 4B适配的64位操作系统。</p><p>系统镜像：2020-06-17-OPENFANS-Debian-Buster-Desktop-Aarch64-ext4-v2019-2.0-U3-Release.img</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_opencv/4.png" style="zoom:80%;" /></div><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">链接：https:<span class="hljs-regexp">//</span>pan.baidu.com<span class="hljs-regexp">/s/</span><span class="hljs-number">1</span>DfE2V_F2q5Uz0nTzy8G9Cg <br>提取码：ocrd<br></code></pre></td></tr></table></figure><p>理论上带GUI的操作系统都可以，比如Raspbian-full。 | <em><strong>揭秘了揭秘了</strong></em>  Raspbian-lite操作成功！！！ </p><p>镜像烧写看这篇教程——<a href="https://uestcpi.cn/2020/06/24/raspi_os/">树莓派系统镜像烧写</a></p><p>如果是Raspbian的话，换源教程在这里——<a href="https://uestcpi.cn/2020/06/27/linux_source/">Linux源的基础操作</a></p><p>至于这里为什么选择带GUI的桌面系统，总归还是太菜了，后面手动CMake了n次全部失败，所以不得不用到CMake-GUI来协助。</p></li><li><p>扩展SWAP分区，否则大概率会在编译过程中因为内存不足而爆掉。因为你编译到后面基本上看到的是下面的景象：</p></li></ol><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_opencv/3.png" style="zoom:80%;" /></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pi@raspbian:~$ free -h<br>              total        used        free      shared  buff/cache   available<br>Mem:          1.8Gi       1.3Gi       232Mi       112Mi       258Mi       277Mi<br>Swap:         3.0Gi       2.2Gi       843Mi<br></code></pre></td></tr></table></figure><p>SWAP扩展分区教程——<a href="https://uestcpi.cn/2020/06/27/raspi_swap/">树莓派的SWAP分区扩展</a></p><p>根据我的编译过程来看RAM+SWAP最少需要5GB，建议给足一点，防止中途爆掉。</p><ol start="3"><li><p>网络配置（可选）</p><p>建议有软路由的小伙伴先把树莓派接入软路由，因为可能会在国外服务器拉取源代码文件，网络不通畅的话会导致这一过程十分的漫长。</p></li><li><p>资源预下载</p><p>OpenCV4.3.0和opencv_contrib-4.3.0的安装包大家可从GitHub上搜索下载，如果网络有障碍，可从我的百度网盘下载（同时网盘内也上传了一些CMake易下载失败的文件）：</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">链接：https:<span class="hljs-regexp">//</span>pan.baidu.com<span class="hljs-regexp">/s/</span><span class="hljs-number">1</span>DtWG-BlsfSmTypd_2pEcSg <br>提取码：p46j <br></code></pre></td></tr></table></figure><h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><h3 id="Step1-扩展文件分区（Raspbian-lite等）"><a href="#Step1-扩展文件分区（Raspbian-lite等）" class="headerlink" title="Step1 扩展文件分区（Raspbian-lite等）"></a>Step1 扩展文件分区（Raspbian-lite等）</h3><p>如果你是新安装的Raspbian操作系统，你应该将文件系统扩展至整张micro-SD卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo raspi-config<br></code></pre></td></tr></table></figure><p>你会看到：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_opencv/5.png" style="zoom:100%;" /></div><p>选择<em><strong>“Advanced Options”</strong></em></p><p>接着：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_opencv/6.png" style="zoom:100%;" /></div><p>选择“<em><strong>A1. Expand File System</strong></em>”</p><p>完成以后重启树莓派</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo reboot<br></code></pre></td></tr></table></figure><p>重启之后使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h<br></code></pre></td></tr></table></figure><p>可以看到当前的分区情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">pi@raspbian:~$ <span class="hljs-built_in">df</span> -h<br>Filesystem      Size  Used Avail Use% Mounted on<br>udev            788M     0  788M   0% /dev<br>tmpfs           185M   20M  166M  11% /run<br>/dev/mmcblk0p2   29G   12G   16G  43% /<br>tmpfs           925M  1.4M  924M   1% /dev/shm<br>tmpfs           5.0M  4.0K  5.0M   1% /run/lock<br>tmpfs           925M     0  925M   0% /sys/fs/cgroup<br>/dev/mmcblk0p1  252M   89M  163M  36% /boot<br>tmpfs           185M   20K  185M   1% /run/user/1000<br></code></pre></td></tr></table></figure><h3 id="Step2-清理不必要文件和程序"><a href="#Step2-清理不必要文件和程序" class="headerlink" title="Step2 清理不必要文件和程序"></a>Step2 清理不必要文件和程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get purge wolfram-engine<br>sudo apt-get purge libreoffice*<br>sudo apt-get clean<br>sudo apt-get autoremove<br></code></pre></td></tr></table></figure><p>你可以获得更大的磁盘空间（毕竟安装OpenCV真的非常消耗空间，更何况还有SWAP分区）</p><h3 id="Step3-安装依赖"><a href="#Step3-安装依赖" class="headerlink" title="Step3 安装依赖"></a>Step3 安装依赖</h3><p>首先更新源和程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update &amp;&amp; sudo apt-get upgrade<br></code></pre></td></tr></table></figure><p>安装CMake相关构建工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install build-essential cmake pkg-config<br>sudo apt-get install cmake-gui <span class="hljs-comment">#（Raspbian-lite不用）</span><br></code></pre></td></tr></table></figure><p>图像I&#x2F;O</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libjpeg-dev libtiff5-dev libjasper-dev libpng12-dev<br></code></pre></td></tr></table></figure><p>视频I&#x2F;O</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev<br>sudo apt-get install libxvidcore-dev libx264-dev<br></code></pre></td></tr></table></figure><p>之后构建会用到的一个模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libgtk2.0-dev libgtk-3-dev<br></code></pre></td></tr></table></figure><p>安装Python2.7和Python3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install python2.7-dev python3-dev<br></code></pre></td></tr></table></figure><h3 id="Step4-下载-x2F-拷贝OpenCV源码"><a href="#Step4-下载-x2F-拷贝OpenCV源码" class="headerlink" title="Step4 下载&#x2F;拷贝OpenCV源码"></a>Step4 下载&#x2F;拷贝OpenCV源码</h3><h5 id="（带GUI的操作系统）"><a href="#（带GUI的操作系统）" class="headerlink" title="（带GUI的操作系统）"></a>（带GUI的操作系统）</h5><p>如果你在百度云下载了相关文件则把提前下载好的OpenCV文件拷贝到&#x2F;home&#x2F;pi文件夹里，并用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip<br></code></pre></td></tr></table></figure><p>命令解压。</p><p>如果网络条件不错当然也可以直接下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br>wget -O opencv.zip https://github.com/Itseez/opencv/archive/4.3.0.zip<br>unzip opencv.zip<br>wget -O opencv_contrib.zip https://github.com/Itseez/opencv_contrib/archive/4.3.0.zip<br>unzip opencv_contrib.zip<br></code></pre></td></tr></table></figure><p>后面的4.3.0是版本号，可以根据实际的最新版本情况修改。</p><h5 id="Raspbian-lite"><a href="#Raspbian-lite" class="headerlink" title="Raspbian-lite"></a>Raspbian-lite</h5><p>获取源码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/opencv/</span>opencv.git<br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/opencv/</span>opencv_contrib.git<br></code></pre></td></tr></table></figure><p>这里需要注意，opencv和contrib必须对应否则编译会失败，因此我此处clone了最新的</p><h3 id="Step5-配置Python"><a href="#Step5-配置Python" class="headerlink" title="Step5 配置Python"></a>Step5 配置Python</h3><p>安装Python的包管理器pip</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://bootstrap.pypa.io/get-pip.py<br>sudo python get-pip.py<br>sudo python3 get-pip.py<br></code></pre></td></tr></table></figure><p>安装NumPy库</p><p>网络条件好用这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install numpy<br></code></pre></td></tr></table></figure><p>网络条件不好用这个命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pip install numpy -i https:<span class="hljs-regexp">//</span>pypi.douban.com/simple<br></code></pre></td></tr></table></figure><p>-i后面是服务器地址，可以根据实际情况切换速度比较快的国内服务器。</p><h3 id="Step6-编译和安装OpenCV"><a href="#Step6-编译和安装OpenCV" class="headerlink" title="Step6 编译和安装OpenCV"></a>Step6 编译和安装OpenCV</h3><p><strong>构建项目</strong></p><p>先创建build文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/opencv-3.3.0/<br><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br></code></pre></td></tr></table></figure><p>然后开始构建：</p><p><em><strong>以下是错误的构建命令</strong></em></p><p><em><strong>以下是错误的构建命令</strong></em></p><p><em><strong>以下是错误的构建命令</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -D CMAKE_BUILD_TYPE=RELEASE \<br>    -D CMAKE_INSTALL_PREFIX=/usr/local \<br>    -D INSTALL_PYTHON_EXAMPLES=ON \<br>    -D OPENCV_EXTRA_MODULES_PATH=/home/pi/opencv_contrib-4.3.0/modules \<br>    -D BUILD_EXAMPLES=ON ..<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -D CMAKE_BUILD_TYPE=Release \<br>    -D CMAKE_INSTALL_PREFIX=/usr/local \<br>    -D OPENCV_EXTRA_MODULES=/home/pi/opencv_contrib-4.3.0/modules \<br>    PYTHON3_EXECUTABLE = /usr/bin/python3 \<br>    PYTHON_INCLUDE_DIR = /usr/include/python3.7 \<br>    PYTHON_INCLUDE_DIR2 = /usr/include/arm-linux-gnueabihf \<br>    -D BUILD_EXAMPLES=ON ..<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -D CMAKE_BUILD_TYPE=RELEASE \<br>    -D CMAKE_INSTALL_PREFIX=/usr/local \<br>    -D OPENCV_EXTRA_MODULES_PATH=/home/pi/opencv_contrib-4.3.0/modules \<br>    -D ENABLE_NEON=ON \<br>    -D ENABLE_VFPV3=ON \<br>    -D WITH_GTK=ON \<br>    -D BUILD_TESTS=OFF \<br>    -D INSTALL_C_EXAMPLES=OFF \<br>    -D INSTALL_PYTHON_EXAMPLES=OFF \<br>    -D BUILD_EXAMPLES=OFF ..<br></code></pre></td></tr></table></figure><p>以上命令要么构建失败，要么编译到一半报错，具体原因由于水平有限我也不清楚。</p><h5 id="（带GUI的操作系统）-1"><a href="#（带GUI的操作系统）-1" class="headerlink" title="（带GUI的操作系统）"></a>（带GUI的操作系统）</h5><p>无奈之下只好选择CMake-GUI来完成构建：</p><p>用<strong>VNC</strong>连接树莓派，在远程桌面的终端中输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cmake-gui</span><br></code></pre></td></tr></table></figure><p>启动cmake-gui如下：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_opencv/2.png" style="zoom:100%;" /></div><p>在Where is the source code:选择opencv-4.3.0目录位置(我的位置为&#x2F;home&#x2F;pi&#x2F;opencv-4.3.0)，在Where to build the binaries:选择build位置(我的位置为&#x2F;home&#x2F;pi&#x2F;opencv-4.3.0&#x2F;build)。<br><strong>选择完毕点击Configure，配置完毕会出现很多 <em>红色</em> 项目</strong></p><ul><li>找到BUILD_opencv_world，后面的方框点上勾；</li><li>找到在CMAKE_BUILD_TYPE 值处输入RELEASE，其他保持不变；</li><li>找到OPENCV_ENABLE_NONFREE，在后面的方框点上勾（有的算法有专利，不点这个不能用，比如sift）</li><li>找到OPENCV_EXTRA_MODULES_PATH，选择opencv_contrib文件夹中的modules文件夹，注意是modules文件夹(我的路径是&#x2F;home&#x2F;pi&#x2F;opencv_contrib&#x2F;modules)。</li></ul><p>完成以上工作再点击Configure，耐心等一等，如果上面还有红色的再点击Configure，直到没有红色为止。</p><p>Configure完成之后点击Generate，等一等即可。</p><p>正常情况下，等Generate完成之后，我们可以直接在build目录下输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j4<br></code></pre></td></tr></table></figure><p><em><strong>-j4</strong></em>命令是多核编译参数，这里的4就是4核的意思，CPU4核拉满能够提高一些效率。</p><h5 id="（Raspbian-lite手动构建）"><a href="#（Raspbian-lite手动构建）" class="headerlink" title="（Raspbian-lite手动构建）"></a>（Raspbian-lite手动构建）</h5><p>之前的cmake代码不成功大概是以下原因：</p><p>Python的libraries，numpy，packages Path都没有，说明Python环境不正常，不会生成Python的opencv库，到时候会报ImportError: No module named cv2的错误。</p><ol><li>指定参数的时候有些没加-D。 </li><li>没有启用BUILD_opencv_python3。 </li><li>部分变量名错了</li></ol><p>打开opencv的CMAKELists.txt,发现许多变量名是错的，下面是opencv的CMAKELists.txt部分代码。</p><p>环境Python3.7 &amp; Python2.7</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake">cmake -D BUILD_opencv_python3=YES \<br>-D CMAKE_BUILD_TYPE=Release \<br>-D CMAKE_INSTALL_PREFIX=/usr/local \<br>-D OPENCV_EXTRA_MODULES=../../opencv_contrib/modules \<br>-D PYTHON3_LIBRARIES=/usr/lib/arm-linux-gnueabihf/libpython3.<span class="hljs-number">7</span>m.so \<br>-D PYTHON3_NUMPY_INCLUDE_DIRS=/usr/lib/python3/dist-packages/numpy/core/<span class="hljs-keyword">include</span>/numpy/ ..<br></code></pre></td></tr></table></figure><p>构建成功如图：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_opencv/cmake.png" style="zoom:100%;" /></div><p>接着我们可以在build目录下输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j4<br></code></pre></td></tr></table></figure><p><em><strong>-j4</strong></em>命令是多核编译参数，这里的4就是4核的意思，CPU4核拉满能够提高一些效率。</p><p>随即开始编译。</p><p><strong>请做好准备，这是一个，非常，非常，非常漫长的过程！！！！！！！！</strong></p><p><strong>请做好准备，这是一个，非常，非常，非常漫长的过程！！！！！！！！</strong></p><p><strong>请做好准备，这是一个，非常，非常，非常漫长的过程！！！！！！！！</strong></p><p>有Building CXX object modules&#x2F;python2&#x2F;CMakeFiles&#x2F;opencv_python2.dir&#x2F;_&#x2F;src2&#x2F;cv2.cpp.o</p><p>和Building CXX object modules&#x2F;python3&#x2F;CMakeFiles&#x2F;opencv_python3.dir&#x2F;_&#x2F;src2&#x2F;cv2.cpp.o两部分编译得有20分钟，一度以为又死机了，实际上不是，耐心等待，树莓派编译特别慢。</p><p><strong>在这个过程当中你可能会遇到不少问题，<em>常见问题写在了末尾。</em></strong></p><p>编译不出错完成之后，在build目录下输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo make install<br></code></pre></td></tr></table></figure><h3 id="Step7-配置环境"><a href="#Step7-配置环境" class="headerlink" title="Step7 配置环境"></a>Step7 配置环境</h3><p>安装完需要配置环境，树莓派可以使用vim，nano等命令进行编辑，也可以安装gedit进行编辑，本菜鸟能力不强，还是喜欢用gedit，就安装了个gedit。输入命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/ld.so.conf.d/opencv.conf<br></code></pre></td></tr></table></figure><p>打开文件之后是空的，输入以下内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local/lib<br></code></pre></td></tr></table></figure><p>保存后退出，再输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ldconfig<br></code></pre></td></tr></table></figure><p>更改环境变量，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/bash.bashrc<br></code></pre></td></tr></table></figure><p>打开之后，在文件最后面输入以下内容：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-title class_">PKG_CONFIG_PATH</span>=<span class="hljs-variable">$PKG_CONFIG_PATH</span><span class="hljs-symbol">:/usr/local/lib/pkgconfig</span> <br>export <span class="hljs-title class_">PKG_CONFIG_PATH</span><br></code></pre></td></tr></table></figure><p>保存退出，opencv基本上就安装完成了。</p><h3 id="Step8-检测安装是否成功"><a href="#Step8-检测安装是否成功" class="headerlink" title="Step8 检测安装是否成功"></a>Step8 检测安装是否成功</h3><h4 id="Python2-7检查"><a href="#Python2-7检查" class="headerlink" title="Python2.7检查"></a>Python2.7检查</h4><p>终端按照如下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">pi@raspbian:~/opencv-4.3.0/build$ python<br>Python 2.7.16 (default, Oct 10 2019, 22:02:15) <br>[GCC 8.3.0] on linux2<br>Type <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;copyright&quot;</span>, <span class="hljs-string">&quot;credits&quot;</span> or <span class="hljs-string">&quot;license&quot;</span> <span class="hljs-keyword">for</span> more information.<br>&gt;&gt;&gt; import cv2<br>&gt;&gt;&gt; cv2.__version__<br><span class="hljs-string">&#x27;4.3.0&#x27;</span><br></code></pre></td></tr></table></figure><p>如果看到了版本号则表示成功。</p><h4 id="Python3-7检查"><a href="#Python3-7检查" class="headerlink" title="Python3.7检查"></a>Python3.7检查</h4><p>终端按照如下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">pi@raspbian:~/opencv-4.3.0/build$ python3<br>Python 3.7.3 (default, Dec 20 2019, 18:57:59) <br>[GCC 8.3.0] on linux<br>Type <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;copyright&quot;</span>, <span class="hljs-string">&quot;credits&quot;</span> or <span class="hljs-string">&quot;license&quot;</span> <span class="hljs-keyword">for</span> more information.<br>&gt;&gt;&gt; import cv2<br>&gt;&gt;&gt; cv2.__version__<br><span class="hljs-string">&#x27;4.3.0&#x27;</span><br></code></pre></td></tr></table></figure><p>如果看到了版本号则表示成功。</p><p><strong>到此为止安装基本成功</strong></p><h2 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h2><ol><li><p>删除安装文件，清理空间。</p></li><li><p><strong>别忘记把SWAP分区改回来！！！</strong></p><p>如果你跳过这一步的话，你的SD卡大概率过不了多久就会被写废！！！</p><p>调整dphys-swapfile：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/dphys-swapfile<br></code></pre></td></tr></table></figure><p>修改文件中以下项目为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># set size to absolute value, leaving empty (default) then uses computed value</span><br><span class="hljs-comment"># you most likely don&#x27;t want this, unless you have an special disk situation</span><br><span class="hljs-attr">CONF_SWAPSIZE</span>=<span class="hljs-number">100</span><br><span class="hljs-comment"># CONF_SWAPSIZE=4096</span><br><span class="hljs-comment"># CONF_MAXSWAP=4096</span><br></code></pre></td></tr></table></figure></li></ol><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">   <br>重启服务：<br>   <br>   ```bash<br>   sudo /etc/init.d/dphys-swapfile restart<br></code></pre></td></tr></table></figure><p>   你的SWAP分区将从4096MB变回100MB</p><h2 id="opencv-config安装问题"><a href="#opencv-config安装问题" class="headerlink" title="opencv_config安装问题"></a>opencv_config安装问题</h2><h3 id="报错1：没有那个文件或目录"><a href="#报错1：没有那个文件或目录" class="headerlink" title="报错1：没有那个文件或目录"></a>报错1：没有那个文件或目录</h3><p><strong>编译OpenCV提示opencv_contrib缺少boostdesc_bgm.i等文件</strong></p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_opencv/1.png" style="zoom:80%;" /></div><p>解决方法：</p><p>查看 build 文件夹下的日志文件 CMakeDownloadLog.txt，在日志文件CMakeDownloadLog.txt中搜索 boostdesc_bgm.i 关键词。日志文件里就有它的下载地址，到指定位置下载即可。<a href="https://github.com/opencv/opencv_contrib/issues/1301%EF%BC%8C%E7%82%B9%E5%BC%80%E4%B8%8A%E9%9D%A2%E8%BF%99%E4%B8%AA%E7%BD%91%E5%9D%80%E5%BE%80%E4%B8%8B%E6%8B%89%EF%BC%8C%E6%9C%89%E4%BA%BA%E6%8F%90%E4%BE%9B%E4%BA%86%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%90%84%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E9%93%BE%E6%8E%A5%EF%BC%8C%E7%82%B9%E5%87%BB%E4%BF%9D%E5%AD%98">https://github.com/opencv/opencv_contrib/issues/1301，点开上面这个网址往下拉，有人提供了缺失的各个文件的链接，点击保存</a>. 或者直接在这个网页里搜索 BenbenIO 这个用户的回答。<br>下载后，直接拷贝源码并生成同名文件，放在 <strong>opencv_contrib&#x2F;modules&#x2F;xfeatures2d&#x2F;src&#x2F;</strong> 路径下即可。</p><h3 id="报错2：编译时头文件不对"><a href="#报错2：编译时头文件不对" class="headerlink" title="报错2：编译时头文件不对"></a><strong>报错2：</strong>编译时头文件不对</h3><p><strong>fatal error: features2d&#x2F;test&#x2F;test_detectors_regression.impl.hpp: 没有那个文件或目录</strong></p><p><strong>#include “features2d&#x2F;test&#x2F;test_detectors_regression.impl.hpp”</strong></p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_opencv/7.png" style="zoom:80%;" /></div><p><strong>头文件include地址不对，解决方法如下：</strong></p><p>将opencv-4.1.0&#x2F;modules&#x2F;<strong>features2d</strong>&#x2F;test&#x2F;文件下的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">test_descriptors_invariance<span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.hpp</span><br>test_descriptors_regression<span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.hpp</span><br>test_detectors_invariance<span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.hpp</span><br>test_detectors_regression<span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.hpp</span><br>test_invariance_utils.hpp<br></code></pre></td></tr></table></figure><p>拷贝到opencv_contrib-4.1.0&#x2F;modules&#x2F;<strong>xfeatures2d</strong>&#x2F;test&#x2F;文件下。</p><p>同时，将opencv_contrib-4.1.0&#x2F;modules&#x2F;<strong>xfeatures2d</strong>&#x2F;test&#x2F;test_features2d.cpp文件下的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;features2d/test/test_detectors_regression.impl.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;features2d/test/test_descriptors_regression.impl.hpp&quot;</span></span><br></code></pre></td></tr></table></figure><p>改成：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_detectors_regression.impl.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_descriptors_regression.impl.hpp&quot;</span></span><br></code></pre></td></tr></table></figure><p>将opencv_contrib-4.1.0&#x2F;modules&#x2F;<strong>xfeatures2d</strong>&#x2F;test&#x2F;test_rotation_and_scale_invariance.cpp文件下的</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-meta">#include &quot;<span class="hljs-string">features</span>2d/<span class="hljs-string">test</span>/<span class="hljs-string">test_detectors_invariance.impl.hpp</span>&quot; </span><br><span class="hljs-meta">#include &quot;<span class="hljs-string">features</span>2d/<span class="hljs-string">test</span>/<span class="hljs-string">test_descriptors_invariance.impl.hpp</span>&quot;</span><br></code></pre></td></tr></table></figure><p>改成：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_detectors_invariance.impl.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_descriptors_invariance.impl.hpp&quot;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry-pi</tag>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派的KDE桌面安装</title>
    <link href="/2020/06/raspi-kde/"/>
    <url>/2020/06/raspi-kde/</url>
    
    <content type="html"><![CDATA[<p>觉得Raspbian的桌面太丑了，换一个KDE Plasma上去，赏心悦目。</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_kde/ked.webp" style="zoom:80%;" /></div><h2 id="方案一：Ubuntu测试成功"><a href="#方案一：Ubuntu测试成功" class="headerlink" title="方案一：Ubuntu测试成功"></a>方案一：Ubuntu测试成功</h2><h3 id="可选-添加PPA源"><a href="#可选-添加PPA源" class="headerlink" title="(可选)添加PPA源"></a>(可选)添加PPA源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo add-apt-repository ppa:kubuntu-ppa/backports<br></code></pre></td></tr></table></figure><h3 id="更新源并更新程序"><a href="#更新源并更新程序" class="headerlink" title="更新源并更新程序"></a>更新源并更新程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update &amp;&amp; sudo apt-get upgrade -y<br></code></pre></td></tr></table></figure><h3 id="修改lightdm配置"><a href="#修改lightdm配置" class="headerlink" title="修改lightdm配置"></a>修改lightdm配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/lightdm/lightdm.conf<br></code></pre></td></tr></table></figure><p>内容修改为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Seat:*]</span><br><span class="hljs-attr">autologin-guest</span>=<span class="hljs-literal">false</span><br><span class="hljs-comment">#autologin-user=pi</span><br><span class="hljs-comment">#autologin-user-timeout=0</span><br><span class="hljs-attr">greeter-session</span>=lightdm-kde-greeter<br><span class="hljs-attr">user-session</span>=kde-plasma-kf5<br></code></pre></td></tr></table></figure><h3 id="重启即为Plasma桌面"><a href="#重启即为Plasma桌面" class="headerlink" title="重启即为Plasma桌面"></a>重启即为Plasma桌面</h3><h2 id="方案二：Debian-10-桌面版-测试成功"><a href="#方案二：Debian-10-桌面版-测试成功" class="headerlink" title="方案二：Debian 10(桌面版)测试成功"></a>方案二：Debian 10(桌面版)测试成功</h2><p>从Debian 10（Buster）安装KDE桌面，安装期间添加了官方上游存储库，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt -y install task-kde-desktop<br></code></pre></td></tr></table></figure><p>安装完成，注销或重启后开始使用Debian 10 Buster上的KDE桌面环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">logout</span> 或者 reboot<br></code></pre></td></tr></table></figure><p>使用登录屏幕上的桌面环境切换器选择KDE Plasma：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_kde/kde1.png" style="zoom:80%;" /></div>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry-pi</tag>
      
      <tag>desktop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派的SWAP分区扩展</title>
    <link href="/2020/06/raspi-swap/"/>
    <url>/2020/06/raspi-swap/</url>
    
    <content type="html"><![CDATA[<h2 id="SWAP分区简介"><a href="#SWAP分区简介" class="headerlink" title="SWAP分区简介"></a>SWAP分区简介</h2><p>Swap分区是磁盘上的一个特殊用途的分区。是当系统的物理内存不够用的时候，把物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。<br>分配太多的Swap空间，会浪费磁盘空间，而Swap空间太少，则系统会发生错误。一般在内存小于2G的情况下，交换分区应为内存的2倍。对于树莓派来说，可以设置为2GB。当然也需要考虑 microSD 卡容量和使用情况。</p><h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><h3 id="1-程序安装"><a href="#1-程序安装" class="headerlink" title="1.程序安装"></a>1.程序安装</h3><p>如果系统默认没有SWAP，则需要手动建立，不过推荐这个自动设置SWAP的软件——dphys-swapfile。</p><p>安装 dphys-swapfile：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install dphys-swapfile<br></code></pre></td></tr></table></figure><p><em>此软件会默认设置RAM两倍大小的SWAP分区</em>。</p><h3 id="2-程序配置"><a href="#2-程序配置" class="headerlink" title="2.程序配置"></a>2.程序配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/dphys-swapfile<br></code></pre></td></tr></table></figure><p>将 CONF_SWAPSIZE 的值修改成你想要的大小。 一般在内存小于2G的情况下，交换分区应为内存的2倍!</p><h3 id="3-重启服务"><a href="#3-重启服务" class="headerlink" title="3.重启服务"></a>3.重启服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /etc/init.d/dphys-swapfile restart<br></code></pre></td></tr></table></figure><h3 id="4-查看分区大小"><a href="#4-查看分区大小" class="headerlink" title="4.查看分区大小"></a>4.查看分区大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">free -h<br></code></pre></td></tr></table></figure><p>你会看到以下内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pi</span>@raspbian:~$ free -h<br>              <span class="hljs-attribute">total</span>        used        free      shared  buff/cache   available<br><span class="hljs-attribute">Mem</span>:          <span class="hljs-number">1</span>.<span class="hljs-number">9</span>Gi       <span class="hljs-number">929</span>Mi       <span class="hljs-number">681</span>Mi       <span class="hljs-number">0</span>.<span class="hljs-number">0</span>Ki       <span class="hljs-number">288</span>Mi       <span class="hljs-number">877</span>Mi<br><span class="hljs-attribute">Swap</span>:         <span class="hljs-number">3</span>.<span class="hljs-number">0</span>Gi       <span class="hljs-number">137</span>Mi       <span class="hljs-number">2</span>.<span class="hljs-number">9</span>Gi<br></code></pre></td></tr></table></figure><p>SWAP即为你设置的SWAP分区信息。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry-pi</tag>
      
      <tag>swap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Icoding题解」平衡二叉树(AVL)的插入算法</title>
    <link href="/2020/06/icoding-avl/"/>
    <url>/2020/06/icoding-avl/</url>
    
    <content type="html"><![CDATA[<h2 id="AVL添加"><a href="#AVL添加" class="headerlink" title="AVL添加"></a>AVL添加</h2><p><a href="https://icoding.run/ide#/question/132">题目链接</a></p><p>平衡二叉树，是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1。它是一种高度平衡的二叉排序树。现二叉平衡树结点定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">left</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">right</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">parent</span>;</span><br>    <span class="hljs-type">int</span> height;<br>&#125; <span class="hljs-type">node_t</span>;<br></code></pre></td></tr></table></figure><p>请实现平衡二叉树的插入算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//向根为 root 的平衡二叉树插入新元素 val，成功后返回新平衡二叉树根结点</span><br><span class="hljs-type">node_t</span> *<span class="hljs-title function_">avl_insert</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *root, <span class="hljs-type">int</span> val)</span>;<br></code></pre></td></tr></table></figure><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="AVL定义"><a href="#AVL定义" class="headerlink" title="AVL定义"></a>AVL定义</h3><p><strong>平衡二叉搜索树</strong>:简称平衡二叉树。由前苏联的数学家Adelse-Velskil和Landis在1962年提出的高度平衡的二叉树，根据科学家的英文名也称为AVL树。它具有如下几个性质：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。</li></ol><p>平衡之意，如天平，即两边的分量大约相同。如定义，假如一棵树的左右子树的高度之差超过1，如左子树的树高为2，右子树的树高为0，子树树高差的绝对值为2就打破了这个平衡。如依次插入1，2，3三个结点（如下图）后，根结点的右子树树高减去左子树树高为2，树就失去了平衡。</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/icoding_avladd/avl1.png" style="zoom:80%;" /></div><p>那么在建立树的过程中，我们如何知道左右子树的高度差呢？在这里我们采用了平衡因子进行记录。</p><p><strong>平衡因子</strong>：左子树的高度减去右子树的高度。由平衡二叉树的定义可知，平衡因子的取值只可能为0,1,-1.分别对应着左右子树等高，左子树比较高，右子树比较高。</p><h3 id="AVL树的插入时的失衡与调整"><a href="#AVL树的插入时的失衡与调整" class="headerlink" title="AVL树的插入时的失衡与调整"></a>AVL树的插入时的失衡与调整</h3><h4 id="不平衡的4种情况"><a href="#不平衡的4种情况" class="headerlink" title="不平衡的4种情况"></a>不平衡的4种情况</h4><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/icoding_avladd/avl2.png" style="zoom:100%;" /></div><ol><li>6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。</li><li>6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。</li><li>2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。</li><li>2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。</li></ol><h4 id="LL型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h4><p>在LL型的不平衡树中，我们首先找到最小不平衡子树，再以其根结点向右旋转。为何是向右旋转呢？应该不难理解，向右旋转后，相当于右边的子树树高增加了1，而左边的子树树高降低了1，而原本的树高之差为2,那么就能够将根的平衡因子就化为0.引用一下之前的图如下。旋转之后为“原来根结点的左孩子作为新的根结点”。</p><p>我们对树以根结点为中心，向右旋转。旋转步骤如下:</p><ol><li>将2作为根结点。</li><li>将3作为2的右孩子。</li><li>将2的右孩子作为3的左孩子（维护树的有序性，只是此处为NULL而已）。</li></ol><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/icoding_avladd/avl3.png" style="zoom:50%;" /></div><p>旋转后，3与2的平衡因子为0，1的平衡因子保持不变。</p><h4 id="RR型"><a href="#RR型" class="headerlink" title="RR型"></a>RR型</h4><p>还是引用一下之前的例子。旋转之后为“原来根结点的右孩子作为新的根结点”。旋转的步骤如下：</p><ol><li>将2作为根结点。</li><li>将1作为2的左孩子。</li><li>将2的左孩子作为1的右孩子（维护树的有序性，只是此处为NULL而已）。</li></ol><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/icoding_avladd/avl4.jpg" style="zoom:50%;" /></div><p>最后1,2,3的平衡因子都为0。</p><h4 id="LR型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h4><p>对于LR，要分为两步进行旋。旋转之后为“原来根结点的左孩子的右孩子作为新的根结点”。</p><p>第一以较高子树的根，即1，为中心向左旋转。具体步骤如下：</p><ol><li>将2的左子树作为1的右子树（维护树的有序性，只是此处为NULL而已）。</li><li>将1作为2的左子树。</li><li>将2作为3的左子树。</li></ol><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/icoding_avladd/avl5.jpg" style="zoom:50%;" /></div><p>第二以原树的根，即3为中心，向右旋转。最后结果如下：</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/icoding_avladd/avl6.jpg" style="zoom:50%;" /></div><p>旋转后，1,2,3的平衡因子变为0。</p><h4 id="RL型"><a href="#RL型" class="headerlink" title="RL型"></a>RL型</h4><p>还是引用一下之前的例子。与LR型类似，我们需要进行两次旋转。旋转之后为“原来根结点的右孩子的左孩子作为新的根结点”。</p><p>第一，以根结点的右孩子即3为中心向右旋转，结果如下。具体步骤如下：</p><ol><li>将2作为1的右孩子。</li><li>将3作为2的右孩子。</li><li>将2的右孩子作为3的左孩子（维护树的有序性，只是此处为NULL而已）。</li></ol><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/icoding_avladd/avl7.jpg" style="zoom:50%;" /></div><p>第二，以原根结点即1，作为中心，向左旋转。结果如下。具体步骤如下：</p><ol><li><p>将2作为根结点。</p></li><li><p>将1作为2的左孩子。</p></li><li><p>将2的左孩子作为1的右孩子（维护树的有序性，只是此处为NULL而已）。</p></li></ol><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/icoding_avladd/avl6.jpg" style="zoom:50%;" /></div><p>最后1,2,3的平衡因子都是0。</p><h2 id="答案代码及注释"><a href="#答案代码及注释" class="headerlink" title="答案代码及注释"></a>答案代码及注释</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;avl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* root)</span><br>&#123;<br>    <span class="hljs-type">int</span> height = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (root)<br>        height = root-&gt;height;<br>    <span class="hljs-keyword">return</span> height;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><span class="hljs-comment">//LL型</span><br><span class="hljs-type">node_t</span>* <span class="hljs-title function_">LL</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* root)</span><br>&#123;<br>    <span class="hljs-type">node_t</span>* child = root-&gt;left;<br>    root-&gt;left = child-&gt;right;<br>    child-&gt;right = root;<br>    root-&gt;height = getMax(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    child-&gt;height = getMax(getHeight(child-&gt;left), root-&gt;height) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> child;<br>&#125;<br><span class="hljs-comment">//RR型</span><br><span class="hljs-type">node_t</span>* <span class="hljs-title function_">RR</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* root)</span><br>&#123;<br>    <span class="hljs-type">node_t</span>* child = root-&gt;right;<br>    root-&gt;right = child-&gt;left;<br>    child-&gt;left = root;<br>    root-&gt;height = getMax(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    child-&gt;height = getMax(root-&gt;height, getHeight(child-&gt;right)) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> child;<br>&#125;<br><span class="hljs-comment">//RL型</span><br><span class="hljs-type">node_t</span>* <span class="hljs-title function_">RL</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* root)</span><br>&#123;<br>    <span class="hljs-comment">//右左调整分两步,先LL再RR</span><br>    root-&gt;right = LL(root-&gt;right);<br>    <span class="hljs-keyword">return</span> RR(root);<br>&#125;<br><span class="hljs-comment">//LR型</span><br><span class="hljs-type">node_t</span>* <span class="hljs-title function_">LR</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* root)</span><br>&#123;<br>    <span class="hljs-comment">//左右调整分两步,先RR再LL</span><br>    root-&gt;left = RR(root-&gt;left);<br>    <span class="hljs-keyword">return</span> LL(root);<br>&#125;<br><span class="hljs-type">node_t</span>* <span class="hljs-title function_">NewNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>&#123;<br>    <span class="hljs-type">node_t</span>* newnode = (<span class="hljs-type">node_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<br>    newnode-&gt;val = val;<br>    newnode-&gt;left = <span class="hljs-literal">NULL</span>;<br>    newnode-&gt;right = <span class="hljs-literal">NULL</span>;<br>    newnode-&gt;parent = <span class="hljs-literal">NULL</span>;<br>    newnode-&gt;height = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> newnode;<br>&#125;<br><span class="hljs-type">node_t</span>* <span class="hljs-title function_">avl_insert</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* root, <span class="hljs-type">int</span> val)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!root)<span class="hljs-comment">//如果avl不存在则先创建一个avl</span><br>        root = NewNode(val);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) &#123;<br>        <span class="hljs-comment">//如果val小于根结点val,则插入左子树</span><br>        root-&gt;left = avl_insert(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (getHeight(root-&gt;left) - getHeight(root-&gt;right) == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-comment">//插入后判断平衡因子,如果等于2则需要旋转</span><br>            <span class="hljs-keyword">if</span> (val &lt; root-&gt;left-&gt;val)<span class="hljs-comment">//LL型</span><br>                root = LL(root);<br>            <span class="hljs-keyword">else</span><span class="hljs-comment">//LR型</span><br>                root = LR(root);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; root-&gt;val) &#123;<br>        <span class="hljs-comment">//如果val大于根结点val,则插入右子树</span><br>        root-&gt;right = avl_insert(root-&gt;right, val);<br>        <span class="hljs-keyword">if</span> (getHeight(root-&gt;right) - getHeight(root-&gt;left) == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-comment">//插入后判断平衡因子,如果等于2则需要旋转</span><br>            <span class="hljs-keyword">if</span> (val &gt; root-&gt;right-&gt;val)<span class="hljs-comment">//RR型</span><br>                root = RR(root);<br>            <span class="hljs-keyword">else</span><span class="hljs-comment">//RL型</span><br>                root = RL(root);<br>        &#125;<br>    &#125;<br>    root-&gt;height = getMax(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>oj</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派系统镜像烧写</title>
    <link href="/2020/06/raspi-flash-os/"/>
    <url>/2020/06/raspi-flash-os/</url>
    
    <content type="html"><![CDATA[<div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_os/raspi1.jpeg" style="zoom: 120%;" /></div><h2 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h2><p>可以适用于树莓派的系统镜像资源十分丰富，根据个人的需求有不同的系统镜像选择，正如我们之前提到的<em>树莓派资源大全</em>里面丰富的镜像资源一样！所以先选一个你喜欢的镜像吧！<a href="https://jason-xy.cn/2020/06/21/raspi_source/">Let’s Go!</a></p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_os/raspi_debian.jpg" style="zoom: 25%;" /></div>## 烧录工具<p>之前看到不少教程都推荐<a href="https://sourceforge.net/projects/win32diskimager/">Win32 Disk Imager</a>但是限于平台限制和“极具年代感”的UI设计，我们今天推荐另一款<strong>开源、全平台</strong>烧录工具——**<a href="https://github.com/balena-io/etcher">BalenaEtcher</a>**</p><div align=center><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_os/etcher.png" style="zoom: 50%;" /></div>有条件的小伙伴可以到[官网](https://www.balena.io/etcher/)下载。<p>没条件的话可以在本页面下载（博主要按流量付费的😭）：<a href="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_os/balenaEtcher-Portable-1.5.100.exe">Windows</a>、<a href="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_os/balena-etcher-electron-1.5.100-linux-ia32.zip">Linux</a>、<a href="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_os/balenaEtcher-1.5.100.dmg">macOS</a></p><h2 id="烧录流程"><a href="#烧录流程" class="headerlink" title="烧录流程"></a>烧录流程</h2><ol><li><p>TF卡插读卡器接上电脑</p></li><li><p><strong>管理员身份</strong>运行Etcher</p></li><li><p>选择镜像（img格式文件）&#x3D;&gt;选择烧写磁盘(会格式化掉所有内容)&#x3D;&gt;Flash!</p></li></ol><h2 id="后续技巧"><a href="#后续技巧" class="headerlink" title="后续技巧"></a>后续技巧</h2><ol><li><p>如果采用的的是Raspbain,在boot分区下事先添加ssh和wpa_supplicant.conf ,可以在开机之前连接WiFi并开启ssh。</p></li><li><p>wpa_supplicant.conf 配置详情</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">country</span><span class="hljs-operator">=</span>CN<br>ctrl_interface<span class="hljs-operator">=</span>DIR<span class="hljs-operator">=/</span>var/run/wpa_supplicant GROUP<span class="hljs-operator">=</span>netdev<br>update_config<span class="hljs-operator">=</span><span class="hljs-number">1</span><br> <br><span class="hljs-attribute">network</span><span class="hljs-operator">=</span>&#123;<br><span class="hljs-attribute">ssid</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;WiFi-A&quot;</span><br><span class="hljs-attribute">psk</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;12345678&quot;</span><br>key_mgmt<span class="hljs-operator">=</span>WPA-PSK<br><span class="hljs-attribute">priority</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br>&#125;<br> <br><span class="hljs-attribute">network</span><span class="hljs-operator">=</span>&#123;<br><span class="hljs-attribute">ssid</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;WiFi-B&quot;</span><br><span class="hljs-attribute">psk</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;12345678&quot;</span><br>key_mgmt<span class="hljs-operator">=</span>WPA-PSK<br><span class="hljs-attribute">priority</span><span class="hljs-operator">=</span><span class="hljs-number">2</span><br>scan_ssid<span class="hljs-operator">=</span><span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>说明以及不同安全性的 WiFi 配置示例：<br><strong>#ssid:网络的ssid</strong><br><strong>#psk:密码</strong><br><strong>#priority:连接优先级，数字越大优先级越高（不可以是负数）</strong><br><strong>#scan_ssid:连接隐藏WiFi时需要指定该值为1</strong></p><p>如果你的 WiFi 没有密码</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">network</span><span class="hljs-operator">=</span>&#123;<br><span class="hljs-attribute">ssid</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;你的无线网络名称（ssid）&quot;</span><br>key_mgmt<span class="hljs-operator">=</span>NONE<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你的 WiFi 使用WEP加密</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">network</span><span class="hljs-operator">=</span>&#123;<br><span class="hljs-attribute">ssid</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;你的无线网络名称（ssid）&quot;</span><br>key_mgmt<span class="hljs-operator">=</span>NONE<br>wep_key0<span class="hljs-operator">=</span><span class="hljs-string">&quot;你的wifi密码&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果你的 WiFi 使用WPA&#x2F;WPA2加密</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">network</span><span class="hljs-operator">=</span>&#123;<br><span class="hljs-attribute">ssid</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;你的无线网络名称（ssid）&quot;</span><br>key_mgmt<span class="hljs-operator">=</span>WPA-PSK<br><span class="hljs-attribute">psk</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;你的wifi密码&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ssh配置详情</p><p>如果通过 ssh 连接树莓派出现 Access denied 这个提示则说明 ssh 服务没有开启。要手动开启的话，和 WiFi 配置相似，同样在 boot 分区新建一个文件，空白的即可，文件命名为 ssh。注意要小写且不要有任何扩展名。<br>树莓派在启动之后会在检测到这个文件之后自动启用 ssh 服务。随后即可通过登录路由器找到树莓派的 IP 地址，通过 ssh 连接到树莓派了。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>raspberry-pi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Icoding题解」哈希表添加</title>
    <link href="/2020/06/icoding-hash-add-int/"/>
    <url>/2020/06/icoding-hash-add-int/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表添加"><a href="#哈希表添加" class="headerlink" title="哈希表添加"></a>哈希表添加</h1><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/wp-content/uploads/2020/06/icoding.png"></p><p><a href="https://icoding.run/ide#/question/131">题目地址</a></p><p>哈希表（Hash Table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。哈希表相关定义如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;<br>    HASH_OK,<br>    HASH_ERROR,<br>    HASH_ADDED,<br>    HASH_REPLACED_VALUE,<br>    HASH_ALREADY_ADDED,<br>    HASH_DELETED,<br>    HASH_NOT_FOUND,<br>&#125; HASH_RESULT;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashEntry</span> HashEntry;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashEntry</span>&#123;<br>    <span class="hljs-keyword">union</span>&#123;<br>        <span class="hljs-type">char</span>  *str_value;<br>        <span class="hljs-type">double</span> dbl_value;<br>        <span class="hljs-type">int</span>       int_value;<br>    &#125; key;<br>    <span class="hljs-keyword">union</span>&#123;<br>        <span class="hljs-type">char</span>  *str_value;<br>        <span class="hljs-type">double</span> dbl_value;<br>        <span class="hljs-type">int</span>       int_value;<br>        <span class="hljs-type">long</span>   long_value;<br>        <span class="hljs-type">void</span>  *ptr_value;<br>    &#125; value;<br>    HashEntry *next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashTable</span>&#123;<br>    HashEntry **bucket;        <br>    <span class="hljs-type">int</span> size;<br>    HASH_RESULT last_error;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashTable</span> HashTable;<br><br><span class="hljs-comment">// 向哈希表中添加元素，其中键类型为char*， 元素类型为int。</span><br><span class="hljs-function">HASH_RESULT <span class="hljs-title">hash_add_int</span><span class="hljs-params">(HashTable * table, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * key, <span class="hljs-type">int</span> value)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="哈希表相关说明："><a href="#哈希表相关说明：" class="headerlink" title="哈希表相关说明："></a>哈希表相关说明：</h2><ol><li>HASH_RESULT 类型为相关函数的返回类型</li><li>HashEntry 为哈希表所保存元素（即键值对 《key, value》）类型</li><li>HashTable 为哈希表，其中 bucket 指向大小为size的、元素类型为 HashEntry*的指针数组</li><li>哈希表采用链地址法处理冲突</li></ol><p>请实现 hash_add_int 函数，向哈希表中添加元素，其中键类型为char*， 元素类型为int。在添加过程中，如果要添加的键值key已在哈希表中，且对应的值value也已存在，则函数返回 HASH_ALREADY_ADDED；如果要添加的键值key已在哈希表中，但对应的值value不同，则函数将value值更新到哈希表中，之后返回 HASH_REPLACED_VALUE；如果要添加的键值key不在哈希表中，则函数创建 HashEntry 类型，并将其加入到哈希表中，且函数返回 HASH_ADDED。本题所用的哈希函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">long hash_string(const char *<span class="hljs-built_in">str</span>)<br>&#123;<br>    long <span class="hljs-built_in">hash</span> = <span class="hljs-number">5381</span>;<br>    <span class="hljs-built_in">int</span> c;<br><br>    <span class="hljs-keyword">while</span> (c = *<span class="hljs-built_in">str</span>++)<br>        <span class="hljs-built_in">hash</span> = ((<span class="hljs-built_in">hash</span> &lt;&lt; <span class="hljs-number">5</span>) + <span class="hljs-built_in">hash</span>) + c; /* <span class="hljs-built_in">hash</span> * <span class="hljs-number">33</span> + c */<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">hash</span> &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">hash</span> *= -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案代码及注释"><a href="#答案代码及注释" class="headerlink" title="答案代码及注释"></a>答案代码及注释</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hash.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function">HASH_RESULT <span class="hljs-title">hash_add_int</span><span class="hljs-params">(HashTable* table, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key, <span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> hash = <span class="hljs-built_in">hash_string</span>(key) % table-&gt;size;<span class="hljs-comment">//计算哈希地址</span><br>    HashEntry* p = table-&gt;bucket[hash];<br>    <span class="hljs-keyword">for</span> (p = table-&gt;bucket[hash]; p &amp;&amp; <span class="hljs-built_in">strcmp</span>(p-&gt;key.str_value, key);)<span class="hljs-comment">//对于char*的变量一定要用strcmp来进行比较</span><br>        p = p-&gt;next;<span class="hljs-comment">//查找是否存在键值相同的元素</span><br>    <span class="hljs-keyword">if</span> (p) &#123;<span class="hljs-comment">//若存在相同键值的元素</span><br>        <span class="hljs-keyword">if</span> (value == p-&gt;value.int_value)<br>            <span class="hljs-keyword">return</span> HASH_ALREADY_ADDED;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p-&gt;value.int_value = value;<br>            <span class="hljs-keyword">return</span> HASH_REPLACED_VALUE;<br>        &#125;<br>    &#125;<br>    p = (HashEntry*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(HashEntry));<span class="hljs-comment">//不存在则添加节点</span><br>    <span class="hljs-keyword">if</span> (!p)<span class="hljs-comment">//是否成功分配节点空间</span><br>        <span class="hljs-keyword">return</span> HASH_ERROR;<br>    <span class="hljs-keyword">else</span> &#123;<br>        p-&gt;key.str_value = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>        <span class="hljs-keyword">if</span> (!p-&gt;key.str_value)<span class="hljs-comment">//是否成功分配键值空间</span><br>            <span class="hljs-keyword">return</span> HASH_ERROR;<br>    &#125;<span class="hljs-comment">//这里一定要判定是否成功！！！</span><br>    <span class="hljs-built_in">strcpy</span>(p-&gt;key.str_value, key);<br>    p-&gt;value.int_value = value;<br>    table-&gt;bucket[hash] = p;<span class="hljs-comment">//按道理这里应该把之前的节点接在p的next后面，但是代码过不了OJ，没想到这样直接不要后面的节点居然对了，没搞明白。</span><br>    <span class="hljs-keyword">return</span> HASH_ADDED;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>oj</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Icoding题解」哈希表创建</title>
    <link href="/2020/06/icoding-create-hash/"/>
    <url>/2020/06/icoding-create-hash/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表创建"><a href="#哈希表创建" class="headerlink" title="哈希表创建"></a>哈希表创建</h1><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/wp-content/uploads/2020/06/icoding.png"></p><p><a href="https://icoding.run/ide#/question/130">题目链接</a></p><p>哈希表（Hash Table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。哈希表相关定义如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;<br>    HASH_OK,<br>    HASH_ERROR,<br>    HASH_ADDED,<br>    HASH_REPLACED_VALUE,<br>    HASH_ALREADY_ADDED,<br>    HASH_DELETED,<br>    HASH_NOT_FOUND,<br>&#125; HASH_RESULT;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashEntry</span> HashEntry;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashEntry</span>&#123;<br>    <span class="hljs-keyword">union</span>&#123;<br>        <span class="hljs-type">char</span>  *str_value;<br>        <span class="hljs-type">double</span> dbl_value;<br>        <span class="hljs-type">int</span>       int_value;<br>    &#125; key;<br>    <span class="hljs-keyword">union</span>&#123;<br>        <span class="hljs-type">char</span>  *str_value;<br>        <span class="hljs-type">double</span> dbl_value;<br>        <span class="hljs-type">int</span>       int_value;<br>        <span class="hljs-type">long</span>   long_value;<br>        <span class="hljs-type">void</span>  *ptr_value;<br>    &#125; value;<br>    HashEntry *next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashTable</span>&#123;<br>    HashEntry **bucket;        <br>    <span class="hljs-type">int</span> size;<br>    HASH_RESULT last_error;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashTable</span> HashTable;<br><br><span class="hljs-comment">// 创建大小为hash_size的哈希表，创建成功后返回HashTable类型的指针，否则返回NULL。</span><br><span class="hljs-function">HashTable *<span class="hljs-title">create_hash</span><span class="hljs-params">(<span class="hljs-type">int</span> hash_size)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="哈希表相关说明："><a href="#哈希表相关说明：" class="headerlink" title="哈希表相关说明："></a>哈希表相关说明：</h2><ol><li>HASH_RESULT 类型为相关函数的返回类型</li><li>HashEntry 为哈希表所保存元素（即键值对 ）类型</li><li>HashTable 为哈希表，其中 bucket 指向大小为size的、元素类型为 HashEntry*的指针数组</li><li>希表采用链地址法处理冲突</li></ol><h2 id="请实现-create-hash-函数，创建指定大小的哈希表。"><a href="#请实现-create-hash-函数，创建指定大小的哈希表。" class="headerlink" title="请实现 create_hash 函数，创建指定大小的哈希表。"></a>请实现 create_hash 函数，创建指定大小的哈希表。</h2><p><strong>程序流程图(flow代码）</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livescript">step1=&gt;start: 开始<br>step2=&gt;operation: 分配哈希表（容器）空间<br>step3=&gt;operation: 分配bucket（桶）空间<br>cond1=&gt;condition: 是否成果分配bucket空间<br>step4=&gt;operation: 释放哈希表空间<br>step5=&gt;operation: <span class="hljs-keyword">return</span> NULL<br>step6=&gt;operation: 初始化哈希表<br>step7=&gt;operation: <span class="hljs-keyword">return</span> H<br>step8=&gt;end: 结束<br><br>step1-&gt;step2-&gt;step3-&gt;cond1<br>cond1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>)</span>-&gt;</span>step6<br>cond1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>step4-&gt;step5<br>step6-&gt;step7-&gt;step8<br></code></pre></td></tr></table></figure><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/icoding_create_hash/20200622222331.png" alt="img"></p><h3 id="答案代码"><a href="#答案代码" class="headerlink" title="答案代码"></a>答案代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hash.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><br><span class="hljs-function">HashTable* <span class="hljs-title">create_hash</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    HashTable* H = (HashTable*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(HashTable));<br>    H-&gt;bucket = (HashEntry**)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(HashEntry**) * size);<br>    <span class="hljs-keyword">if</span> (!H-&gt;bucket) &#123;<br>        <span class="hljs-built_in">free</span>(H);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(H, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(HashTable));<br>    H-&gt;size = size;<br>    <span class="hljs-keyword">return</span> H;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="哈希表创建-1"><a href="#哈希表创建-1" class="headerlink" title="哈希表创建"></a>哈希表创建</h1><p><a href="https://icoding.run/ide#/question/130">题目链接</a></p><p>哈希表（Hash Table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。哈希表相关定义如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;<br>    HASH_OK,<br>    HASH_ERROR,<br>    HASH_ADDED,<br>    HASH_REPLACED_VALUE,<br>    HASH_ALREADY_ADDED,<br>    HASH_DELETED,<br>    HASH_NOT_FOUND,<br>&#125; HASH_RESULT;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashEntry</span> HashEntry;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashEntry</span>&#123;<br>    <span class="hljs-keyword">union</span>&#123;<br>        <span class="hljs-type">char</span>  *str_value;<br>        <span class="hljs-type">double</span> dbl_value;<br>        <span class="hljs-type">int</span>       int_value;<br>    &#125; key;<br>    <span class="hljs-keyword">union</span>&#123;<br>        <span class="hljs-type">char</span>  *str_value;<br>        <span class="hljs-type">double</span> dbl_value;<br>        <span class="hljs-type">int</span>       int_value;<br>        <span class="hljs-type">long</span>   long_value;<br>        <span class="hljs-type">void</span>  *ptr_value;<br>    &#125; value;<br>    HashEntry *next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashTable</span>&#123;<br>    HashEntry **bucket;        <br>    <span class="hljs-type">int</span> size;<br>    HASH_RESULT last_error;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashTable</span> HashTable;<br><br><span class="hljs-comment">// 创建大小为hash_size的哈希表，创建成功后返回HashTable类型的指针，否则返回NULL。</span><br><span class="hljs-function">HashTable *<span class="hljs-title">create_hash</span><span class="hljs-params">(<span class="hljs-type">int</span> hash_size)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="哈希表相关说明：-1"><a href="#哈希表相关说明：-1" class="headerlink" title="哈希表相关说明："></a>哈希表相关说明：</h2><ol><li>HASH_RESULT 类型为相关函数的返回类型</li><li>HashEntry 为哈希表所保存元素（即键值对 ）类型</li><li>HashTable 为哈希表，其中 bucket 指向大小为size的、元素类型为 HashEntry*的指针数组</li><li>希表采用链地址法处理冲突</li></ol><h2 id="请实现-create-hash-函数，创建指定大小的哈希表。-1"><a href="#请实现-create-hash-函数，创建指定大小的哈希表。-1" class="headerlink" title="请实现 create_hash 函数，创建指定大小的哈希表。"></a>请实现 create_hash 函数，创建指定大小的哈希表。</h2><p><strong>程序流程图(flow代码）</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livescript">step1=&gt;start: 开始<br>step2=&gt;operation: 分配哈希表（容器）空间<br>step3=&gt;operation: 分配bucket（桶）空间<br>cond1=&gt;condition: 是否成果分配bucket空间<br>step4=&gt;operation: 释放哈希表空间<br>step5=&gt;operation: <span class="hljs-keyword">return</span> NULL<br>step6=&gt;operation: 初始化哈希表<br>step7=&gt;operation: <span class="hljs-keyword">return</span> H<br>step8=&gt;end: 结束<br><br>step1-&gt;step2-&gt;step3-&gt;cond1<br>cond1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>)</span>-&gt;</span>step6<br>cond1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>step4-&gt;step5<br>step6-&gt;step7-&gt;step8<br></code></pre></td></tr></table></figure><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/icoding_create_hash/20200623164111.png" alt="img"></p><h3 id="答案代码-1"><a href="#答案代码-1" class="headerlink" title="答案代码"></a>答案代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hash.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><br><span class="hljs-function">HashTable* <span class="hljs-title">create_hash</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    HashTable* H = (HashTable*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(HashTable));<br>    H-&gt;bucket = (HashEntry**)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(HashEntry**) * size);<br>    <span class="hljs-keyword">if</span> (!H-&gt;bucket) &#123;<br>        <span class="hljs-built_in">free</span>(H);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(H, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(HashTable));<br>    H-&gt;size = size;<br>    <span class="hljs-keyword">return</span> H;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>oj</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本科阶段嵌入式方向技能树</title>
    <link href="/2020/06/awesome-es/"/>
    <url>/2020/06/awesome-es/</url>
    
    <content type="html"><![CDATA[<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>这是一个电子科技大学软件学院本科阶段计算机体系结构学习&amp;嵌入式开发的公开课&#x2F;书籍&#x2F;Blog&#x2F;资料整理的项目，如果你有贡献的想法：</p><ol><li>可以直接提交Pull Request</li><li>如果你是嵌入式工作室成员，请联系<a href="https://github.com/starFalll">@starFalll</a>（<a href="mailto:&#x66;&#x79;&#120;&#102;&#x6f;&#114;&#109;&#x61;&#108;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;">&#x66;&#x79;&#120;&#102;&#x6f;&#114;&#109;&#x61;&#108;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;</a>）,<a href="https://github.com/StevenXu98">@StevenXu98</a>（<a href="mailto:&#115;&#116;&#x65;&#x76;&#101;&#x6e;&#95;&#x78;&#x75;&#x39;&#x38;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#109;">&#115;&#116;&#x65;&#x76;&#101;&#x6e;&#95;&#x78;&#x75;&#x39;&#x38;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#109;</a>）等<a href="https://github.com/UESTC404">UESTC404</a>组织的所有者，邀请你加入 UESTC404 中</li></ol><h1 id="学习资源分享"><a href="#学习资源分享" class="headerlink" title="学习资源分享"></a>学习资源分享</h1><ul><li><p>推荐的学习主线：</p><table><thead><tr><th>时间</th><th>内容</th></tr></thead><tbody><tr><td>大一上</td><td>C语言，STM32&#x2F;51单片机开发入门</td></tr><tr><td>大一下</td><td>数据结构和算法， STM32裸板开发，Linux操作及使用，项目实战</td></tr><tr><td>大二上</td><td>arm体系架构(<a href="#%E5%B5%8C%E5%85%A5%E5%BC%8Flinux">嵌入式linux</a>)，STM32从裸板到应用，计算机组成原理，软件工程项目实战</td></tr><tr><td>大二下</td><td>C++， 实时操作系统RTOS，<a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>，Linux系统编程，计算机网络，项目实战</td></tr><tr><td>大三上</td><td>编译原理，Linux内核与驱动(<a href="#%E5%B5%8C%E5%85%A5%E5%BC%8Flinux">嵌入式linux</a>)，<a href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98">项目实战</a>，<a href="#%E6%89%BE%E5%AE%9E%E4%B9%A0">找实习</a></td></tr><tr><td>大三下</td><td>企业实习&#x2F;教研室科研&#x2F;海外交换</td></tr></tbody></table></li><li><p>欢迎大家随时更新</p></li><li><p>参考阅读</p><ul><li><a href="https://zhuanlan.zhihu.com/p/22266788">机器人工程师学习计划</a></li><li><a href="https://zhuanlan.zhihu.com/p/75522108">技术专精与广博的一些思考</a></li><li><a href="https://github.com/UESTC-Course/uestc-course">电子科技大学资源共享平台</a></li><li><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT">清华大学计算机系课程攻略</a></li><li><a href="https://github.com/QSCTech/zju-icicles">浙江大学课程攻略共享计划</a></li><li><a href="https://github.com/USTC-Resource/USTC-Course">中国科学技术大学课程资源</a></li><li><a href="https://github.com/CoolPhilChen/SJTU-Courses">上海交通大学课程资料分享</a></li></ul></li></ul><h2 id="技能图谱"><a href="#技能图谱" class="headerlink" title="技能图谱"></a>技能图谱</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>作为一名软件学院的本科生，必须牢牢掌握以下计算机相关的知识：</p><table><thead><tr><th>技能点名称</th><th>技能点内容</th></tr></thead><tbody><tr><td><a href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a></td><td><a href="#C%E8%AF%AD%E8%A8%80">C语言</a>, <a href="#C++">C++</a>, <a href="#Python">Python</a></td></tr><tr><td><a href="#%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">算法和数据结构</a></td><td>链表，栈，队列，字符串，二叉树，图，查找，排序，以及一些面试中经常考察的模板例如动态规划，滑动窗口，快慢指针，寻找第 K 个最大的元素等等</td></tr><tr><td><a href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">软件工程</a></td><td>编写文档, 代码质量, 自动化测试, Code Review, 持续集成工具</td></tr><tr><td><a href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86">编译原理</a></td><td>编译器构造及各部分功能</td></tr><tr><td><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机体系结构</a></td><td>CPU原型机, 总线, 存储,</td></tr><tr><td><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></td><td>进程管理, 内存管理, 文件系统, …</td></tr><tr><td><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a></td><td>OSI五层模型, TCP&#x2F;IP协议栈, Linux网络编程, …</td></tr></tbody></table><h3 id="嵌入式方向"><a href="#嵌入式方向" class="headerlink" title="嵌入式方向"></a>嵌入式方向</h3><p>如果你对嵌入式方向有兴趣，需要掌握以下技能：</p><table><thead><tr><th>技能点名称</th><th>技能点内容</th></tr></thead><tbody><tr><td>开发平台</td><td>CPU: Intel x86 x64, ARM64</td></tr><tr><td></td><td><a href="#MCU%E7%BC%96%E7%A8%8B">MCU编程</a>：C51, STM32</td></tr><tr><td></td><td>FPGA</td></tr><tr><td><a href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6">嵌入式开发软件</a></td><td>Keil uVision, STM32Cube, JTAG debugger, System Viewer</td></tr><tr><td><a href="#%E5%B5%8C%E5%85%A5%E5%BC%8FLinux">嵌入式Linux</a></td><td>Bootloader, Driver, …</td></tr><tr><td><a href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">实时操作系统</a></td><td>uCOS, FreeRTOS, ROS（严格来说是ROS2）</td></tr><tr><td>外设</td><td>Timer, ADC &#x2F; DAC, ROM &#x2F; RAM, PWM, I&#x2F;O &#x2F; GPIO, …</td></tr><tr><td>执行器</td><td>电机(步进, 无刷, 舵机, …), 电调, FOC</td></tr><tr><td>传感器</td><td>陀螺仪, 加速度计, 超声波, 红外, …</td></tr><tr><td>电子元件</td><td>电容, 电阻, 开关, 二极管, 晶振…</td></tr><tr><td>通信协议</td><td>Bluetooth, Zigbee, Wifi, UART, TCP, UDP, I2C, …</td></tr><tr><td>电路</td><td>PCB设计, 元件焊接</td></tr><tr><td>仪器</td><td>万用表, 示波器, 信号发生器, 逻辑分析仪, …</td></tr></tbody></table><p>借一张导师的经典老图，差不多就这个学习路线。</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2022/01/15/image-20220115150133350.png" alt="image-20220115150133350"></p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p>书籍推荐：</p><table><thead><tr><th>名称</th><th>作者</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/2280547/">C语言程序设计现代方法</a></td><td>K. N. King</td><td>入门推荐读物，讲解清晰</td></tr><tr><td><a href="https://book.douban.com/subject/3012360/">C与指针</a></td><td><a href="https://book.douban.com/author/1715767/">Kenneth A·Reek</a></td><td>进阶读物，“C语言三剑客”之一</td></tr><tr><td><a href="https://book.douban.com/subject/2778632/">C陷阱与缺陷</a></td><td><a href="https://book.douban.com/author/284407/">凯尼格</a></td><td>进阶读物，“C语言三剑客”之一，重点讲解C中的注意事项</td></tr><tr><td><a href="https://book.douban.com/subject/2377310/">C专家编程</a></td><td><a href="https://book.douban.com/author/1176128/">Peter van der Linden</a></td><td>进阶读物，“C语言三剑客”之一</td></tr></tbody></table><p>资源推荐：</p><ul><li><a href="https://github.com/jobbole/awesome-c-cn">C 语言资源大全中文版</a></li><li><a href="https://blog.feabhas.com/2012/06/the-c-build-process/">The C build process</a></li></ul><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>书籍推荐阅读顺序：</p><table><thead><tr><th>阅读顺序</th><th>名称</th><th>作者</th><th>介绍</th></tr></thead><tbody><tr><td>1</td><td><a href="https://book.douban.com/subject/25708312/">C++ Primer</a></td><td>[<a href="https://en.wikipedia.org/wiki/Stanley_B._Lippman">美] Stanley B. Lippman</a> &#x2F; [美] Josée Lajoie &#x2F; [<a href="https://en.wikipedia.org/wiki/Barbara_E._Moo">美] Barbara E. Moo</a></td><td>C++最经典教程</td></tr><tr><td>2</td><td><a href="https://book.douban.com/subject/5387403/">Effective C++</a></td><td><a href="https://book.douban.com/search/%E6%A2%85%E8%80%B6">梅耶 (Scott Meyers)</a></td><td>C++开发必读经典</td></tr><tr><td>3</td><td><a href="https://book.douban.com/subject/1110934/">STL源码剖析</a></td><td><a href="https://book.douban.com/author/104388/">侯捷</a></td><td>理解STL源码必读</td></tr><tr><td>4</td><td><a href="https://book.douban.com/subject/1091086/">深度探索C++对象模型</a></td><td>[<a href="https://book.douban.com/author/201520/">美] Stanley B·Lippman</a></td><td>从编译器层面认识C++对象模型</td></tr></tbody></table><p>资源推荐：</p><ul><li><a href="https://github.com/jobbole/awesome-cpp-cn">C++ 资源大全中文版</a></li><li><a href="https://github.com/wuye9036/CppTemplateTutorial">CppTemplateTutorial</a></li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><a href="http://www.icourse163.org/course/ZJU-1001542001#/info">面向对象程序设计——Java语言 - 翁恺</a></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">Python教程- 廖雪峰</a></li></ul><h3 id="汇编-X86"><a href="#汇编-X86" class="headerlink" title="汇编 - X86"></a>汇编 - X86</h3><ul><li><a href="https://github.com/gurugio/book_assembly_8086">8086 assembly programming with emu8086</a></li></ul><h3 id="汇编-ARM"><a href="#汇编-ARM" class="headerlink" title="汇编 - ARM"></a>汇编 - ARM</h3><ul><li><a href="https://www.scss.tcd.ie/~waldroj/3d1/arm_arm.pdf">ARM Architecture Reference Manual, 2nd Edition</a></li></ul><h2 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h2><table><thead><tr><th>名称</th><th>作者</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/">数据结构</a></td><td>邓俊辉</td><td>国内质量最高的数据结构课程，推荐在MOOC上跟学，<a href="https://book.douban.com/subject/25859528/">教材链接</a></td></tr></tbody></table><h2 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h2><p>在大一上学完C语言之后，推荐自学一门课：MIT 的 <a href="https://missing.csail.mit.edu/">The Missing Semester of Your CS Education</a>，可以翻译为计算机科学课堂中学不到的知识。<a href="https://www.bilibili.com/video/BV1x7411H7wa">B站链接</a>.</p><p>这门课会教你使用各种工具链，比如 在终端下Bash Shell 编程，VIM 编辑器，正则表达式，Git 版本控制，profiler, SSH 配置远程环境等等。灵活地使用工具链能极大地提高你的工作效率。</p><p>你可以考虑运用在这门课上学到的知识，在大一下的时候在 Github 上搭一个自己的博客。</p><h3 id="版本控制：Git"><a href="#版本控制：Git" class="headerlink" title="版本控制：Git"></a>版本控制：Git</h3><ul><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程- 廖雪峰</a></li></ul><h3 id="编译工具：Makelile"><a href="#编译工具：Makelile" class="headerlink" title="编译工具：Makelile"></a>编译工具：Makelile</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2015/02/make.html">Make 命令教程</a></li><li><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html">GCC and Make</a></li><li><a href="http://uploads.mitechie.com/books/Managing_Projects_with_GNU_Make_Third_Edition.pdf">Managing projects with GNU Make</a></li></ul><h3 id="嵌入式开发软件"><a href="#嵌入式开发软件" class="headerlink" title="嵌入式开发软件"></a>嵌入式开发软件</h3><ul><li>Keil uVision</li><li>STM32Cube</li><li>jtag debugger</li></ul><h2 id="MCU编程"><a href="#MCU编程" class="headerlink" title="MCU编程"></a>MCU编程</h2><h3 id="51单片机"><a href="#51单片机" class="headerlink" title="51单片机"></a>51单片机</h3><ul><li><a href="https://github.com/TairanHu/51-BY51DB">BY51DB开发板 51单片机代码</a></li></ul><h3 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h3><ul><li><a href="https://github.com/Embdefire/products/wiki">野火电子</a></li><li><a href="https://github.com/avislab/STM32F103">STM32F103C8 参考代码</a></li><li><a href="https://github.com/RT-Thread/rt-thread/tree/master/bsp/stm32/stm32f427-robomaster-a">STM32F427 RoboMaster A板 BSP</a></li></ul><h3 id="学习指南"><a href="#学习指南" class="headerlink" title="学习指南"></a>学习指南</h3><p><strong>内核</strong>：多参考ARM Crotex M3&#x2F;M4权威指南，结合《计算机组成原理》和《ARM处理器及应用》相关课程内容进行理解。需要了解的知识点有启动流程、中断流程、时钟树……</p><p><strong>外设</strong>：对于MCU编程来说外设的学习主要分为以下步骤</p><ol><li><p>硬件构造，例如挂载到哪个时钟总线上，硬件上是否需要依托其他外设工作……</p></li><li><p>协议原理，搞清楚通信协议内容和规则，了解下通信的信号是怎么样的。</p></li><li><p>寄存器功能，参考芯片《用户手册》详细了解外设相关寄存器功能，有多少个相关寄存器，每个寄存器是干什么用的，每一位又有什么用。</p></li><li><p>代码模仿，去原子、野火这些地方找点样例代码，学习下代码结构，让外设工作起来需要哪些配置步骤。</p></li><li><p>上手实践，自己去实现一套外设驱动，多尝试不同的配置不同的功能。</p></li></ol><p>搞定这几个环节应该就能把相应的外设基本搞清楚，也能实现简单的功能了，接下来就是灵活应用，深入了解其中原理了。</p><h2 id="嵌入式Linux"><a href="#嵌入式Linux" class="headerlink" title="嵌入式Linux"></a>嵌入式Linux</h2><h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><table><thead><tr><th>名称</th><th>作者</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/6097773/">LKD3</a></td><td>Robert Love</td><td>linux内核的设计与实现，非常经典的入门书籍。可帮助理解操作系统</td></tr><tr><td><a href="https://book.douban.com/subject/3088263/">ELDD</a></td><td>Sreekrishnan Venkateswaran</td><td>linux设备驱动详细解读，稍难，是linux设备驱动相关的经典书籍。</td></tr><tr><td>Linux内核源代码情景分析</td><td>毛德操 &#x2F; 胡希明</td><td>浙大毛教授著作。基于2.4内核，对代码有详细解读。虽2.4版本较老，但如此详细的解读也值得一读。</td></tr><tr><td><a href="https://book.douban.com/subject/1768601/">The Design of the Unix Operating System</a></td><td>Maurice J. Bach</td><td></td></tr><tr><td><a href="https://xinqiu.gitbooks.io/linux-insides-cn/content/index.html">Linux 内核揭秘</a></td><td></td><td></td></tr><tr><td><a href="https://book.douban.com/subject/1723151/">Linux Device Drivers, 3rd Edition</a></td><td>Jonahan Corbet</td><td></td></tr></tbody></table><h3 id="树莓派"><a href="#树莓派" class="headerlink" title="树莓派"></a>树莓派</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2017/06/raspberry-pi-tutorial.html">树莓派新手入门教程</a></li><li><a href="https://www.zhihu.com/question/409358504/answer/1361895930">树莓派有什么好用的系统</a></li><li><a href="https://www.zhihu.com/question/389530501/answer/1416338154">树莓派NAS</a></li><li><a href="https://zhuanlan.zhihu.com/p/269727770">树莓派安装OpenCV</a></li><li>……</li></ul><h3 id="NVIDIA-Jetson"><a href="#NVIDIA-Jetson" class="headerlink" title="NVIDIA Jetson"></a>NVIDIA Jetson</h3><ul><li><a href="https://www.zhihu.com/column/c_1412785437094506496">CUDA on ARM入门教程</a></li><li><a href="https://github.com/dusty-nv/jetson-inference">Hello AI World</a></li><li>……</li></ul><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><table><thead><tr><th>名称</th><th>作者</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://www.cs.cmu.edu/~janh/courses/411/16/">15-411&#x2F;611 Compiler Design - CMU</a></td><td>Jan Hoffmann</td><td>CMU的编译原理基础课程</td></tr><tr><td><a href="https://pandolia.net/tinyc/index.html">自己动手写编译器</a></td><td>pandolia</td><td>实现一个简单的C编译器</td></tr></tbody></table><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><ul><li>编写文档： <a href="http://www.doxygen.nl/">Doxygen</a>, <a href="http://www.sphinx-doc.org/en/master/">Sphinx</a></li><li>代码质量：<ul><li>C: <a href="https://ilcc.gitbooks.io/wiki/StyleGuide/Huawei-C/index.html">华为C语言编程规范</a></li><li>C++: <a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></li><li>Java: <a href="https://yq.aliyun.com/articles/69327">阿里巴巴Java开发手册</a></li><li>Python: <a href="https://www.python.org/dev/peps/pep-0008/">PEP8</a>, <a href="https://pypi.org/project/isort/">isort</a>, <a href="https://pypi.org/project/black/">black</a>, <a href="https://github.com/facebook/pyre-check">Pyre</a></li></ul></li><li>自动化测试: <a href="https://robotframework.org/">Robot</a>, <a href="https://docs.pytest.org/en/latest/">pytest</a></li><li>Code review: <a href="https://www.vogella.com/tutorials/Gerrit/article.html">Gerrit</a></li><li>持续集成工具: <a href="https://travis-ci.org/">Travis CI</a></li></ul><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><table><thead><tr><th>名称</th><th>作者</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/25820786/">Computer Organization and Design, Fifth Edition</a></td><td>David A. Patterson &#x2F; John L. Hennessy</td><td>作者是图灵奖得主，提出RISC架构</td></tr></tbody></table><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><table><thead><tr><th>名称</th><th>作者</th><th>介绍</th></tr></thead><tbody><tr><td><a href="http://book.douban.com/subject/26176870/">计算机网络(第6版)</a></td><td>James F.Kurose &#x2F; Keith W.Ross</td><td></td></tr></tbody></table><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><table><thead><tr><th>名称</th><th>作者</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://chyyuu.gitbooks.io/os_course_info/">清华大学操作系统课程(2019)</a></td><td></td><td>清华OS实验室的操作系统课程，课件、实验作业的质量都非常高</td></tr></tbody></table><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><table><thead><tr><th>名称</th><th>作者</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://doc.micrium.com/pages/viewpage.action?pageId=10753180&preview=/10753180/12779577/100-uCOS-III-ST-STM32-003.pdf">μC&#x2F;OS-III: The Real-Time Kernel for STM32</a></td><td>Jean J. Labrosse</td><td>经典实时操作系统, C语言编写</td></tr><tr><td><a href="https://github.com/alibaba/AliOS-Things">AliOS Things</a></td><td></td><td>国产实时操作系统，阿里巴巴面向物联网领域开发</td></tr><tr><td><a href="https://github.com/Tencent/TencentOS-tiny">TencentOS-tiny</a></td><td></td><td>国产实时操作系统，腾讯面向物联网领域开发</td></tr><tr><td><a href="https://github.com/LiteOS/LiteOS">Huawei-LiteOS</a></td><td></td><td>鸿蒙操作系统物联网业务内核</td></tr></tbody></table><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>工作室往届的项目介绍：</p><table><thead><tr><th>名称</th><th>年级</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://github.com/xxyyttxx/Quadcopter">Quadcopter</a></td><td>2015</td><td>基于STM32F411外设固件库的四轴keil5工程</td></tr><tr><td><a href="https://github.com/starFalll/Raspbarry_Tensorflow_Robot">基于Tensorflow的树莓派智能识别机器人</a></td><td>2016</td><td>基于Tensorflow的树莓派智能识别机器人</td></tr><tr><td><a href="https://github.com/Crabor/Quadcopter">Quadcopter</a></td><td>2017</td><td>基于STM32F401RE的四轴飞行器</td></tr><tr><td><a href="https://github.com/Jason-xy/VSLAM-Quadcopter_2021TI">SkyEye</a></td><td>2021</td><td>基于ROS的VSLAM四轴飞行器</td></tr><tr><td><a href="https://github.com/Jason-xy/WuhuTakeOff">WuhuTakeOff</a></td><td>2021</td><td>基于FreeRTOS的四轴飞行器</td></tr></tbody></table><p>一些推荐参加的本科阶段的科技创新类项目 &amp; 比赛：</p><table><thead><tr><th>名称</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://summerofcode.withgoogle.com/">Google Summer of Code</a></td><td>每年3月份开始提交申请的proposal</td></tr><tr><td><a href="http://121.48.165.20/mathmodeling/">数学建模</a></td><td>要自学一下matlab</td></tr><tr><td><a href="https://www.robomaster.com/zh-CN/robo/overview">Robomaster</a></td><td></td></tr><tr><td><a href="https://acm.uestc.edu.cn/home">ACM</a></td><td></td></tr><tr><td>嵌入式综合设计</td><td>在廖老师指导下做四轴飞行器</td></tr></tbody></table><h2 id="找实习"><a href="#找实习" class="headerlink" title="找实习"></a>找实习</h2><ul><li>找工作室前辈内推</li><li>刷题：<a href="https://leetcode.com/">Leetcode</a>，<a href="https://www.nowcoder.com/">牛课网</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>学习计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>embedded system</tag>
      
      <tag>plan</tag>
      
      <tag>awesome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派(Raspberry Pi)资源大全中文版</title>
    <link href="/2020/06/raspi-source/"/>
    <url>/2020/06/raspi-source/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/wwj718/awesome-raspberry-pi-zh" title="转载自Github：awesome-raspberry-pi-zh">转载自Github：awesome-raspberry-pi-zh</a></p><p>   <a href="https://www.raspberrypi.org"><img src="https://www.raspberrypi.org/wp-content/uploads/2012/03/raspberry-pi-logo.png" alt="Raspberry Pi Logo" align="left" style="margin-right: 25px" height=150></a></p><blockquote><p>树莓派（Raspberry Pi，下面简称RPi）是一系列由英国树莓派基金会（Raspberry Pi Foundation）开发的仅信用卡大小的微型计算机，截止到2017年2月，共发行了RPi 1，RPi 2，RPi 3以及RPi Zero 四款。树莓派发行的初衷，是在学校以及发展中国家推广基础计算机科学，官方主页：<a href="https://raspberrypi.org/">Raspberry Pi Homepage</a></p></blockquote><p>   本列表翻译自<a href="https://github.com/thibmaek/awesome-raspberry-pi">awesome-raspberry-pi</a> ，是由 <a href="https://github.com/thibmaek">thibmaek</a> 发起并维护的树莓派资源列表，内容包括树莓派相关的工具、项目、系统镜像、社区及其他一些资源。</p><p>   Awesome-XXX 是GitHub上知名的一组项目，其主页：<a href="https://github.com/sindresorhus/awesome/blob/master/awesome.md">Awesome 清单</a></p><p>   近期我正好在折腾树莓派，觉得资源列表上有很多好玩的项目，遂决定译个中文版本，之后会根据我个人的使用情况添加更详细的注脚，也非常欢迎国内的树莓派爱好者一起来维护这个列表，但在这之前，请先阅读<a href="CONTRIBUTING.md">贡献指南</a></p><h2 id="项目的参与者"><a href="#项目的参与者" class="headerlink" title="项目的参与者"></a>项目的参与者</h2><ul><li>Todo：<ul><li><input disabled="" type="checkbox"> 添加国内开发者有趣的项目</li></ul></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#os-images">系统镜像</a></li><li><a href="#tools">工具</a></li><li><a href="#projects">项目</a></li><li><a href="#resources">资源</a></li></ul>   <h2 id="os-images">系统镜像</h2><ul><li><a href="https://www.raspberrypi.org/downloads/raspbian/">Raspbian</a> - 来自树莓派官方的操作系统，基于Debian，同时官方也提供了一个Raspbian的精简版。</li><li><a href="https://www.raspberrypi.org/downloads/noobs/">NOOBS</a> - 新的开箱即用软件, 为初学者准备的系统安装工具.</li><li><a href="https://ubuntu-mate.org/raspberry-pi/">Ubuntu MATE</a> - 为树莓派准备的Ubuntu发行版，基于MATE桌面环境. <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-2%2B.png" alt="Supports Raspberry Pi 2+"></li><li><a href="https://developer.ubuntu.com/en/snappy/start/raspberry-pi-2/">Snappy Ubuntu Core</a> - 为物联网准备的Ubuntu官方最小发行版 <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-2%2B.png" alt="Supports Raspberry Pi 2+"></li><li><a href="https://developer.microsoft.com/nl-nl/windows/iot/Downloads.htm">Windows 10 IoT Core</a> - 为物联网准备的Windows 10发行版. <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-2%2B.png" alt="Supports Raspberry Pi 2+"></li><li><a href="https://osmc.tv/">OSMC</a> - 基于Kodi的开源数字媒体中心系统.</li><li><a href="https://github.com/openfans-community-offical/Debian-Pi-Aarch64" title="Debian-Pi-Aarch64">Debian-Pi-Aarch64</a> - 为全新Raspberry Pi 4B适配的64位操作系统.</li><li><a href="http://pinet.org.uk/">PiNet</a> - 用于管理树莓派课堂的系统.</li><li><a href="https://www.riscosopen.org/content/downloads/raspberry-pi">Risc OS</a> - 非Linux操作系统, 来自ARM微处理器的开发小组</li><li><a href="http://www.runeaudio.com/">RuneAudio</a> - 免费和开源和操作系统，可将嵌入式硬件变为Hi-fi音乐播放器</li><li><a href="http://openelec.tv/">OpenELEC</a> - 开放的嵌入式Linux娱乐中心，基于Kodi构建的轻量级系统.</li><li><a href="http://blog.hypriot.com/about/">HypriotOS</a> - 基于Debian的最小操作系统，为运行docker做了优化.</li><li><a href="https://www.offensive-security.com/kali-linux-arm-images/">Kali Linux</a> -  为渗透测试和正义黑客准备的Linux发行版，运行在ARM设备上</li><li><a href="https://retropie.org.uk/">RetroPie</a> - 在树莓派玩复古游戏。</li><li><a href="https://wiki.alpinelinux.org/wiki/Raspberry_Pi">Alpine Linux</a> - 面向安全的linux发行版，基于musl libc和busybox.</li><li><a href="https://archlinuxarm.org/">Arch Linux ARM</a> - 轻量且灵活的linux发行版，力图保持简单.</li><li><a href="https://volumio.org/">Volumio</a> - 高保真音乐播放器</li><li><a href="https://www.recalbox.com/">Recalbox</a> - 更轻巧的复古游戏和媒体中心</li><li><a href="http://lakka.tv/">Lakka</a> - 在树莓派上玩复古游戏，完全基于RetroArch构建.</li><li><a href="http://www.rasplex.com/">RasPlex</a> - 为树莓派准备的Plex客户端.</li><li><a href="https://github.com/futurice/chilipie-kiosk">chilipie-kiosk</a> - 可直接引导到全屏Chrome的镜像，非常适合用于仪表板和构建监视器。 <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-2%2B.png" alt="Supports Raspberry Pi 2+"></li><li><a href="https://github.com/Fourdee/DietPi">DietPi</a> -  为2G SD卡准备的最小镜像， 带有许多可配置项和脚本.</li><li><a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/Arm32/RaspberryPi3">CentOS</a> - 运行在树莓派上的CentOS. <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-2%2B.png" alt="Supports Raspberry Pi 2+"></li><li><a href="https://minibianpi.wordpress.com/">Minibian</a> - 最小的 Raspbian (比 Jessie Lite还要轻量).</li><li><a href="http://www.berryterminal.com/doku.php/berryboot">BerryBoot</a> - 系统启动加载器(Bootloader) &#x2F;通用操作系统安装程序 , 支持 VNC 和 HDMI-CEC.</li><li><a href="https://piratebox.cc/raspberry_pi:diy">PirateBox</a> - 匿名的离线移动文件共享&#x2F;通信系统。</li><li><a href="https://octopi.octoprint.org/">OctoPi</a> - 为3d打印机准备的发行版.</li><li><a href="http://developers.kano.me/downloads/">Kano OS</a> - 为探索、创造和玩耍准备准备的开源操作系统 – 对树莓派免费.</li><li><a href="https://resinos.io/">resinOS</a> - 在嵌入式设备中跑docker容器的开源操作系统, 考虑了生产环境所需的可靠性</li><li><a href="https://fedoraproject.org/wiki/Raspberry_Pi#Preparing_the_SD_card">Fedora</a> <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-2%2B.png" alt="Supports Raspberry Pi 2+"></li><li><a href="https://github.com/ccrisan/motioneyeos/wiki">motionEyeOS</a> - 将微型计算机打造为视频监控系统的Linux发行版。</li><li><a href="https://ownyourbits.com/2017/02/13/nextcloud-ready-raspberry-pi-image/">NextCloudPi</a> - 基于 LAMP（Linux Apache Mysql PHP） 的 Nextcloud 系统镜像，用于搭建家庭私有云服务。</li><li><a href="https://github.com/openfans-community-offical/Debian-Pi-Aarch64">Debian-Pi-Aarch64</a>全球发行的第一个同时支持树莓派全系64位硬件的64位系统 !!!</li></ul>   <h2 id="tools">工具</h2><ul><li><a href="http://www.pibakery.org/">PiBakery</a> - 基于google的blockly项目, 为树莓派准备的易用的配置工具.</li><li><a href="http://www.tweaking4all.com/software/macosx-software/macosx-apple-pi-baker/">ApplePi Bakery</a>  - macOS应用程序,可轻松地将系统镜像安装&#x2F;备份&#x2F;恢复到SD卡上.</li><li><a href="https://www.etcher.io/">Etcher</a> - 跨平台的SD卡烧录程序，使用简单，易于扩展.</li><li><a href="https://github.com/Drewsif/PiShrink/">PiShrink</a> - Bash脚本，它会自动缩小pi镜像，之后在启动时将其调整为SD卡的最大存储空间大小</li><li><a href="https://github.com/StarshipEngineer/OpenVPN-Setup">OpenVPN-Setup</a> - 用于将树莓派设置为OpenVPN服务器的Shell脚本.</li><li><a href="https://github.com/RPi-Distro/pi-gen">pi-gen</a> - 用于构建树莓派官方镜像的工具. 你可以将其用于构建自己的定制镜像（预装特定软件）</li><li><a href="http://www.pivpn.io/">PiVPN</a> - 简单、灵活的单行安装脚本，用于在树莓派上安装OpenVPN服务</li><li><a href="https://github.com/initialstate/pi-sensor-free-presence-detector/wiki">Network Presence Detector</a> - 配置Pi0，使其可以在wifi网络里扫描，发现谁是”home”</li><li><a href="https://github.com/resin-io-playground/resin-bridge">Resin Bridge</a> - 一个能够将RPid的wlan0接口和连接在eth0接口上的设备进行桥接的程序。</li><li><a href="https://steveedson.co.uk/tools/wpa/">WiFi config generator</a> - 用于生成一个包含wifi配置信息的配置文件wpa_supplicant.conf的小程序。</li><li><a href="https://ownyourbits.com/2017/02/06/raspbian-on-qemu-with-network-access/">Raspbian QEMU with network</a> - 在 Raspbian上运行QEMU的小程序。</li></ul>   <h2 id="projects">项目</h2><ul><li><p><a href="https://cdn-learn.adafruit.com/downloads/pdf/mini-oontz-3d-printed-midi-controller.pdf">Mini OONTZ</a> - 3D打印的迷你MIDI控制器</p></li><li><p><a href="https://gnurds.com/index.php/2012/10/02/raspberry-pi-power-strip/">Power Sniffing Strip</a> - 藏在电源插座里的树莓派, 用于嗅探网络数据.</p></li><li><p><a href="https://medium.com/@pieterjan_m/erlang-pi2-arm-cluster-vs-xeon-vm-40871d35d356#.bpao66cm8">Raspberry Pi Erlang Cluster</a> - 跑在树莓派2代上的Erlang集群</p></li><li><p><a href="http://www.mjoldfield.com/atelier/2012/08/ntp-nixie.html">NTP driven Nixie Clock</a> - 由树莓派驱动的数码管时钟</p></li><li><p><a href="http://hackaday.com/2014/02/17/40-node-raspi-cluster/">40-node Raspberry Pi Cluster</a> - 40个节点构成的树莓派集群</p></li><li><p><a href="http://www.widriksson.com/raspberry-pi-hadoop-cluster/">Raspberry PI Hadoop Cluster</a> - 跑在树莓派上的大数据集群.</p></li><li><p><a href="http://www.datastax.com/dev/blog/32-node-raspberry-pi-cassandra-cluster">Multi-Datacenter Cassandra on 32 Raspberry Pi’s</a> - 32个节点的树莓派cassandra数据库集群.</p></li><li><p><a href="http://bryanapperson.com/blog/the-definitive-guide-ceph-cluster-on-raspberry-pi/">Building a Ceph Cluster on Raspberry Pi</a> - 基于分布式对象存储系统RADOS的高度冗、低功耗家庭存储解决方案。</p></li><li><p><a href="https://github.com/evancohen/smart-mirror">Smart Mirror</a> - 带语音控制智能镜子，集成物联网. <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-2%2B.png" alt="Supports Raspberry Pi 2+"></p></li><li><p><a href="http://magicmirror.builders/">Magic Mirror</a> - 开源模块化智能镜子平台. <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-2%2B.png" alt="Supports Raspberry Pi 2+"></p></li><li><p><a href="https://blog.haschek.at/post/f31aa">Door bot</a> - 门卫机器人，感知到门被打开时将给你发送信息.</p></li><li><p><a href="https://www.reddit.com/r/raspberry_pi/comments/53nj1z/chromebook_charger_kiosk_last_minute_charge_for/">Chromebook Charger Kiosk</a> - 给在校生的Chromebooks准备的定时充电站</p></li><li><p><a href="https://jasperproject.github.io/">Jasper</a> - 灵活的开源个人助理.</p></li><li><p><a href="https://lightberry.eu/">Lightberry</a> - 为树莓派和电视准备的LED照明解决方</p></li><li><p><a href="https://github.com/SecPi/SecPi">SecPi</a> - 基于Raspberry Pi的家庭报警系统.</p></li><li><p><a href="https://github.com/n0bel/PiClock">PiClock</a> - 别致的时钟</p></li><li><p><a href="https://github.com/benjefferies/gogo-garage-opener">Garage Door Opener</a> - 车库开门器</p></li><li><p><a href="https://github.com/stevelacy/movel">Movel</a> - 树莓派车载电脑</p></li><li><p><a href="https://github.com/winkidney/PIFanTuner">PiFanTuner</a> - CPU风扇控制程序. <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-3.png" alt="Supports Raspberry Pi 3"></p></li><li><p><a href="https://samy.pl/skyjack/">SkyJack</a> - 在无线距离内，劫持并控制任何的Parrot AR Drone.</p></li><li><p><a href="https://github.com/nerves-project">Nerves Project</a> - 为嵌入式设备准备的erlang交叉编译环境</p></li><li><p><a href="https://github.com/rothgar/rpi-wordpress">Wordpress using Docker</a> - 使用docker跑wordpress（采用动态DNS）</p></li><li><p><a href="https://pi-hole.net/">Pi-hole</a> - 为互联网广告准备的黑洞.</p></li><li><p><a href="https://resin.io/blog/planning-lunch-with-a-slackbot-on-resin-io/">Planning lunch with a Slackbot on resin.io</a> - 用nodejs写的Slack机器人– 帮助解决”我们该吃什么”</p></li><li><p><a href="https://github.com/evancohen/sonus">Sonus</a> - 开源、跨平台的语音识别框架（Google Cloud Speech）</p></li><li><p><a href="https://github.com/samaaron/sonic-pi">Sonic Pi</a> - 让大家能够通过制作音乐来学习编程的一款音乐合成器</p></li><li><p><a href="https://github.com/alexa/alexa-avs-sample-app/wiki/Raspberry-Pi">Alexa AVS</a> - 基于Java客户端和Node.js服务端的 Alexa Voice Service 示例程序</p></li><li><p><a href="http://pi4j.com/">Pi4j Project</a> - 为RPi编写的具有友好API的Java I&#x2F;O 库</p></li><li><p><a href="https://www.raspberrypi.org/blog/harry-potter-and-the-real-life-daily-prophet/">Harry Potter and the real life Daily Prophet</a> - 通过RPi的7英寸显示模拟哈利波特中的魔法报纸（动态头条）</p></li><li><p><a href="http://denis.papathanasiou.org/posts/2015.05.30.post.html">PiScan</a> - 基于RPi和 EAN 扫描仪的 Amazon 条形码扫描器.</p></li><li><p><a href="http://www.htxt.co.za/2017/02/07/pie-ink-is-a-raspberry-pi-name-tag-that-uses-an-e-ink-display/">PiE-Ink</a> - 在RPi Zero上运行的E-ink身份卡片 <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-0.png" alt="Supports Raspberry Pi Zero"></p></li></ul>   <h2 id="resources">资源</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul><li><a href="https://www.liquidlight.co.uk/blog/article/raspberry-pi-what-is-it-and-why-do-i-need-one/">Raspberry Pi and why do I need one?</a> - 本文介绍树莓派以及能用它做些什么</li><li><a href="https://raspberrypi.about.com/od/Power/tp/10-Ways-to-Power-your-Raspberry-Pi.htm">10 Ways To Power</a> - 十种给树莓派供电的方法.</li></ul><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><ul><li><a href="https://blog.thibmaekelbergh.be/2015/02/16/bridging-wifi-to-the-raspberry-pi-over-ethernet.html">Bridging Wifi to the Raspberry Pi over Ethernet</a> - 在macOS和树莓派之间设置网络</li><li><a href="https://blog.thibmaekelbergh.be/2015/05/07/raspberry-pi-login-with-ssh-keys.html">Raspberry Pi login with SSH keys</a> - ssh免密码登录树莓派（使用SSH key）</li><li><a href="http://blog.hsp.dk/how-to-setup-vpn-server-on-raspberry-pi-or-digitalocean/">How to setup a secure VPN server on Raspberry Pi or DigitalOcean</a> - 简单、安全而详细的指南：在树莓派上设置VPN</li><li><a href="https://thesocietea.org/2016/03/controlling-spotify-with-slack-and-a-raspberry-pi/">Controlling Spotify with Slack and a Raspberry Pi</a> - Node.js项目， 使用libspotify控制 Spotify 和 Slack.</li><li><a href="https://github.com/irtimmer/moonlight-embedded">Moonlight</a> - 嵌入式系统的Gamestream客户端（把电脑主机的游戏串流到树莓派，然后输出到电视玩）</li><li><a href="http://blog.gbaman.info/?p=791">Raspberry Pi Zero: Programming over USB</a> - 树莓派Zero：使用USB来编程，无需网络连接、键盘或者屏幕 <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-0.png" alt="Supports Raspberry Pi Zero"></li><li><a href="https://www.mikestreety.co.uk/blog/use-a-raspberry-pi-with-multiple-wifi-networks">Use a Raspberry Pi with multiple WiFi networks</a> - 将树莓派接入多个无线网络的教程.</li><li><a href="http://www.htpcguides.com/category/raspberry-pi/">Raspberry Pi Media Server Guides</a> - 用树莓派搭建媒体服务器的教程（HTPC：Home Theater Personal Computer，即家庭影院电脑）</li><li><a href="http://n-o-d-e.net/post/150780207431/turn-the-raspberry-pi-zero-into-a-mini-dongle">Turn the Raspberry Pi Zero into a mini dongle computer</a> - 设置pi0，使其可以用USB登录ssh 和 vnc . <img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/rpi-0.png" alt="Supports Raspberry Pi Zero"></li><li><a href="http://developer.radiusnetworks.com/2014/04/27/how-to-make-a-raspberry-pi-turn-on-a-lamp-with-an-ibeacon.html">How To Make a Raspberry Pi Turn on a Lamp with iBeacon™ Technology</a> - iBeacon新手教程.</li><li><a href="https://raymii.org/s/articles/Build_a_35_dollar_Time_Capsule_-_Raspberry_Pi_Time_Machine.html">Build a $35 Time Capsule</a> - 时光机器（备份服务）</li><li><a href="https://lifehacker.com/how-to-turn-your-raspberry-pi-into-a-retro-game-console-498561192">Raspberry Pi Game Console</a> - 用35美元搭建一个树莓派复古游戏机.</li></ul><h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><ul><li><a href="https://www.raspberrypi.org/forums/">Official Forum</a></li><li><a href="https://twitter.com/Raspberry_Pi"><code>@Raspberry_Pi</code> on Twitter</a></li><li><a href="https://webchat.freenode.net/?channels=%23raspberrypi"><code>#raspberrypi</code> on Freenode</a></li><li><a href="https://raspberrypi.stackexchange.com/">StackExchange</a></li><li><a href="https://www.reddit.com/r/raspberry_pi">Reddit</a></li><li><a href="https://www.reddit.com/r/RASPBERRY_PI_PROJECTS">Reddit Projects</a></li><li><a href="http://elinux.org/RPi_Hub">eLinux Hub</a></li></ul><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><p>   可以在这里找到<a href="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/CONTRIBUTING.md">贡献指南</a></p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>   <a href="https://creativecommons.org/publicdomain/zero/1.0/"><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/raspi_source/media/badges/687474703a2f2f6d6972726f72732e6372656174697665636f6d6d6f6e732e6f72672f70726573736b69742f627574746f6e732f38387833312f7376672f63632d7a65726f2e737667.svg" alt="CC0"></a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>awesome</tag>
      
      <tag>raspberry-pi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于PrimoCache的硬盘缓存加速</title>
    <link href="/2020/06/hd-cache/"/>
    <url>/2020/06/hd-cache/</url>
    
    <content type="html"><![CDATA[<p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/primocache/20200620173204.png"></p><p>目前随着硬盘发展的趋势，越来越多的硬盘采用了SMR存储技术，厂商依托这个技术节省了成本，但是用户却常常饱受硬盘掉速的困扰。</p><p><strong>如下图所示👇</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/primocache/1592645713715.jpeg">希捷酷鱼全线SMR</p><p>在进行大文件（10G左右）读写的时候就会有明显的感受，看着这十几万的延迟，不得不说👴要等吐了！</p><p>由此可见SMR硬盘是有多么依赖缓存空间！！！</p><h4 id="下面有请SMR救星PrimoCache上场！"><a href="#下面有请SMR救星PrimoCache上场！" class="headerlink" title="下面有请SMR救星PrimoCache上场！"></a>下面有请SMR救星<a href="https://www.romexsoftware.com/zh-cn/primo-cache/index.html">PrimoCache</a>上场！</h4><p>先看看加速效果：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/primocache/1592645718106.jpeg">过于暴力的测试数据</p><h3 id="PrimoCache的使用方法"><a href="#PrimoCache的使用方法" class="headerlink" title="PrimoCache的使用方法"></a>PrimoCache的使用方法</h3><ul><li><strong>前期准备</strong></li></ul><p>1）前往<a href="https://www.romexsoftware.com/zh-cn/primo-cache/index.html">PrimoCache官网</a>下载正版付费软件</p><p> 注：<a href="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/primocache/PrimoCache%20v3.09.zip">用于学习研究的小伙伴可以点这个链接</a>进行下载</p><p>2）按照流程进行安装（等一些列操作）</p><ul><li><strong>开始配置PrimoCache</strong></li></ul><p>1）创建加速任务</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/primocache/1.png"></p><p>2）选择需要加速的硬盘</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/primocache/2.png"></p><p>在这里选择你想要加速度的硬盘，通常选择你想要拯救的SMR盘</p><p>3）配置缓存策略</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/primocache/3.png"></p><p><strong>L1级缓存</strong></p><p>通过分配一部分内存空间来作为硬盘缓存分区，根据自己的电脑配置来分配空间大小。</p><p>通常来说不必分太大的内存，L1级缓存的作用一般只用于加速碎片文件的读写，体积通常不会太大。</p><p><strong>L2级缓存</strong></p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/primocache/4.png"></p><p>先将SSD分配一块空白区域，<strong>单独分为一块磁盘分区</strong>。</p><p>选择刚刚分好的分区，并分配用于读和写的缓存空间。</p><p><strong>缓存粒度</strong></p><p>数值越小 | 加速效果越好 | CPU占用越高</p><p>数值越大 | 加速效果次之 | CPU占用越低</p><p><strong>预取设置</strong></p><p>最好别开机预取，不然电脑开机得开几十分钟！！！</p><p><strong>注意：</strong>未开启预取，意味着如果在缓存没有完全写入目标磁盘前<strong>关机</strong>、<strong>断电</strong>等情况出现你将会面临<strong>数据丢失</strong>！！！</p><ul><li><strong>配置完毕点击启动！！！</strong></li></ul><h3 id="小技巧："><a href="#小技巧：" class="headerlink" title="小技巧："></a><strong>小技巧：</strong></h3><p>如何确定缓存是否完全写入目标磁盘?</p><ol><li>打开<strong>任务管理器</strong></li><li>点击<strong>性能</strong>查看磁盘详情</li><li>观察目标磁盘<strong>活动时间</strong>和<strong>延迟</strong>，如果活动时间占比长时间小于20%且延迟小于10ms基本可以判断已完成写入！</li></ol>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>IT小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cache</tag>
      
      <tag>smr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BP神经网络</title>
    <link href="/2020/06/bpnn/"/>
    <url>/2020/06/bpnn/</url>
    
    <content type="html"><![CDATA[<p>人工神经网络(Artificial Neural Network,简称 ANN)是利用仿生原理对人脑神经网络的结构和功能的简化抽象。人工神经网络是一种可以并行分散处理数据，具有非线性映射、容错能力强、自适应学习进化的特点。BP人工神经网络是在此基础上，基于误差反向传播算法而设计的多层前向神经网络。因其能够实现输入与输出间任意的非线性映射，因此在模式识别、自适应控制、风险评估等领域有着广泛的应用。</p><p>BP(back propagation)神经网络是1986年由Rumelhart和McClelland为首的科学家提出的概念，是一种按照误差逆向传播算法训练的多层前馈神经网络，是应用最广泛的神经网络。</p><h4 id="BP神经网络的基本原理"><a href="#BP神经网络的基本原理" class="headerlink" title="BP神经网络的基本原理"></a>BP神经网络的基本原理</h4><p>BP算法在神经网络训练中是一个十分典型的学习算法。其构成如下：一个输入层，一个或者多个隐含层和一个输出层构成，各层又由若干个神经元节点构成，每个神经元的输出值由其输入值、传递函数、阈值所决定。神经网络的学习过程包括了正向传播和反向传播两个过程。正向传播的过程中，在输入层输出数据，经过隐含层一系列运算后，将输出层得到的结果与期望值比较，得到误差取值。若误差大于某个范围则进行反向传播，根据上一层的误差，对该层神经元的权值和阈值进行相应的修改，从而减小误差。如此循环，直到误差在精度范围内或者达到训练终止条件为止。</p><h4 id="BP神经网络的训练方法"><a href="#BP神经网络的训练方法" class="headerlink" title="BP神经网络的训练方法"></a>BP神经网络的训练方法</h4><p>BP神经网络的基本训练步骤如下：</p><ol><li>BP神经网络的构建和初始化，确定隐含层层数，确定各层的节点数，随机生成各个节点的权值和阈值；</li><li>输入训练数据集，训练输入数据以及其对应的输出数据；</li><li>根据输入样本计算输出数据；</li><li>根据输出数据和期望数据计算误差，并判定是否达到精度，若达到精度就停止运行并取得各节点权值和阈值，否则继续执行（5）；</li><li>根据误差反向传播，修正各层各节点的权值和阈值；</li><li>继续执行（3）。</li></ol><h4 id="基本BP神经网络的构建与训练（Python）"><a href="#基本BP神经网络的构建与训练（Python）" class="headerlink" title="基本BP神经网络的构建与训练（Python）"></a>基本BP神经网络的构建与训练（Python）</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> numpy as np<br><br><span class="hljs-comment">#sigmoid 激活函数</span><br><span class="hljs-attribute">def</span> sigmoid1(x):<br><span class="hljs-attribute">a</span>=<span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+np.exp(-x))<br><span class="hljs-attribute">return</span> a<br><br><span class="hljs-comment">#训练集</span><br><span class="hljs-attribute">training_set</span>=np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]])<br><span class="hljs-attribute">yy</span>=np.zeros((<span class="hljs-number">4</span>,<span class="hljs-number">1</span>))<br><span class="hljs-attribute">eta</span>=<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><br><span class="hljs-comment">#定义连接权、阈值</span><br><span class="hljs-attribute">vih</span>=np.random.rand(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)#输入层与隐层连接权<br><span class="hljs-attribute">delt_vih</span>=np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))<br><span class="hljs-attribute">r</span>=np.random.rand(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)#隐层阈值<br><span class="hljs-attribute">delt_r</span>=np.zeros((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br><span class="hljs-attribute">whj</span>=np.random.rand(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)#隐层与输出层连接权<br><span class="hljs-attribute">delt_whj</span>=np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))<br><span class="hljs-attribute">o</span>=np.random.rand(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)#输出层阈值<br><span class="hljs-attribute">delt_o</span>=np.zeros((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br><span class="hljs-comment">#创建隐层</span><br><br><span class="hljs-attribute">alph</span>=np.zeros((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br><span class="hljs-attribute">b</span>=np.zeros((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br><span class="hljs-attribute">e</span>=np.zeros((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))#隐层梯度项<br><span class="hljs-comment">#创建输出层</span><br><span class="hljs-attribute">beita</span>=np.zeros((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br><span class="hljs-attribute">y</span>=np.zeros((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br><span class="hljs-attribute">g</span>=np.zeros((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))#输出层梯度项<br><span class="hljs-comment">#开始训练</span><br><span class="hljs-attribute">times</span>=input(How many times do you want to train:\n)<br><span class="hljs-attribute">times</span>=int(times)<br><span class="hljs-attribute">for</span> daishu in range(<span class="hljs-number">0</span>,times):<br><span class="hljs-attribute">for</span> train in range(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>):<br><span class="hljs-comment">#计算隐层的输入</span><br><span class="hljs-attribute">alph</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=vih[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]*training_set[train,<span class="hljs-number">0</span>]+vih[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]*training_set[train,<span class="hljs-number">1</span>]<br><span class="hljs-attribute">alph</span>[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]=vih[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]*training_set[train,<span class="hljs-number">0</span>]+vih[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]*training_set[train,<span class="hljs-number">1</span>]<br><span class="hljs-comment">#计算隐层输出</span><br><span class="hljs-attribute">b</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=sigmoid1(alph[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]-r[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])<br><span class="hljs-attribute">b</span>[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]=sigmoid1(alph[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]-r[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])<br><span class="hljs-comment">#计算输出层的输入</span><br><span class="hljs-attribute">beita</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=whj[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]*b[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]+whj[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]*b[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br><span class="hljs-comment">#输出层输出</span><br><span class="hljs-attribute">y</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=sigmoid1(beita[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]-o[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])<br><span class="hljs-attribute">yy</span>[train,<span class="hljs-number">0</span>]=y[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><span class="hljs-comment">#输出层梯度项</span><br><span class="hljs-attribute">g</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=y[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]*(<span class="hljs-number">1</span>-y[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])*(training_set[train,<span class="hljs-number">2</span>]-y[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])<br><span class="hljs-comment">#隐层梯度项</span><br><span class="hljs-attribute">e</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=b[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]*(<span class="hljs-number">1</span>-b[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])*(whj[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]*g[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])<br><span class="hljs-attribute">e</span>[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]=b[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]*(<span class="hljs-number">1</span>-b[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])*(whj[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]*g[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])<br><span class="hljs-comment">#更新连接权和阈值</span><br><span class="hljs-attribute">delt_whj</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=eta*g[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]*b[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><span class="hljs-attribute">delt_whj</span>[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]=eta*g[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]*b[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br><span class="hljs-attribute">whj</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=delt_whj[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]+whj[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><span class="hljs-attribute">whj</span>[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]=delt_whj[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]+whj[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br><span class="hljs-attribute">delt_o</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=-(eta*g[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])<br><span class="hljs-attribute">o</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=delt_o[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]+o[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><span class="hljs-attribute">delt_vih</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=eta*e[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]*training_set[train,<span class="hljs-number">0</span>]<br><span class="hljs-attribute">delt_vih</span>[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]=eta*e[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]*training_set[train,<span class="hljs-number">1</span>]<br><span class="hljs-attribute">delt_vih</span>[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]=eta*e[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]*training_set[train,<span class="hljs-number">0</span>]<br><span class="hljs-attribute">delt_vih</span>[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]=eta*e[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]*training_set[train,<span class="hljs-number">1</span>]<br><span class="hljs-attribute">vih</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=vih[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]+delt_vih[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><span class="hljs-attribute">vih</span>[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]=vih[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]+delt_vih[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br><span class="hljs-attribute">vih</span>[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]=vih[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]+delt_vih[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br><span class="hljs-attribute">vih</span>[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]=vih[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]+delt_vih[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br><span class="hljs-attribute">delt_r</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=-(eta*e[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])<br><span class="hljs-attribute">delt_r</span>[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]=-(eta*e[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])<br><span class="hljs-attribute">r</span>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=delt_r[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]+r[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><span class="hljs-attribute">r</span>[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]=delt_r[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]+r[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br><br><span class="hljs-attribute">training_set</span>=training_set.astype(np.float64)<br><span class="hljs-attribute">training_set</span>[:,<span class="hljs-number">2</span>]=yy[:,<span class="hljs-number">0</span>]<br><span class="hljs-attribute">print</span>(Output:)<br><span class="hljs-attribute">print</span>(training_set)<br></code></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/BPNN/BP.png" alt="/"></p><h4 id="BP神经网络函数逼近实验"><a href="#BP神经网络函数逼近实验" class="headerlink" title="BP神经网络函数逼近实验"></a>BP神经网络函数逼近实验</h4><p>网络构建模型：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/BPNN/%E5%87%BD%E6%95%B0%E9%80%BC%E8%BF%911-768x448.jpg">神经网络模型</p><p><strong>对函数 f(x)&#x3D;x2&#x2F;3 +0.9√(3.3-x2 )×sin(31.41593x)的拟合（Python ）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> time<br><span class="hljs-comment">#计时</span><br>start=time.time()<br><span class="hljs-comment"># 取得样本</span><br>x = np.linspace(-<span class="hljs-number">1.81659</span>,<span class="hljs-number">1.81659</span>,<span class="hljs-number">100</span>)<span class="hljs-comment">#获取-10 到 10 之间距离相等的 10000 个点，作为 x 取值。</span><br>x_size = x.size<br>y = np.zeros((x_size,<span class="hljs-number">1</span>))<span class="hljs-comment">#生成 y 数组</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(x_size):<br>y[i]= math.<span class="hljs-built_in">pow</span>(math.<span class="hljs-built_in">pow</span>(x[i],<span class="hljs-number">2</span>),<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)+<span class="hljs-number">0.9</span>*math.<span class="hljs-built_in">pow</span>((<span class="hljs-number">3.3</span>-<br>math.<span class="hljs-built_in">pow</span>(x[i],<span class="hljs-number">2</span>)),<span class="hljs-number">0.5</span>)*math.sin(<span class="hljs-number">10</span>*math.pi*x[i])<span class="hljs-comment">#得到样本集</span><br><br><span class="hljs-comment">#网络参数</span><br>hidesize = <span class="hljs-number">5</span> <span class="hljs-comment">#隐层神经元个数</span><br>W1 = np.random.random((hidesize,<span class="hljs-number">1</span>)) <span class="hljs-comment">#输入层与隐层之间的权重</span><br>B1 = np.random.random((hidesize,<span class="hljs-number">1</span>)) <span class="hljs-comment">#隐含层神经元的阈值</span><br>W2 = np.random.random((<span class="hljs-number">1</span>,hidesize)) <span class="hljs-comment">#隐含层与输出层之间的权重</span><br>B2 = np.random.random((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) <span class="hljs-comment">#输出层神经元的阈值</span><br>threshold = <span class="hljs-number">0.05</span><span class="hljs-comment">#速率</span><br>max_steps = <span class="hljs-number">1001</span><span class="hljs-comment">#训练次数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x_</span>):<span class="hljs-comment">#激活函数</span><br>y_ = <span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+math.exp(-x_))<br><span class="hljs-keyword">return</span> y_<br><br><span class="hljs-comment">#开始训练</span><br>E = np.zeros((max_steps,<span class="hljs-number">1</span>))<span class="hljs-comment">#误差随迭代次数的变化</span><br>Y = np.zeros((x_size,<span class="hljs-number">1</span>)) <span class="hljs-comment"># 模型的输出结果</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_steps):<br>temp = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(x_size):<br><br><span class="hljs-comment">#正向传播</span><br>hide_in = np.dot(x[i],W1)-B1 <span class="hljs-comment"># 隐含层输入数据</span><br>hide_out = np.zeros((hidesize,<span class="hljs-number">1</span>)) <span class="hljs-comment">#隐含层的输出数据</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(hidesize):<br>hide_out[j] = sigmoid(hide_in[j])<br>y_out = np.dot(W2,hide_out) - B2 <span class="hljs-comment">#模型输出</span><br>Y[i] = y_out<br>e = y_out - y[i] <span class="hljs-comment">#模型输出减去实际结果。得出误差</span><br><br><span class="hljs-comment">#反向传播</span><br>dB2 = -<span class="hljs-number">1</span>*threshold*e<span class="hljs-comment">#输出层阈值误差</span><br>dW2 = e*threshold*np.transpose(hide_out)<span class="hljs-comment">#输出层权值误差</span><br>dB1 = np.zeros((hidesize,<span class="hljs-number">1</span>))<span class="hljs-comment">#输入层阈值误差</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(hidesize):<br>dB1[j] = np.dot(np.dot(W2[<span class="hljs-number">0</span>][j],sigmoid(hide_in[j])),(<span class="hljs-number">1</span>-sigmoid(hide_in[j]))*(-<br>*e*threshold)<br>dW1 = np.zeros((hidesize,<span class="hljs-number">1</span>))<span class="hljs-comment">#输出层权值误差</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(hidesize):<br>dW1[j] = np.dot(np.dot(W2[<span class="hljs-number">0</span>][j],sigmoid(hide_in[j])),(<span class="hljs-number">1</span>-<br>sigmoid(hide_in[j]))*x[i]*e*threshold)<br><span class="hljs-comment">#参数修正</span><br>W1 = W1 - dW1<br>B1 = B1 - dB1<br>W2 = W2 - dW2<br>B2 = B2 - dB2<br>temp = temp + <span class="hljs-built_in">abs</span>(e)<br><br>E[k] = temp<br><span class="hljs-comment">#训练进度</span><br><span class="hljs-keyword">if</span> k%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;已训练%d 次&#x27;</span>%k)<br>stop=time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;训练用时%ds&#x27;</span>%(stop-start))<br><br><span class="hljs-comment">#训练结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输入层权值 w1：&#x27;</span>)<br><span class="hljs-built_in">print</span>(W1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输入层阈值 b1：&#x27;</span>)<br><span class="hljs-built_in">print</span>(B1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输出层权值 w2：&#x27;</span>)<br><span class="hljs-built_in">print</span>(W2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输出层阈值 b2：&#x27;</span>)<br><span class="hljs-built_in">print</span>(B2)<br><span class="hljs-comment">#拟合曲线</span><br>plt.figure()<br>plt.plot(x,y)<br>plt.plot(x,Y,color=<span class="hljs-string">&#x27;red&#x27;</span>,linestyle=<span class="hljs-string">&#x27;--&#x27;</span>)<br><br>plt.show()<br><span class="hljs-comment">#误差变化</span><br>steps = np.linspace(<span class="hljs-number">0</span>,max_steps,max_steps)<br>plt.figure()<br>plt.plot(steps,E)<br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>第一组测试结果：</strong></p><p>样本数量 100，训练次数 1000，训练速率 0.05</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs inform7">已训练 0 次<br>训练用时 0s<br>已训练 100 次<br>训练用时 1s<br>已训练 200 次<br>训练用时 2s<br>已训练 300 次<br>训练用时 3s<br>已训练 400 次<br>训练用时 4s<br>已训练 500 次<br>训练用时 5s<br>已训练 600 次<br>训练用时 6s<br>已训练 700 次<br>训练用时 8s<br>已训练 800 次<br>训练用时 9s<br>已训练 900 次<br>训练用时 10s<br>已训练 1000 次<br>训练用时 11s<br>输入层权值 w1：<br><span class="hljs-comment">[<span class="hljs-comment">[ 3.12169479]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[-0.12887541]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[-3.3705294 ]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[ 0.68280681]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[-0.15176392]</span>]</span><br>输入层阈值 b1：<br><span class="hljs-comment">[<span class="hljs-comment">[2.41933289]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[2.5423254 ]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[2.67626102]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[2.92251419]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[2.58144723]</span>]</span><br>输出层权值 w2：<br><span class="hljs-comment">[<span class="hljs-comment">[1.25280733]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[0.07273052]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[1.29053161]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[0.28913382]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[0.09012128]</span>]</span><br>输出层阈值 b2：<br><span class="hljs-comment">[<span class="hljs-comment">[-0.13334891]</span>]</span><br></code></pre></td></tr></table></figure><p>拟合曲线：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/BPNN/%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF1.jpg" alt="拟合曲线-1"></p><p>误差曲线：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/BPNN/%E8%AF%AF%E5%B7%AE%E6%9B%B2%E7%BA%BF1.png" alt="误差曲线-1"></p><p><strong>第二组测试结果：</strong></p><p>样本数量 10000，训练次数 1000，训练速率 0.05</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs inform7">已训练 0 次<br>训练用时 1s<br>已训练 100 次<br>训练用时 114s<br>已训练 200 次<br>训练用时 227s<br><br>已训练 300 次<br>训练用时 341s<br>已训练 400 次<br>训练用时 454s<br>已训练 500 次<br>训练用时 567s<br>已训练 600 次<br>训练用时 680s<br>已训练 700 次<br>训练用时 793s<br>已训练 800 次<br>训练用时 907s<br>已训练 900 次<br>训练用时 1020s<br>已训练 1000 次<br>训练用时 1134s<br>输入层权值 w1：<br><span class="hljs-comment">[<span class="hljs-comment">[-9.34109363]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[-6.26655843]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[ 0.38915887]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[-2.666515 ]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[-2.69118967]</span>]</span><br>输入层阈值 b1：<br><span class="hljs-comment">[<span class="hljs-comment">[ 1.47712007]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[ 4.86462404]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[-2.89037925]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[ 1.12851018]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[ 1.31828715]</span>]</span><br>输出层权值 w2：<br><span class="hljs-comment">[<span class="hljs-comment">[3.28226408]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[4.90921857]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[4.96920982]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[-4.36115203]</span></span><br><span class="hljs-comment"><span class="hljs-comment">[-4.59367305]</span>]</span><br>输出层阈值 b2：<br><span class="hljs-comment">[<span class="hljs-comment">[3.29980763]</span>]</span><br></code></pre></td></tr></table></figure><p>拟合曲线：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/BPNN/%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF2.jpg" alt="拟合曲线-2"></p><p>误差曲线：</p><p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/BPNN/%E8%AF%AF%E5%B7%AE%E6%9B%B2%E7%BA%BF2.png" alt="误差曲线-2"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>nn</tag>
      
      <tag>pnn</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>感知器（神经网络模型）</title>
    <link href="/2020/06/pnn/"/>
    <url>/2020/06/pnn/</url>
    
    <content type="html"><![CDATA[<p><strong>感知器</strong>是人工神经网络中的一种典型结构， 它的主要的特点是结构简单，对所能解决的问题 存在着收敛算法，并能从数学上严格证明，从而对神经网络研究起了重要的推动作用。</p><p><strong>感知器</strong>，也可翻译为<strong>感知机</strong>，是Frank Rosenblatt在1957年就职于Cornell航空实验室(Cornell Aeronautical Laboratory)时所发明的一种人工神经网络。它可以被视为一种最简单形式的前馈式人工神经网络，是一种二元线性分类器。 Frank Rosenblatt给出了相应的感知器学习算法，常用的有感知机学习、最小二乘法和梯度下降法。譬如，感知机利用梯度下降法对损失函数进行极小化，求出可将训练数据进行线性划分的分离超平面，从而求得感知器模型。</p><p>感知器是生物神经细胞的简单抽象，如右图.神经细胞结构大致可分为：树突、突触、</p><p><a href="https://baike.baidu.com/pic/%E6%84%9F%E7%9F%A5%E5%99%A8/16525448/0/810a19d8bc3eb1357c1bdf11a41ea8d3fc1f44bf?fr=lemma&ct=single" title="图1.神经细胞示意图"><img src="https://bkimg.cdn.bcebos.com/pic/810a19d8bc3eb1357c1bdf11a41ea8d3fc1f44bf?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1" alt="图1.神经细胞示意图"></a></p><p>神经细胞示意图</p><p>细胞体及轴突。单个神经细胞可被视为一种只有两种状态的机器——激动时为‘是’，而未激动时为‘否’。</p><p> 神经细胞的状态取决于从其它的神经细胞收到的输入信号量，及突触的强度（抑制或加强）。当信号量总和超过了某个阈值时，细胞体就会激动，产生电脉冲。电脉冲沿着轴突并通过突触传递到其它神经元。为了模拟神经细胞行为，与之对应的感知机基础概念被提出，如权量（突触）、偏置（阈值）及激活函数（细胞体）。 在人工神经网络领域中，感知器也被指为单层的人工神经网络，以区别于较复杂的多层感知器（Multilayer Perceptron）。 作为一种线性分类器，（单层）感知器可说是最简单的前向人工神经网络形式。尽管结构简单，感知器能够学习并解决相当复杂的问题。感知器主要的本质缺陷是它不能处理线性不可分问题。</p><h3 id="模型构建的代码实现（Python）"><a href="#模型构建的代码实现（Python）" class="headerlink" title="模型构建的代码实现（Python）"></a>模型构建的代码实现（Python）</h3><p>单层感知器模型</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import numpy as np<br><span class="hljs-comment">#sigmoid 激活函数</span><br>def nonlin(x, deriv = <span class="hljs-literal">False</span>):<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">deriv</span>==True):<br>return x*(1-x)<br>return 1/(1+np.exp(-x))<br><br><span class="hljs-comment">#输入-输出</span><br><span class="hljs-comment">#[0,0,1]-0</span><br><span class="hljs-comment">#[0,1,1]-1</span><br><span class="hljs-comment">#[1,0,1]-1</span><br><span class="hljs-comment">#[1,1,1]-0</span><br><br><span class="hljs-comment">#输入矩阵</span><br><span class="hljs-attribute">X</span>=np.array([[0,0,1],<br>[0,1,1],<br>[1,0,1],<br>[1,1,1]])<br><br><span class="hljs-comment"># 目标矩阵</span><br><span class="hljs-attribute">y</span>=np.array([[0,1,0,1]]).T<br><br><span class="hljs-comment">#生成随机权重</span><br>np.random.seed()<br>weight = np.random.random((3,1))<br><br><span class="hljs-comment">#训练次数</span><br><span class="hljs-attribute">times</span>=input(How many times you want <span class="hljs-keyword">to</span> train:\n)<br><span class="hljs-attribute">times</span>=int(times)<br><br><span class="hljs-comment">#训练开始</span><br><span class="hljs-keyword">for</span> iter <span class="hljs-keyword">in</span> range(times):<br>#计算输出<br><span class="hljs-attribute">L0</span>=X<br><span class="hljs-attribute">L1</span>=nonlin(np.dot(L0,weight))<br>#计算误差<br><span class="hljs-attribute">L1_error</span>=y-L1<br>L1_delta = L1_error*nonlin(L1,<span class="hljs-literal">True</span>)<br>#更新权重<br><br>weight+=np.dot(L0.T,L1_delta)<br><br><span class="hljs-built_in">print</span>(Output After Training:)<br><span class="hljs-built_in">print</span>(L1)<br><span class="hljs-built_in">print</span>(The Weight After Training:)<br><span class="hljs-built_in">print</span>(weight)<br><br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua">How many times you want to train:<br><span class="hljs-number">10000</span><br>Output After Training:<br><span class="hljs-string">[[0.00966633]</span><br><span class="hljs-string">[0.99359071]</span><br><span class="hljs-string">[0.00786352]</span><br><span class="hljs-string">[0.99211866]]</span><br>The Weight After Training:<br><span class="hljs-string">[[-0.20823225]</span><br><span class="hljs-string">. [ 9.67307298]</span><br><span class="hljs-string">. [-4.6294448 ]]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Algorithm</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>nn</tag>
      
      <tag>pnn</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 命令行下配置 wlan 无线网卡</title>
    <link href="/2020/06/linux-wifi/"/>
    <url>/2020/06/linux-wifi/</url>
    
    <content type="html"><![CDATA[<p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Gallery/2022/11/28/1024px-WiFi_Logo.svg.png"><br>Linux 命令行下配置连接 wlan 无线网卡具体步骤参考。</p><p>工作的大体思路如下：</p><ul><li>用iwconfig开启无线网卡的电源，并查找区域内的无线网络</li><li>连接到相应的无线网络</li><li>通过ifconfig启用无线网卡，并获取IP（如果使用DHCP的话）</li></ul><p><strong>注意：</strong></p><p>假设无线被识别为 wlan0，如果您的网卡没有被识别为 wlan0，可以在操作时做相应的修改。</p><p><strong>具体步骤</strong>：</p><ul><li>打开无线网卡电源</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">iwconfig</span> wlan0 txpower <span class="hljs-literal">on</span><br></code></pre></td></tr></table></figure><ul><li>列出区域内的无线网络</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">iwlist wlan0 <span class="hljs-built_in">scan</span><br></code></pre></td></tr></table></figure><ul><li>假设要连接到网络MyHome（即essid为MyHome的网络），那么输入命令</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">iwconfig</span> wlan0 essid “MyHome”<br></code></pre></td></tr></table></figure><ul><li>如果网络是加密的，密码是0123456789，那么就输入命令</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">iwconfig</span> wlan0 essid “MyHome” key <span class="hljs-number">0123</span>-<span class="hljs-number">4567</span>-<span class="hljs-number">89</span><br></code></pre></td></tr></table></figure><ul><li>如果正常的话，输入</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">iwconfig</span> wlan0<br></code></pre></td></tr></table></figure><p>就可以看到连接正常的各项参数了。</p><ul><li>启用无线网卡</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ifconfig</span> wlan0 up<br></code></pre></td></tr></table></figure><ul><li>如果是用 DHCP 获取 IP 的，那么用 dhclient 或 dhcpcd 获取 ip</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">dhclient</span> wlan0<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">dhcpcd wla<span class="hljs-symbol">n0</span><br></code></pre></td></tr></table></figure><ul><li>现在无线网卡应该可以正常使用了</li></ul><p><strong>注意：一定要把 NetworkManager 服务停掉</strong></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>Usage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>wifi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ras-Pi的VPN设置</title>
    <link href="/2020/06/raspi-vpn/"/>
    <url>/2020/06/raspi-vpn/</url>
    
    <content type="html"><![CDATA[<p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/rasp-pi_vpn/86d8d8ae30cd6d7043056c6766004a68_waifu2x_4x_2n_jpg-768x699.png"></p><h2 id="基于PPTP协议的VPN连接"><a href="#基于PPTP协议的VPN连接" class="headerlink" title="基于PPTP协议的VPN连接"></a>基于PPTP协议的VPN连接</h2><h3 id="前提条件："><a href="#前提条件：" class="headerlink" title="前提条件："></a>前提条件：</h3><ol><li>拥有一台已经配置好的PPTP服务器</li><li>可以正常使用的任意Linux发行版（Debian为例）</li></ol><h3 id="操作方法："><a href="#操作方法：" class="headerlink" title="操作方法："></a>操作方法：</h3><ul><li>安装PPTP-Linux客户端</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install -y pptp-linux<br></code></pre></td></tr></table></figure><ul><li>配置客户端信息</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>ppp<span class="hljs-regexp">/peers/</span>pptpconf<br><br><span class="hljs-regexp">//</span> 添加如下内容：（自行更改IP, name, password）<br>pty pptp xxx.xxx.xxx.xxx --nolaunchpppd<br>name xxx<br>password xxx<br>remotename PPTP<br>require-mppe-<span class="hljs-number">128</span><br>require-mschap-v2<br>refuse-eap<br>refuse-pap<br>refuse-chap<br>refuse-mschap<br>noauth<br>persist<br>maxfail <span class="hljs-number">0</span><br>defaultroute<br>replacedefaultroute<br>usepeerdns<br></code></pre></td></tr></table></figure><ul><li>启动和关闭</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pptp</span> 客户端操作： <br>启动：pon pptpconf <br>关闭：poff pptpconf<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
      <category>ARM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raspberry-pi</tag>
      
      <tag>vpn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用docker部署WordPress</title>
    <link href="/2020/06/wordpress-docker/"/>
    <url>/2020/06/wordpress-docker/</url>
    
    <content type="html"><![CDATA[<p><img src="https://wpcos-1300629776.cos.ap-chengdu.myqcloud.com/Picture/wp/article/202006/wordpress_docker/34173314725397cecc026b7371fa78ee-1024x640.jpg"></p><h2 id="基于Docker的部署方案"><a href="#基于Docker的部署方案" class="headerlink" title="基于Docker的部署方案"></a>基于Docker的部署方案</h2><p>容器部署在Docker下部署WordPress的难点在于<strong>数据库的连接</strong>，下面给出一种可行的方案。</p><h3 id="前提条件："><a href="#前提条件：" class="headerlink" title="前提条件："></a>前提条件：</h3><ul><li>任意可以运行的Linux发行版</li><li>已安装完成Docker相关组件</li><li>完成了Docker镜像源相关的设置</li></ul><h3 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h3><h4 id="1-数据库容器配置"><a href="#1-数据库容器配置" class="headerlink" title="1. 数据库容器配置"></a>1. 数据库容器配置</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker pull MariaDB <span class="hljs-regexp">//</span>下载mysql镜像<br>docker volume create mysql1 <span class="hljs-regexp">//</span>创建数据卷<br>docker run -d --privileged=true --name my-mysql -v <span class="hljs-regexp">/data/my</span>sql:<span class="hljs-regexp">/var/</span>lib/mysql -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> -p <span class="hljs-number">33306</span>:<span class="hljs-number">3306</span> mariadb<br></code></pre></td></tr></table></figure><p>参数解释:</p><ul><li>-p: 端口映射，33306表示宿主，3306表示容器中的端口。 这里表示将宿主机的33306映射给镜像的3306。</li><li>-e: 环境变量， 环境变量和具体的Docker容器制作时设置有关，这里表示设置镜像中MySQL的root 密码时123456</li><li>-v: 指定数据卷，也就是将我们MySQL容器的&#x2F;var&#x2F;lib&#x2F;mysql映射到宿主机的&#x2F;data&#x2F;mysql</li><li>–privileged&#x3D;true: CentOS系统下的安全Selinux禁止了一些安全权限，导致MySQL容器在运行时会因为权限不足而报错，所以需要增加该选项</li></ul><h4 id="2-WordPress容器配置"><a href="#2-WordPress容器配置" class="headerlink" title="2. WordPress容器配置"></a>2. WordPress容器配置</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">docker pull wordpress <span class="hljs-comment">//下载镜像</span><br>docker run -d <span class="hljs-attr">--name</span> my-wp -e WORDPRESS_DB_HOST=mysql -e WORDPRESS_DB_PASSWORD=<span class="hljs-number">123456</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> <span class="hljs-attr">--link</span> my-mysql:mysql wordpress <span class="hljs-comment">//运行镜像创建容器</span><br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li>“WORDPRESS_DB_HOST”: 链接的docker的MySQL的IP地址和端口，一般设置成mysql表示用默认的设置</li><li>“WORDPRESS_DB_USER”: 以什么用户使用MySQL，默认是root</li><li>“WORDPRESS_DB_PASSWORD” 这设置MySQL的登陆用户密码，由于上一项是默认的root，所以这一项和之前的MYSQL_ROOT_PASSWORD“要相同。</li><li>WORDPRESS_DB_NAME”: 数据库的表名，不需要修改，用默认的”wordpress就行</li></ul><h4 id="3-进入Web界面设置"><a href="#3-进入Web界面设置" class="headerlink" title="3. 进入Web界面设置"></a>3. 进入Web界面设置</h4><p>浏览器地址栏输入IP:Port访问即可</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>categories</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>links</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h2 id="站点日志"><a href="#站点日志" class="headerlink" title="站点日志"></a>站点日志</h2><p>2020-6-20  Jason的小站终于从内网搬到服务器啦！！！</p><p>2020-6-21   暂定域名<a href="https://uestcpi.cn/">https://uestcpi.cn</a> | <a href="https://www.uestcpi.cn/">https://www.uestcpi.cn</a></p><p>2020-6-22  装修了一下主页，加了亿点点特效噢！COS对象存储服务部署完成。</p><p>2020-6-23  博客现在可以自己发送邮件啦！</p><p>2020-6-26  给网站注册了新的域名jason-xy.cn，现在正在备案呢。</p><p>2020-6-28  添加了后台统计功能，统计访客浏览信息。</p><p>2020-7-1    网站服务器更换为Debian LAMP框架。自动静态缓存部署完成。</p><p>2020-7-2    新域名<a href="https://jason-xy.cn/">https://jason-xy.cn</a> | <a href="https://jason-xy.cn上线/">https://jason-xy.cn上线</a> 。CDN内容分发网络部署完成。评论与回复模块添加完成。</p><p>2020-7-3    统计面板功能实现。社交分享与赞赏功能实现。修复Markdown语法高亮显示问题。</p><p>2020-7-20   移植Pi-Dashboard项目，给网站服务器添加了实时监控仪表盘。</p><p>2020-7-21   图床部署完成，所有图片及媒体完全移至腾讯云COS对象存储服务器。</p><p>2020-7-22   <a href="https://gallery.jason-xy.cn/">https://gallery.jason-xy.cn</a> 图床网站上线。完成动态网站的CDN静态缓存优化，解决账户登录实不及时刷新缓存问题。</p><p>2020-7-23   <a href="https://media.jason-xy.cn/">https://media.jason-xy.cn</a> 音乐小站上线。</p><p>2020-7-24   <a href="http://ebook.jason-xy.cn/">http://ebook.jason-xy.cn</a> 书库网站上线。爆肝一周丰富了网站资源，该认真预习期末考试了。</p><p>2020-7-25   由于带宽问题将书库搬到了内网，走纽约机房用frp内网穿透，理论100兆带宽，实测600ms、50Mbps。</p><p>2020-7-26   站点健康状态监控与提醒功能上线。</p><p>2020-8-11    由于网络连通性问题，frp代理服务器搬到了NJ，目前测试下载带宽500Mbps，上传带宽10Mbps。</p><p>2020-9-16   邮件服务器维修完成，感谢ROYLEO发现的BUG。</p><p>2022-12-11  腾讯云的三年学生优惠用完了，不打折实在太贵了，所以决定搬家到Github。</p><pre><code class="hljs">        更新：            1. 框架由wordpress换为hexo。            2. 服务器就直接用GitHub pages，正好还可以搭一个CI自动发布。            3. 考虑到GitHub国内访问体验不太好，所以还是做了CDN全球加速。            4. 域名用CNAME解析到jason-xy，尽量保持之前的文章链接不变。        下线：            1. https://gallery.jason-xy.cn图床下线 ，前端没了PicGo直连COS服务。            2. https://media.jason-xy.cn音乐小站下线 ，免费的API太少，之前的基本用不了，懒得维护了。            3. http://ebook.jason-xy.cn书库网站下线 ，书现在都放Goodnotes和zotero里面了，可以用iCloud和OneDrive同步，比放我的服务器更稳妥。            4. 站点监控功能下线，uptime定格在了1000多天，云服务器稳定性确实🐂🍺，现在换GitHub了只要CI不挂应该就不太需要监控了。</code></pre><script src="https://utteranc.es/client.js"        repo="Jason-xy/jason-xy.github.io"        issue-term="pathname"        label="💬"        theme="github-dark"        crossorigin="anonymous"        async></script>]]></content>
    
  </entry>
  
  
  
</search>
